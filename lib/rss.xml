<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[cs-learning-vault]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>cs-learning-vault</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 07 Mar 2025 08:51:11 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 07 Mar 2025 08:49:56 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[我的obsidian插件开发的学习过程]]></title><description><![CDATA[ 
 <br>来源网址: <a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/508345279" target="_blank">https://zhuanlan.zhihu.com/p/508345279</a><br>
裁剪时间: 2023-08-28 15:54:08<br><br><br>我学习javascript编程的最终目标是为了能够给自己做obsidian的插件，当我第一个插件做出来，我就明白要实现我的插件梦其实只需要时间了。因为obsidian的九成的插件都是开源的，你有大量的各种类型的源程序可以学习和借鉴。MDN和菜鸟上有最基础的语言知识。现在真是一个学习时代，影响学习效率最大的瓶径是我们自己。我尽量把插件开发相关的内容都放在这一篇文章里，所以这个文章是迭代。之所以这些方式来写文章，主要因为如果等所有任务完成再写文章，可能并不能如实反应真实的过程。如果有前后矛盾之处，我尽量不改原文，只是在后面补充内容并标注补充的时间。2022-05-03<br><br><br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//marcus.se.net/obsidian-plugin-docs/concepts/vault" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//marcus.se.net/obsidian-plugin-docs/concepts/vault" target="_blank">Vault | Obsidian Plugin Developer Docs</a><br>上面链接一个爱好者发布的obsidian开发文档，其实也来自官网的github的内容，它不象MDN对每个函数和变量的属性和方法都有描述和示例，这个网站只是把所有的api罗列清单，网站上api说明我没发现有什么价值，因为vscode查找定义结果是一样的。我只推荐学习这个网站的guide目录的内容，对开发插件涉及几个模块都有详细的说明及示例。建议在阅读其他人的插件源程序之前应该认真把上面每篇文章都认真学习一遍。可以少走很多弯路。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-7c6319fa9cc06131b427290bdfd0585b.webp"><br><br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-3db2a8665fd78dd620f3c6b9dc9e7c4a.webp"><br>
<br>git
<br>因为我在研究obsidian同步的时候对git有深入的了解，在插件开发之初git主要是用来下载源程序，方便不同场合代码同步。git其实比较简单，而且网上资源比较丰富，将来在很多地方都会用到，所以早学早享受。经过我测试，用git clone来下载程序经常因为网络的原因而报致命错误，直接在github的代码菜单里下载其压缩包成功率奇高。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-b287d1087f759b3832086c37b84fba12.webp"><br>
<br>node.js和typescript
<br>对于初学者node.js这是必须要安装的项目，因为根据官网的指南在本地把ts编译成js的npm命令都依赖node.js环境。如果开发工具用vscode开发最好把node.js和typescript的环境配置好，至于ES6还是typescript的选择，我在github上看大部分插件源程序repo都显示typescript占了八九成。不过国外obsidian论坛里有一个用户发言我觉得还是很中肯的，其实真正高手只要写原生的javascript就够了。不过根据我的经验，刚入门就如此，有点难度，没有指南很多流程都要自己琢磨，而且源代码的语法格式也不太一样。所以有时候我们选择某个流程或工具，不是因为它是最好，而是用得人多而己。这样我们在遇到问题时，至少还能找到资料。<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//forum.obsidian.md/t/how-to-get-started-with-developing-a-custom-plugin/8157/5" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//forum.obsidian.md/t/how-to-get-started-with-developing-a-custom-plugin/8157/5" target="_blank">How to get started with developing a custom Plugin?</a><br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-f9355631221939305b119ee6a5d3ae8b.webp"><br><br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-1652dd33a8941d175c05f3a2972ca7ed.webp"><br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//github.com/obsidianmd/obsidian-sample-plugin" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//github.com/obsidianmd/obsidian-sample-plugin" target="_blank">GitHub - obsidianmd/obsidian-sample-plugin​github.com/obsidianmd/obsidian-sample-plugin<span src="assets/1693209248-2c82c6cd32145b16c7c40a93251d9bd9.jpg" class="internal-embed media-embed image-embed is-loaded"></span></a><img src="00-obsidian的使用\99-剪藏\assets\1693209248-2c82c6cd32145b16c7c40a93251d9bd9.jpg"><br>官网建议开发之前先把sample库复制到自己github的库中。上面是obsidian sample-plugin库的链接地址，按步骤以此为模板在github创建一个自己的库。记住要改成自己的库的名字，如果看不到"use this template"这个菜单，是因为你没有登录github上。我自己在开发插件的时候，并没有创建这个库，直接把库复制到本地。放到测试库里插件目录(plugins)里，直接进行开发，我主要在单位就是学习知识和背诵卡片，在家里开发代码。如果你两边都要开发，还是码云上创建一个库更靠谱一点。<br><br>编程所需要引用三种模块：一个obsidian自身库中所有模块，node.js内置的四个模块，还有包括用户自定义模块的外置模块。引用语法common和es6都兼容，我开始编译时老早不到obsidian的库，后来发现有一些插件的源程序并不有把obsidian自带库上传到github上去，所以建议初学者务必按官网流程下载obsidian sample-plugin库，这个插件库最完整。初学者开始严格按官网流程，可以规避很多坑。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-5dee62d343aecdf1ee60fdd355bae8ae.webp"><br><br>我是修改Note Refacotr的时候涉及到这个概念，就大致了解一下，目前在obsidian国外论坛推荐两种测试框架：Jest和Mocha，下面是链接，这个资源站是官方提供还是爱好者整理的，我目前还没有整明白。只要你在论坛里问技术问题，就会被人推荐去访问这些资源，但资源很凌乱，不太象官网的资料。我对待测试框架和npm态度是：只要能用不影响我实现目标，我暂时不会深入的学习。因为我在写这段文章的时候，我只是停留在修改别人插件，而这些插件编译和测试的脚本都是别人配好的，每次编译都自动完成。如果想彻底搞明白这两样知识点，并会自己配置脚本，我估算一下这个坑比较大，要花费很多时间，目前目标还不需要我这样做。但我知道我最终要面对这个问题。<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//publish.obsidian.md/hub/04%2B-%2BGuides%2C%2BWorkflows%2C%2B%26%2BCourses/Guides/Why%2Bautomate%2Btests%2Bfor%2Bplugins" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//publish.obsidian.md/hub/04%2B-%2BGuides%252C%2BWorkflows%252C%2B%2526%2BCourses/Guides/Why%2Bautomate%2Btests%2Bfor%2Bplugins" target="_blank">https://publish.obsidian.md/hub/04+-+Guides%2C+Workflows%2C+%26+Courses/Guides/Why+automate+tests+for+plugins​publish.obsidian.md/hub/04+-+Guides%2C+Workflows%2C+%26+Courses/Guides/Why+automate+tests+for+plugins</a><br>所以我现在也只是有意识收集一些基础知识，比如脚本一些关键词我还是能看懂，一些简单的报错还能知道怎么改，等到时机成熟我再彻底学习一遍。下面的链接是知乎上对测试框架简单介绍，有兴趣的朋友可以了解一下。不过根据我的经验，除非你之前接触过这东西，不然看了还是一头雾水。但这也是学习一个复杂的知识点必备过程。评估难度决定挂起，研究前置条件，然后从简单术语开始，逐步深入等到正式启动这个任务时，你已经对知识点概念和环境有大致的了解，对后面学习也非常有帮助。added:2022-05-07<br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/448577649" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/448577649" target="_blank">优弧同学：2021 年 JavaScript 测试框架回顾1 赞同 · 0 评论文章</a><br><br>一般来说越是功能复杂的插件，主程序main.ts越简单，main.ts包括：引导部分，定义类型和全局变量。主类一般继承自plugin类，主要有onload和onunload两个方法组成。一些次要的功能一般都模块化。作为外部模块由主程序在其onload方法中调用其方法及属性即可。这样整个程序结构清晰，日后升级和修改也比较方便。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-71b0cf549326a503241ffef2951434ce.webp"><br>调用已经导入的外部模块和主类的方法的语法格式是一样的<br>
this.方法名 ：this.addCommand （），const { contentEl } = this;
<br>但也有完整路径的格式,因为workspace并没有做为模块导入，这里只是作为app的属性<br>
this.app.workspace.getActiveViewOfType(MarkdownView)
<br><br>因为之前我用quicker做一个却作，就是修改Note Refacotr的data.json文件，然后重载插件，对文件进行拆分。当时我对hot-fix的插件进行修改，只要data.json文件一改动，就自动重载插件。但我觉得这个插件用于开发比较合适但在平常使用会驻留内在占用资源。所以最好用命令行或侧边栏来启动，这样我可以用快捷键来重载插件。也可以让我的脚本每个过程都是可控的。所以我需要使用命令行方式来重载插件，只是实现这个功能就太简单了，所以我给自己又定更高的目标，就是用modal中suggestion模块实现在安装的所有插件清单里，随便选择一个插件重载。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-d33f41bea20cd7b85f5fbc5de77a3f16.webp"><br><br><br>devtool一些小技巧可以让开发效率大幅度提升，在开发插件过程中我又发现一个小技巧：它就是编译代码块的功能，因为插件开发api文档过于简陋，所有示例也没有描述。所以我只能通过在devtool的命令面板来敲命令来看看某个方法有什么参数，某个类有什么属性，返回值是什么？但有一个难题如果是循环语句这种代码块我直接敲出来会报错，所以我在网上找到可以通过在source面板新建snippet来实现对代码块的运行。这又解决了我一个大问题。如下图，你只要在左侧的snippet文件名点击右键会有"run"就可以运行你编写的代码块。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-8fdaf274ce941928555da4e0c07f552d.webp"><br><br>我编译ts文件一直用npx tsc，所以在开发之初我也用这个命令来编译main.ts文件，但出现很奇怪的现象，我的插件无法打开，一打开就报错。就这一问题我在国外obsidian论坛进行咨询，但很长时间也没有人理会我，老外还是很热情的，估计问题比较特殊，我当时卡在那里，这个问题在开发之初差点让我放弃了，后来我重新学习官网的插件开发说明，发现他推荐用npm run dev编译，我就死马就活马医，下载了npm，然后运行npm run dev之后就正常了。<br>开发插件过程中也就是这个坑比较深一点。但你只要按要求安装node.js和npm。在命令窗口进入开发插件目录，再运行npm run dev，再开始用vscode进行代码开发即可。<br><br>因为在研究obsidian同步的时候对git有深入的了解，开发之初git主要是用来下载源程序和办公室与家里同步。不过用git clone来下载程序经常因为网络的原因，经常报错，还不如直接下载其压缩包。<br><br><br>const ribbonIconEl = this.addRibbonIcon('dice', 'reload', (evt: MouseEvent) =&gt; {
			// Called when the user clicks the icon.
			this.reload('obsidian-sample-plugin');
		});
<br>dice是图标代表是骰子，reload：是提示语，鼠标放在图标上显示的提示字符，evt:事件 点击鼠标会执行reload这个方法。<br>如果想换图标可以下面的链接里查询：<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//forum.obsidian.md/t/list-of-available-icons-for-component-seticon/16332/4" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//forum.obsidian.md/t/list-of-available-icons-for-component-seticon/16332/4" target="_blank">List of available icons for component setIcon</a><br>侧边栏最简单，点击侧边栏上图标启动指定插件重载，这个功能主要为了熟悉侧边栏的开发。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-4388e7e5790e8e7416f6e53746e30b84.jpg"><br>00:05 / 00:07<br>倍速<br>高清<br><br>this.addCommand({
        id: "Excalidraw plugin",
        name: "Excalidraw plugin",
        callback: () =&gt; {
          this.reload("obsidian-excalidraw-plugin");        
         
        }
<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-b900399e566025f20795dbb807af0992.jpg"><br>00:21 / 00:20<br>倍速<br>高清<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-b900399e566025f20795dbb807af0992.jpg"><br>重新播放<br>通过命令行开启插件，本来只是想配合我的脚本来实现脚本的流程化。结果无意中发现，如果插件本来是关闭的，重载的插件可以启动这个插件，而且在ob重启后插件依然处于关闭状态，这样我就可以把不常用的插件都关闭，然后在使用的时候才重载。极大提高obsidian启动的速度。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-b900399e566025f20795dbb807af0992.jpg"><br>00:00 / 00:20<br>倍速<br>高清<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-b900399e566025f20795dbb807af0992.jpg"><br>00:20<br><br>开发这个功能主要是给自己找点别扭，并检验自己modal模块部分知识是否真正掌握了，开始本来想借用Auto Move Notes插件里现成的suggestion模块，读了程序之后才发现这位作者也是原样抄的另外一个插件模块，而那个插件模块做得太复杂了，涉及到我以后才会学到内容，我觉得原样调用对现在我没有意义，所以自己在官网示例的基础上做一个简单的suggestion模块，修改别人代码相对比较容易，不需要考虑很多细节。但自己从头开发真得难多了，发现自己基本功不扎实，一个简单的问题就能把我卡住，所以我干脆把类，接口，数组，对象，变量重新过一遍，做了导图。然后又用卡片复习巩固，自己觉得基本功扎实之后，再重新启动任务，很轻松完成了。<br>onChooseSuggestion(books, evt: MouseEvent | KeyboardEvent) {
	    this.item=selectedPlugin;//选中插件的ID赋于全局变量item
	   if(this.i==1){ this.reload(selectedPlugin);   } //根据调用参数确定调用方法
	   if(this.i==2){ this.disablepl(selectedPlugin);   }
		
	}
<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-e2361ad1338d9cffd79b0529ecf9e4ee.webp"><br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-b4271d9a4f8f7a177ac36eb08d559f12.jpg"><br>00:21 / 00:20<br>倍速<br>高清<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-b4271d9a4f8f7a177ac36eb08d559f12.jpg"><br>重新播放<br>选择框会根据输入的内容缩小选择范围，这其实是模块方法的内置的功能，但如果想正常使用，涉及到对象与数组类型转换，以及自定义类型和方法返回值的知识，这个浪费我一点时间，把基本功夯实才轻松解决。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-d753a1c173e8cbd338155a3c09ad2a81.jpg"><br>00:00 / 00:12<br>倍速<br>高清<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-d753a1c173e8cbd338155a3c09ad2a81.jpg"><br>00:12<br><br>设置页是插件结构中最复杂的部分，所以单独做一个章节。设置页主要包括两个类一个main.js中的主类，一个settings.ts，在示例sample-plugin中，虽然不有把settingtab单独设置一个文件，但也是samplSettingTab也是作为单独一个类来处理。<br>视频就是是最终的效果<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-94b74c752102dc33469b08e8488e4801.jpg"><br>00:00 / 00:14<br>倍速<br>高清<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-94b74c752102dc33469b08e8488e4801.jpg"><br>00:14<br><br>设置的类要想添加到面板上在main.js有几个要点。在变量方面主要程序要一个全局的缺省值，这样在初次使用可以把初始值赋给设置值来使用。另外在类中设置一个属性setting.用来保存设置值，当把this做为参数传递给设置页类class的时候。可以在设置页类中调用this.setting来对设置值进行操作。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-03cb495944da8593f31c4040f4cd0cd6.webp"><br><br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-828558cb29d26ff2bb80f39827194674.webp"><br>一个属性变量在使用前要经过三部曲：自定义类型-接口，声明，赋值（初次使用为默认值）。我开始对设置接口(interface)自定义类型不是特别理解，觉得完全没有必要。后来源程序看多了，就明白设置接口的目的主要还是规范代码管理，因为随着插件功能增强，设置变量种类越来越多，设置接口类型可以把变量进行分组管理。这样在以后调用过程中，思路比较清晰，也方便其他人阅读。比如下图就是Auto Note Mover插件的设置变量的接口设置。三个接口分别代表关于标签，排除路径，移动路径三个功能变量组。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-de58250495870a13bf4ea1484fb1997d.webp"><br>因为我第一个插件功能比较简单settingTab类只有一个属性，所以设置一个变量mySetting就够了.一个属性变量在使用前要经过三部曲：自定义类型-接口，声明，赋值（初次使用为默认值）。通过上面接口自定义类型，设默认值，下面我就要去声明这个变量，并使之为主类的属性。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-5c9af4b889d1daeab7126739d54d56c3.webp"><br>声明之后还要对这个变量进行赋值。这里使用了Object.assign,其含义是合并默认值及data.json的值。如果默认值与文件中值重复以文件的值为准。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-1330c5963c2005b0998c8286ffd883d0.webp"><br>下面我就看看我们如何调用这个属性变量。我对上面侧边栏做一些小的改动。根据设置页变量的改变其鼠标放到图标上后提示内容也做相应的改变，具体代码如下，在main.js的主类调用属性的格式：this.setting。<br>const ribbonIconEl = this.addRibbonIcon('dice', this.settings.mySetting, (evt: MouseEvent) =&gt; {
			// Called when the user clicks the icon.			
			this.reload(this.settings.mySetting)//重载setting属性中的mysetting值指定插件
		});
<br><br>设置页类的属性变量主要存放设置内容，而设置页的方法主要是操作Element元素，来完成设置页的构造。比如设置标题，说明及各种输入框和按钮。一般常用添加有动作元素都是用setting()来实现，设置的元素方法很多，详见下面的链接<br><a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//marcus.se.net/obsidian-plugin-docs/api/classes/Setting" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//marcus.se.net/obsidian-plugin-docs/api/classes/Setting" target="_blank">Setting | Obsidian Plugin Developer Docs</a><br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-c41857deeccda66281424c93dbafd3af.svg"><br>输入框addText和按钮addButton比较常见，也比较简单，我这里介绍是比较实用且相对有一定难度的选择输入框addSearch，在视频可以看到，他可能根据你输入关键词缩放提示项，它跟我主界面中实现原理和调用类都是类似，唯一的区别是参数el元素不同，这个参数决定了选择项显示位置，cb.inputEl是指在输入框下方显示,具体原理参照我上面suggestion类的原理导图，代码实现如下，<br>new Setting(containerEl)
			.setName('插件名')//设置输入框标题
			.setDesc('侧边栏重载的插件名设置') //输入注释说明
			.addSearch((cb) =&gt; {  //添加选项项输入框
				new PluginSuggest(this.app, cb.inputEl); //调用插件显示选择项模块
				cb.setValue(this.plugin.settings.mySetting) //把输入值赋给变量
				.onChange(async (value) =&gt; { //一旦内容变动
				   this.plugin.settings.mySetting = value; //输入内容输给变量
				   await this.plugin.saveSettings();//结果保存到data.json文件中
					});
			})
<br>
注意:设置页settingTab类中调用 主类plugin类中的设置变量setting的语法格式：this.plugin.settings.因为主类plugin类是作为参数进入设置页类settingTab，`this.addSettingTab(new SampleSettingTab(this.app, this));故主类plugin被定义为settingTab的类的属性，`this.plugin = plugin;`,故主类的属性setting,在settingTab调用语法格式为：this.plugin.settings.mySetting. 听起来有点绕口令，也只能说成这样了。
<br><br>之前用quicker做一个脚本，就是在Note Refacotr拆分笔记之前用来改变文件前缀和标签，当时用quicker的获取文本模块来实现的，为了能够让修改的data.json生效，还增加了插件重载的功能。掌握了插件开发技能之后，发现只要对Note Refacotr插件稍做一些完善就能实现这个功能。以后开发内容都放到这个文章里。<br><br>编译Note Refacotr源程序依赖是不完整的，需要从sample插件把obsidian的一些依赖给拷贝到node_modules目录即可，一般用vscode打开源码会提示缺少什么模块及模块名，你按照提示拷贝即可。在运行npm run dev上面提示缺什么就安装什么 npm install xxxx。另外需要设置的地方就是他编译成的main.js的目录为当前目录的dist目录下，你只要把在esbuild.config文件里把目录改成当前目录即可。<br><br>Note Refacotr很经典，但技术难度不高，主要是对编辑界面下的文本内容进行复制和剪切操作。但整个程序结构逻辑清晰和结构干净简洁，作者基本功很扎实。Note Refacotr是非常好进行入门临模的插件。下图就是效果，如果上面介绍的设置页部分能够理解，这个功能非常简单，就是增加一个settingModal.ts，用setting()的addTextArea增加两个多行文本即可。然后在命令行addcommand调用这个设置面板。2022-05-07 added<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-48c571b7bf1fa3314dc285089368d997.jpg"><br>00:00 / 00:49<br>倍速<br>高清<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-48c571b7bf1fa3314dc285089368d997.jpg"><br>00:49<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-792eafe90d54c188dbaf659c8a60ea4f.svg"><br><br>这个插件是作者是我们国人，主要功能有三个一个粘贴图片自动传到图床，一个把当前笔记中所有图片链接上传到图床，另一个把当前笔记图片下载。第一个功能很好用，但第二功能一直无法使用，没有任何反应。我到作者github上咨询发现很多人都有这个问题，我也追问把我现象描述出来，作者反馈是图床软件的版本问题，但我下载前面所有版本都测试不成功，作者反馈他按我的描述进行演示没有发现这个情况。源程序能够说明一切，我们看看他是怎么写的吧。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-4620da658c1724d391b35fb7777837eb.svg"><br>上面的代码的意思如果http开头不处理，也就是这个插件只上传存储在本地的图片。与时我又测试只有本地图片的笔记，但依然没任何的反应。那就看看他如何处理本地图片的链接的。这是抽取链接的正则表达式<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-355ee94cbf9a1b0f483eeb9825ffd38b.svg"><br>他的意思是抽取[]()两种地址。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-1709af28b499b893d5f20bbd954f8e64.svg"><br>这个代码的意思把（）中的作为地址，把[]作为名称，简单的说：就是这个插件它不支持较为简短的wiki形式的图片链接，就是下图的链接方式。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-698cd67ec2e791d9f452c754f21e4224.svg"><br>原来如此，所以我取消wiki的链接形式，但依然没有上传成功。why?<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-59cf74acb1d311ea72777042af2da50f.svg"><br>原来这里还有一句话，他又在原来地址前加上父路径。简单的说：他这个插件只支持用相对路径的图片链接。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-d73b4078e3b5a1eebca0eba6ef9b5152.svg"><br>图片改成相对地址的链接，这次上传终于成功了，所以这个插件只支持相对链接的本地图片上传到图床，既然看懂了源程序，对这个插件完善就相对比较简单了。中午大概用了半个小时就把这个软件稍做修改，基本完成图片链接都可以上传的功能，但觉得程序强壮性还有待考证，先使用一段时间观察观察。added: 2022-05-08。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-287059b5c3b3a7ae1f384c1eb0f7dfbb.jpg"><br>00:00 / 01:35<br>倍速<br>高清<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-287059b5c3b3a7ae1f384c1eb0f7dfbb.jpg"><br>01:35<br><br>Spaced Repetition是目前我使用最频繁的插件，因为使用的频繁，所以对他的一些bug就越发不能忍受，其实我学习插件开发大部分原因就是想改造这个插件。<br>复习笔记中时间偶尔会出现标签错乱，这个问题我向作者反馈了，而且之前半年前也有一个用户反应过这个问题，但都没有得到回应。估计作者暂时不会处理。只能自己来解决。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-42e2be81430f29bb3391ee0d6e4b0e25.svg"><br>因为从库里下载的源程序缺少两个很重要的文件所以没有办法对ts文件进行编译，虽然最终的main.js里包含这两个文件的内容，但是编译过的，我暂时没有能力从js恢复到ts文件，只能直接修改main.js文件，所以不可能做太大的修改。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-5b554e7949b9594ffd54634819a2094f.svg"><br>找到相关的判断代码，代码的意思如果笔记有复习记录就修改复习记录的value值，如果初次复习就添加复习记录key:value值，这两种情况之外第三种情况就添加复习记录key:value。（第三个逻辑很奇怪，不知适合什么情况）所以我每个条件我增加一个console.log来跟踪错误发生时，它引发哪个逻辑。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-dc567be19ec6bac525abcc7ebe8a03d2.svg"><br>当我抓到bug时，他显示运行第三个逻辑，实际人工判断这个笔记应该属于第一个逻辑已经有复习记录的笔记。这是怎么回事呢？我ctrl+z恢复笔记原状再来一次。<br><img src="00-obsidian的使用\99-剪藏\assets\1693209248-e1e6e95e7047cd8843141d79deb5f5b1.svg"><br>可以看到这次恢复正常，判断为逻辑一，我又试了几次好象都正常了，所以这其实可能obsidian的api的bug，获取信息失败，但插件判断机制处理失当造成的。我把第三个逻辑全部注释掉，然后增加一个提醒。这样如果出现异常，会报警并保持原样。<br>我把整个过程发给作者，他改不改是他的事情，至少对我没有影响，这也是学习开发的主要原因，尽可能把主动权掌握在自己手里。如果对这个比较敏感的朋友，可以跟我一样找到这个代码段全部注释掉就可以了。等我把两个js文件恢复后，我会优化更改，可以自行重新过一遍，这样应该更合理。.<br><br>通过开发一个小插件熟悉了插件开发涉及到的所有结构，主要难点在设置页上，而设置页的基础是modal，对插件结构熟悉之后，就能很轻松看懂别人源代码。然后对自己常用的几个插件不太满意的功能尝试进行完善，因为obsidian的api文档不太完善，所以学习别人插件是开发插件的必由之路，在修改别人插件过程中，其实能够学习到很多的东西。特别是经典的插件，他们结构简洁清晰，语法规范严谨从中受益颇深。2022-05-08修改。]]></description><link>00-obsidian的使用\99-剪藏\01-插件的开发.html</link><guid isPermaLink="false">00-obsidian的使用/99-剪藏/01-插件的开发.md</guid><pubDate>Wed, 10 Apr 2024 07:01:20 GMT</pubDate><enclosure url="00-obsidian的使用\99-剪藏\assets\1693209248-7c6319fa9cc06131b427290bdfd0585b.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;00-obsidian的使用\99-剪藏\assets\1693209248-7c6319fa9cc06131b427290bdfd0585b.webp&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[免费直接把笔记发布成网站:Obsidian + GitHub + Netlify]]></title><description><![CDATA[ 
 <br>来源网址: <a rel="noopener nofollow" class="external-link" href="https://fengrin.me/posts/2022-12-19-publish-your-website-free-use-your-local-note-obsidian-gitHub-netlify" target="_blank">https://fengrin.me/posts/2022-12-19-publish-your-website-free-use-your-local-note-obsidian-gitHub-netlify</a><br>
裁剪时间: 2023-08-29 10:29:15<br><br>December 19, 2022<br>本文的视频版：<a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV13V4y1c76b/" target="_blank">https://www.bilibili.com/video/BV13V4y1c76b/</a><br>Hello，大家好，今天向大家介绍，如何免费用 Obsidian + GitHub + Netlify 发布自己的网站。简单的说，Obsidian 是一个 markdown 笔记软件，GitHub 是一个代码托管网站，Netlify 是一个静态网站部署工具。<br>建好之后，流程大致是，在 Obsidian 编辑文章，然后通过命令一键发布，然后就可以通过网址访问了，这里有其他人建好的，大致是这个样子：<br>
<br>1: <img alt="image" src="00-obsidian的使用\99-剪藏\assets\1693276155-1a74a2b11d8479978763b7a752632fe7.png">
<br>2: <img alt="image" src="00-obsidian的使用\99-剪藏\assets\1693276155-8cec1931215bd069184c636454e87254.png">
<br>0,<br>准备：<br>
<br>下载 Obsidian 笔记软件
<br>注册 GitHub 账号
<br>1,<br>首先，我们需要用到 Obsidian 的一个插件 Digital Garden，下载安装Digital Garden。<br>2，<br>打开这个 <a data-tooltip-position="top" aria-label="https://github.com/oleeskild/digitalgarden" rel="noopener nofollow" class="external-link" href="https://github.com/oleeskild/digitalgarden" target="_blank">repo</a>，点击绿色的 deploy to netlify<br>这样会打开 Netlify，在你的 GitHub 创建一个这个 repo 的 copy。然后新建一个名字，然后按步骤在 Netlify 发布你的网站到 internet。<br>3，<br>下一步，你需要获取你 GitHub 账户的 access token，这个 token 用于你的 Obsidian 笔记软件的设置，相当于一个 password。去<a data-tooltip-position="top" aria-label="https://github.com/settings/tokens/new?scopes=repo" rel="noopener nofollow" class="external-link" href="https://github.com/settings/tokens/new?scopes=repo" target="_blank">这个网址</a>，点击 generate token 按钮，复制 token，下一步需要用到。<br>4， 打开 Obsidian - Digital Garden 的 settings。填入 GitHub 用户名，repo 的名字（在 step3 设置好的），还有上一步复制好的 token。<br>5，<br>现在可以发布你的第一个笔记了。在 Obsidian 创建一个新的笔记，并且把下面字符加到笔记的开头。<br>---
dg-publish: true
dg-home: true
---
<br>笔记现在它应该是这样的： <img alt="image" src="00-obsidian的使用\99-剪藏\assets\1693276155-8cd519ee1a13a0f3a72a5534649be5c8.png"><br>
<br>dg-home 代表这个笔记应该作为网站首页
<br>dg-publish 设置代表这个笔记是否需要被发布到互联网上。
<br>6， 按 CTRL+P 打开命令面板，找到 Digital Garden: Publish Single Note 命令，按回车。<br>或者，点击侧边栏的小树苗 🌱 的图标，然后点击发布按钮： <img alt="image" src="00-obsidian的使用\99-剪藏\assets\1693276155-d0f684390316f0f24f788072cf70ba2c.png"><br>7, 在 Netlify 找到你网站的网址，打开，大功告成： <img alt="image" src="00-obsidian的使用\99-剪藏\assets\1693276155-a82e7c440cee838dbe2222fe64377d46.png"><br><br>0, 例子：<br><img alt="example" src="00-obsidian的使用\99-剪藏\assets\1693276155-2a2fde2cfe64f171c17457f81ba961a2.png"><br>1 点击 Obsidian - settings：<br><img alt="obsidian - settings" src="00-obsidian的使用\99-剪藏\assets\1693276155-86a87229b87c4e5c56e8a0255b4f5a88.png"><br>2 点击 settings - Appearance - Manage：<br><img alt="obsidian - settings" src="00-obsidian的使用\99-剪藏\assets\1693276155-d2638669d96b38b4e86f36a280958034.png"><br>3 选择支持图表的 Theme，如 Wikipedia<br><img alt="obsidian - settings" src="00-obsidian的使用\99-剪藏\assets\1693276155-5fbe338b9b6c27c27fc492901021a1f3.png"><br>4 点击 settings - Note Settings - Edit<br>5 开启：Show local graph for notes:<br><img alt="obsidian - settings" src="00-obsidian的使用\99-剪藏\assets\1693276155-04a80ca087ab7b0d7acecbb286c8b648.png"><br>6 添加 <a data-tooltip-position="top" aria-label="https://help.obsidian.md/How+to/Internal+link" rel="noopener nofollow" class="external-link" href="https://help.obsidian.md/How+to/Internal+link" target="_blank">Internal link</a><br>创建一个 Note，名为 hi i am Refo Zhang<br>创建一个 Note，名为 digital garden<br>在 Obsidian 中，编辑 digital garden note，按键盘上的 [ 两次，然后输入 hi，选择弹出的 hi i am Refo Zhang。最终效果是：<br>[[hi i am Refo Zhang]]
<br>这样就会在第二个 note 中，创建一个第一个 note 的 internal link。<br>7 Publish 所有的改变，即可得到一个含有所有 Notes 关系的图表<br><br>
<br>网站 CSS 样式定制
<br>购入一个顶级域名，这样网站就不再是用 xxx.netlify.app 这样别人的 2 级域名了。
<br>相关链接：<br>
<br><a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV13V4y1c76b/" rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV13V4y1c76b/" target="_blank">本文的B站视频版</a>
<br><a data-tooltip-position="top" aria-label="https://obsidian.md/" rel="noopener nofollow" class="external-link" href="https://obsidian.md/" target="_blank">Obsidian 官网</a>
<br><a data-tooltip-position="top" aria-label="https://dg-docs.ole.dev/" rel="noopener nofollow" class="external-link" href="https://dg-docs.ole.dev/" target="_blank">Digital Garden 插件官网</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/oleeskild/digitalgarden" rel="noopener nofollow" class="external-link" href="https://github.com/oleeskild/digitalgarden" target="_blank">Digital Garden Github repo</a>
<br><a data-tooltip-position="top" aria-label="https://netlify.com/" rel="noopener nofollow" class="external-link" href="https://netlify.com/" target="_blank">Nelify</a>
<br><a data-tooltip-position="top" aria-label="https://github.com/" rel="noopener nofollow" class="external-link" href="https://github.com/" target="_blank">GitHub</a>
]]></description><link>00-obsidian的使用\99-剪藏\02-免费直接把笔记发布成网站obsidian&amp;github&amp;netlify.html</link><guid isPermaLink="false">00-obsidian的使用/99-剪藏/02-免费直接把笔记发布成网站Obsidian&amp;GitHub&amp;Netlify.md</guid><pubDate>Wed, 10 Apr 2024 07:01:22 GMT</pubDate><enclosure url="00-obsidian的使用\99-剪藏\assets\1693276155-1a74a2b11d8479978763b7a752632fe7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;00-obsidian的使用\99-剪藏\assets\1693276155-1a74a2b11d8479978763b7a752632fe7.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-markdown语法]]></title><description><![CDATA[<a class="tag" href="?query=tag:flashcard" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#flashcard</a> 
 <br>
微信公众号排版工具。问题或建议，请公众号留言。<a class="internal-link" data-href="#jump_8" href="about:blank#jump_8" target="_self" rel="noopener nofollow">程序员翻身</a>
<br>Q: 建议使用 Chrome 浏览器，体验最佳效果。<br>A: 使用微信公众号编辑器有一个十分头疼的问题：粘贴出来的代码，格式错乱，空间小还带行号，而且特别丑。Markdown.com.cn编辑器能够解决这个问题。<br>Markdown是一种轻量级的「标记语言」。<br>请阅读下方文本熟悉工具使用方法，本文可直接拷贝到微信中预览。<br><br>
<br>支持自定义样式的 Markdown 编辑器
<br>支持微信公众号、知乎和稀土掘金
<br>点击右上方对应图标，一键复制到各平台
<br><br><br>不同数量的#可以完成不同的标题，如下：<br><br><br><br><br>粗体、斜体、粗体和斜体，删除线，需要在文字前后加不同的标记符号。如下11： <a href=".?query=tag:flashcard" class="tag" target="_blank" rel="noopener nofollow">#flashcard</a><br>
这个是粗体<br>
这个是斜体<br>// FileName: HelloWorld.java
public class HelloWorld {
  // Java 入口程序，程序从此入口
  public static void main(String[] args) {
    System.out.println("Hello,World!"); // 向控制台打印一条语句
  }
}
<br><br><br>这个是粗体加斜体<br>
<br>有序列表 1
<br>有序列表 2
<br>有序列表 3<br>
这里想用删除线
<br>
<br>无序列表 1
<br>无序列表 2
<br>无序列表 3
<br>注：如果想给字体换颜色、字体或者居中显示，需要使用内嵌HTML来实现。<br><br>无序列表的使用，在符号-后加空格使用。如下：<br>
<br>无序列表 1
<br>无序列表 2
<br>无序列表 3
<br>如果要控制列表的层级，则需要在符号-前使用空格。如下：<br>
<br>无序列表 1
<br>无序列表 2

<br>无序列表 2.1
<br>无序列表 2.2


<br>由于微信原因，最多支持到二级列表。<br><br>有序列表的使用，在数字及符号.后加空格后输入内容，如下：<br>
<br>有序列表 1
<br>有序列表 2
<br>有序列表 3
<br><br>引用的格式是在符号&gt;后面书写文字。如下：<br>
读一本好书，就是在和高尚的人谈话。 ——歌德
<br>
雇用制度对工人不利，但工人根本无力摆脱这个制度。 ——阮一峰
<br><br>微信公众号仅支持公众号文章链接，即域名为https://mp.weixin.qq.com/的合法链接。使用方法如下所示：<br>对于该论述，欢迎读者查阅之前发过的文章，<a data-tooltip-position="top" aria-label="https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA" rel="noopener nofollow" class="external-link" href="https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA" target="_blank">你是《未来世界的幸存者》么？</a><br>
<a id="jump_8" target="_blank" rel="noopener nofollow"></a><br><br>插入图片，格式如下：<br><img alt="这里写图片描述" src="https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg" referrerpolicy="no-referrer"><br>支持 jpg、png、gif、svg 等图片格式，其中 svg 文件仅可在微信公众平台中使用，svg 文件示例如下：<br><img src="https://markdown.com.cn/images/i-am-svg.svg" referrerpolicy="no-referrer"><br>支持图片拖拽和截图粘贴到编辑器中。<br>注：支持图片 拖拽和截图粘贴 到编辑器中，仅支持 https 的图片，图片粘贴到微信时会自动上传微信服务器。<br><br>可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：<br><br><br>可以使用冒号来定义表格的对齐方式，如下：<br><br><br><br>
支持平台：微信公众号、知乎。
<br>脚注与链接的区别如下所示：<br>链接：[文字](链接)
脚注：[文字](脚注解释 "脚注名字")
<br>有人认为在<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Front-end_web_development" rel="noopener nofollow" class="external-link" title="Front-end web development" href="https://en.wikipedia.org/wiki/Front-end_web_development" target="_blank">大前端时代</a>的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。<br><a title="什么是全栈工程师" class="internal-link" data-href="是指掌握多种技能，并能利用多种技能独立完成产品的人。" href="是指掌握多种技能，并能利用多种技能独立完成产品的人。" target="_self" rel="noopener nofollow">全栈工程师</a>在业务开发流程中起到了至关重要的作用。<br>脚注内容请拉到最下面观看。<br><br>
支持平台：微信代码主题仅支持微信公众号！其他主题无限制。
<br>如果在一个行内需要引用代码，只要用反引号引起来就好，如下：<br>Use the printf() function.<br>在需要高亮的代码块的前一行及后一行使用三个反引号，同时第一行反引号后面表示代码块所使用的语言，如下：<br>// FileName: HelloWorld.java
public class HelloWorld {
  // Java 入口程序，程序从此入口
  public static void main(String[] args) {
    System.out.println("Hello,World!"); // 向控制台打印一条语句
  }
}
<br>支持以下语言种类：<br>bash
clojure，cpp，cs，css
dart，dockerfile, diff
erlang
go，gradle，groovy
haskell
java，javascript，json，julia
kotlin
lisp，lua
makefile，markdown，matlab
objectivec
perl，php，python
r，ruby，rust
scala，shell，sql，swift
tex，typescript
verilog，vhdl
xml
yaml
<br>diff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:<br>+ 新增项
- 删除项
<br>其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致<br><br>
支持平台：微信公众号、知乎。
<br>行内公式使用方法，比如这个化学公式：<br>块公式使用方法如下：<br><br>矩阵：<br><br>公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。<br>目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。<br><br>
支持平台：微信公众号、知乎。
<br>TOC 全称为 Table of Content，列出全部标题。<br>[TOC]<br>由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。<br><br>
支持平台：微信公众号。
<br>支持注音符号，用法如下：<br>Markdown Nice 这么好用，简直是{喜大普奔|hē hē hē hē}呀！<br><br>
支持平台：微信公众号。
<br>通过&lt;![](url),![](url)&gt;这种语法设置横屏滑动滑动片，具体用法如下：<br><a data-tooltip-position="top" aria-label="![蓝1](https://markdown.com.cn/images/blue.jpg),![绿2](https://markdown.com.cn/images/green.jpg),![红3](https://markdown.com.cn.jpg)" rel="noopener nofollow" class="external-link" href="![蓝1](https:\\markdown.com.cn\images\blue.jpg),![绿2](https:\\markdown.com.cn\images\green.jpg),![红3](https:\\markdown.com.cn.jpg)" target="_blank">![蓝1](https://markdown.com.cn/images/blue.jpg),![绿2](https://markdown.com.cn/images/green.jpg),![红3](https://markdown.com.cn.jpg)</a><br><br><br>支持原生 HTML 语法，请写内联样式，如下：<br>橙色居右<br>
橙色居中<br><br>不支持，推荐使用开源工具https://draw.io/制作后再导入图片<br><br>
<br>歌词经理 <a data-tooltip-position="top" aria-label="https://github.com/lyricat/wechat-format" rel="noopener nofollow" class="external-link" title="灵感来源" href="https://github.com/lyricat/wechat-format" target="_blank">wechat-fromat</a>
<br>颜家大少 <a data-tooltip-position="top" aria-label="http://md.aclickall.com/" rel="noopener nofollow" class="external-link" title="MdA2All" href="http://md.aclickall.com/" target="_blank">MD2All</a>
]]></description><link>00-obsidian的使用\01-markdown语法.html</link><guid isPermaLink="false">00-obsidian的使用/01-markdown语法.md</guid><pubDate>Tue, 04 Jun 2024 07:51:37 GMT</pubDate><enclosure url="https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[关于]]></title><description><![CDATA[ 
 <br><br>修改语言为简体中文asd <br><br>默认配置接即可<br>
显示行号 ：<br>
options-&gt;Editor-&gt;show line number<br><br>
<br>删除文件移动至.trash (如果你是多终端用git来同步的话，删除的文件也会同步至各终端，便于找回)
<br>始终更新内部链接 开<a rel="noopener nofollow" class="external-link" href="" target="_blank"></a>
<br>新建笔记位置(个人选择当前文件所在文件夹)
<br>检测所有文件链接(目前还没用到，有用pdf之类的可以开一下)
<br>附件默认存放路径（子路径: /assets）
<br><br>
<br>主题，字体随意
<br>zoom level(个人喜欢小一点的，91%觉得合适)
<br>ribbon menu 	<br>
<img src="00-obsidian的使用\assets\pasted-image-20221226135034.png">34.png)<br>
东西不多  后面安装了<a class="internal-link" data-href="03-插件.md" href="00-obsidian的使用\03-插件.html" target="_self" rel="noopener nofollow">03-插件</a>之后可选的东西会很多
<br><br>ctrl + p 最好用的也是最常用的 没有之一  <br><br>obsidian插入图片 默认是  [[]] 这样的格式  这种格式在不支持双链的软件中没法使用  关掉这个配置就是用默认的markdown格式<br>检测所有类型文件打开后  可以监测非markdown文件 pdf,word等等<br>
<img src="00-obsidian的使用\assets\use-wikilink.png"><br><br>在左侧目录树种聚焦当前打开的文件<br>
reveal file in navigation<br><br>blue topaz<br>
things<br>更多使用可参考：<br>
<a data-tooltip-position="top" aria-label="https://publish.obsidian.md/hub/00+-+Start+here" rel="noopener nofollow" class="external-link" href="https://publish.obsidian.md/hub/00+-+Start+here" target="_blank">obsidian hub</a>]]></description><link>00-obsidian的使用\02-基础设置.html</link><guid isPermaLink="false">00-obsidian的使用/02-基础设置.md</guid><pubDate>Tue, 04 Jun 2024 07:36:57 GMT</pubDate><enclosure url="00-obsidian的使用\assets\pasted-image-20221226135034.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;00-obsidian的使用\assets\pasted-image-20221226135034.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[核心插件]]></title><description><![CDATA[ 
 <br><br><br><br><br><br>点击这里展开  默认就是这四个<br>
<img src="00-obsidian的使用\assets\pasted-image-20221228165318.png"><br><br>Workspaces 插件允许您根据任务（例如日记、阅读或写作）在不同的应用程序布局之间进行管理和切换。<br>
工作区包含有关打开的文件和窗格的信息，以及每个侧边栏的宽度和可见性。<br><br><br><br>使用最多的就是最实用的东西<br>
| 姓名 | 年龄 | 性别 |<br>
| ---- | ---- | ---- |<br>
| 1    | 2    | 3    |<br>
| 4    | 5    | 6    |<br><br>typewrite scroll<br><br><br>如果不用官方的收费同步服务的话  git无疑是最好的选择，用了这个插件  操作能更丝滑一些，不喜欢的话其实命令行也无所谓<br><br><br>file tree alternative<br><br><a data-tooltip-position="top" aria-label="https://github.com/dy-sh/obsidian-consistent-attachments-and-links" rel="noopener nofollow" class="external-link" href="https://github.com/dy-sh/obsidian-consistent-attachments-and-links" target="_blank">obsidian-consistent-attachments-and-links</a><br>保持附件的一致性  使用markdown<br><br>Required Obsidian settings for the plugin to work properly:<br>
插件正常工作所需的黑曜石设置：<br>
<br>"Files &amp; Links &gt; Automatically update internal links": disabled.&nbsp;The plugin itself is responsible for updating the links. When Obsidian shows a dialog asking to update links, refuse.<br>
“文件和链接&gt;自动更新内部链接”：已禁用。插件本身负责更新链接。当黑曜石显示要求更新链接的对话框时，请拒绝。<br>

<br>"New link format": Relative path to file.&nbsp;Otherwise, strict compliance of the links cannot be guaranteed.<br>
“新链接格式”：文件的相对路径。否则，无法保证严格遵守链接。<br>

<br>"Use <a class="internal-link" data-href="Wikilinks" href="Wikilinks" target="_self" rel="noopener nofollow">Wikilinks</a>": disabled. Wikilinks are not a markdown standard.<br>
“使用<a class="internal-link" data-href="维基链接" href="维基链接" target="_self" rel="noopener nofollow">维基链接</a>”：禁用。维基链接不是降价标准。<br>

<br>Recommended additional settings (not required for the plugin to work):<br>
建议的附加设置（插件工作不需要）：<br>
<br>"Default location for new attachments":In subfolder under current folder. This is not required, but this ensures that attachments are always next to your notes. The option "Same folder as current file" is also suitable.<br>
“新附件的默认位置”：在当前文件夹下的子文件夹中。这不是必需的，但这可确保附件始终位于笔记旁边。选项“与当前文件相同的文件夹”也是合适的。<br>

<br>"Subfolder name": "_attachments". Or any other.<br>
“子文件夹名称”：“_attachments”。或任何其他。
<br><br><br><a rel="noopener nofollow" class="external-link" href="https://github.com/aidenlx/media-extended" target="_blank">https://github.com/aidenlx/media-extended</a><br>演示视频：<br>0:000:00/0:00|实测！房东送的五级能效空调，到底赚走多少电费？.mp4<br>
<a data-href="00-obsidian的使用/assets/实测！房东送的五级能效空调，到底赚走多少电费？.mp4#t=05:16.150" href="00-obsidian的使用\assets\实测！房东送的五级能效空调，到底赚走多少电费？.mp4#t=05:16.150" class="internal-link" target="_self" rel="noopener nofollow">00-obsidian的使用/assets/实测！房东送的五级能效空调，到底赚走多少电费？.mp4 &gt; t=05:16.150</a><br>注意：<br>
1. 需要将视频单独打开一个tab页并且要关联两个tab页<br>
2. 以上生成的链接  需要预览模式才能跳转到指定的分钟数<br><br><br><br><br><a class="internal-link" data-href="99-剪藏/02-免费直接把笔记发布成网站Obsidian&amp;GitHub&amp;Netlify.md" href="00-obsidian的使用\99-剪藏\02-免费直接把笔记发布成网站obsidian&amp;github&amp;netlify.html" target="_self" rel="noopener nofollow">02-免费直接把笔记发布成网站Obsidian&amp;GitHub&amp;Netlify</a><br><br><br>现在叫 Export to Anki <br><br>配置<br>
<img src="00-obsidian的使用\assets\pasted-image-20240603093855.png"><br><br>插件使用教程参考：<br>
<a data-tooltip-position="top" aria-label="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki" rel="noopener nofollow" class="external-link" href="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki" target="_blank">wiki</a><br>一下是简化版的<br>
安装后打开插件的设置页面<br>
<img src="00-obsidian的使用\assets\img-2024.06.04-04.03.07.jpg"><br>
模板的配置打开后，会列出anki中的所有模板<br>
下图配置的正则 就是会把当前打开的md文件中符合正则的内容 制作成anki卡片，推送到指定/默认的牌组中；<br>
正则参见：<br>
<a data-tooltip-position="top" aria-label="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki/Regex" rel="noopener nofollow" class="external-link" href="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki/Regex" target="_blank">wiki/Regex</a><br>
<img src="00-obsidian的使用\assets\pasted-image-20240604174419.png"><br>比如上图中 配置的是闪卡的正则，<br>
当我们在有如下内容 点击 推送按钮后 就会生成卡片<br>
<img src="00-obsidian的使用\assets\pasted-image-20240605095749.png"><br>
生成后，会在卡片内容后追加id 后续再推送时就不是新增卡片 而是更新卡片<br>
<img src="00-obsidian的使用\assets\pasted-image-20240605100158.png">]]></description><link>00-obsidian的使用\03-插件.html</link><guid isPermaLink="false">00-obsidian的使用/03-插件.md</guid><pubDate>Wed, 05 Jun 2024 02:02:19 GMT</pubDate><enclosure url="00-obsidian的使用\assets\pasted-image-20221228165318.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;00-obsidian的使用\assets\pasted-image-20221228165318.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[04-test_obsidian_to_anki]]></title><description><![CDATA[<a class="tag" href="?query=tag:flashcard" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#flashcard</a> <a class="tag" href="?query=tag:flashcard" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#flashcard</a> <a class="tag" href="?query=tag:flashcard" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#flashcard</a> 
 <br>In Neuracache style, 阿萨德to masdasd kaasdsdeasdasd11 a flassshcard 11y11ou do <a href=".?query=tag:flashcard" class="tag" target="_blank" rel="noopener nofollow">#flashcard</a><br><br><br>If you want, it's certaasas 阿萨asd 德sdasdinly po11ssible to11<br>
do a multi-line quasdasdestion <a href=".?query=tag:flashcard" class="tag" target="_blank" rel="noopener nofollow">#flashcard</a><br>-- 还款区 REPAYMENT  公司银行   无
select b.ACCOUNT_NO, (select code from T_DIM_OBJECT where b.OBJECT_ID = OBJECT_ID)  
from T_BILL_AREA_FK__DEF_001 d,  
     T_DIM_BANKACCOUNT b  
where b.ACCOUNT_NO = d.F_FKZH;
<br>
<br>主数据问asd题1111<br>
- [ ] 1. 供应商银行 多币种<br>
- [ ] 2. 人员 预入职


<br>And, of coasdura阿asadsd萨德sd11se <a href=".?query=tag:flashcard" class="tag" target="_blank" rel="noopener nofollow">#flashcard</a><br>
<img src="00-obsidian的使用\assets\pasted-image-20221228165318.png"><br>]]></description><link>00-obsidian的使用\04-test_obsidian_to_anki.html</link><guid isPermaLink="false">00-obsidian的使用/04-test_obsidian_to_anki.md</guid><pubDate>Wed, 05 Jun 2024 01:59:32 GMT</pubDate><enclosure url="00-obsidian的使用\assets\pasted-image-20221228165318.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;00-obsidian的使用\assets\pasted-image-20221228165318.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Drawing 2023-08-25 16.30.44]]></title><description><![CDATA[ 
 <br><br>excalidraw-plugin: parsed<br>
tags: [excalidraw]<br><br>⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠<br><br>123 <br>第三方 <br><a data-href="../97-运维/99-ansible#ansible是什么" href="97-运维\99-ansible.html#ansible是什么" class="internal-link" target="_self" rel="noopener nofollow">../97-运维/99-ansible &gt; ansible是什么</a> <br>]]></description><link>00-obsidian的使用\drawing-2023-08-25-16.30.44.excalidraw.html</link><guid isPermaLink="false">00-obsidian的使用/Drawing 2023-08-25 16.30.44.excalidraw.md</guid><pubDate>Wed, 10 Apr 2024 07:08:32 GMT</pubDate></item><item><title><![CDATA[obsidian的使用]]></title><description><![CDATA[ 
 <br>
微信公众号排版工具。问题或建议，请公众号留言。<a class="internal-link" data-href="#jump_8" href="about:blank#jump_8" target="_self" rel="noopener nofollow">程序员翻身</a>
<br>Q: 建议使用 Chrome 浏览器，体验最佳效果。<br>A: 使用微信公众号编辑器有一个十分头疼的问题：粘贴出来的代码，格式错乱，空间小还带行号，而且特别丑。Markdown.com.cn编辑器能够解决这个问题。<br>Markdown是一种轻量级的「标记语言」。<br>请阅读下方文本熟悉工具使用方法，本文可直接拷贝到微信中预览。<br><br>
<br>支持自定义样式的 Markdown 编辑器
<br>支持微信公众号、知乎和稀土掘金
<br>点击右上方对应图标，一键复制到各平台
<br><br><br>不同数量的#可以完成不同的标题，如下：<br><br><br><br><br>粗体、斜体、粗体和斜体，删除线，需要在文字前后加不同的标记符号。如下11： <a href=".?query=tag:flashcard" class="tag" target="_blank" rel="noopener nofollow">#flashcard</a><br>
这个是粗体<br>
这个是斜体<br>// FileName: HelloWorld.java
public class HelloWorld {
  // Java 入口程序，程序从此入口
  public static void main(String[] args) {
    System.out.println("Hello,World!"); // 向控制台打印一条语句
  }
}
<br><br><br>这个是粗体加斜体<br>
<br>有序列表 1
<br>有序列表 2
<br>有序列表 3<br>
这里想用删除线
<br>
<br>无序列表 1
<br>无序列表 2
<br>无序列表 3
<br>注：如果想给字体换颜色、字体或者居中显示，需要使用内嵌HTML来实现。<br><br>无序列表的使用，在符号-后加空格使用。如下：<br>
<br>无序列表 1
<br>无序列表 2
<br>无序列表 3
<br>如果要控制列表的层级，则需要在符号-前使用空格。如下：<br>
<br>无序列表 1
<br>无序列表 2

<br>无序列表 2.1
<br>无序列表 2.2


<br>由于微信原因，最多支持到二级列表。<br><br>有序列表的使用，在数字及符号.后加空格后输入内容，如下：<br>
<br>有序列表 1
<br>有序列表 2
<br>有序列表 3
<br><br>引用的格式是在符号&gt;后面书写文字。如下：<br>
读一本好书，就是在和高尚的人谈话。 ——歌德
<br>
雇用制度对工人不利，但工人根本无力摆脱这个制度。 ——阮一峰
<br><br>微信公众号仅支持公众号文章链接，即域名为https://mp.weixin.qq.com/的合法链接。使用方法如下所示：<br>对于该论述，欢迎读者查阅之前发过的文章，<a data-tooltip-position="top" aria-label="https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA" rel="noopener nofollow" class="external-link" href="https://mp.weixin.qq.com/s/s5IhxV2ooX3JN_X416nidA" target="_blank">你是《未来世界的幸存者》么？</a><br>
<a id="jump_8" target="_blank" rel="noopener nofollow"></a><br><br>插入图片，格式如下：<br><img alt="这里写图片描述" src="https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg" referrerpolicy="no-referrer"><br>支持 jpg、png、gif、svg 等图片格式，其中 svg 文件仅可在微信公众平台中使用，svg 文件示例如下：<br><img src="https://markdown.com.cn/images/i-am-svg.svg" referrerpolicy="no-referrer"><br>支持图片拖拽和截图粘贴到编辑器中。<br>注：支持图片 拖拽和截图粘贴 到编辑器中，仅支持 https 的图片，图片粘贴到微信时会自动上传微信服务器。<br><br>可以在一行中用三个以上的减号来建立一个分隔线，同时需要在分隔线的上面空一行。如下：<br><br><br>可以使用冒号来定义表格的对齐方式，如下：<br><br><br><br>
支持平台：微信公众号、知乎。
<br>脚注与链接的区别如下所示：<br>链接：[文字](链接)
脚注：[文字](脚注解释 "脚注名字")
<br>有人认为在<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Front-end_web_development" rel="noopener nofollow" class="external-link" title="Front-end web development" href="https://en.wikipedia.org/wiki/Front-end_web_development" target="_blank">大前端时代</a>的背景下，移动端开发（Android、IOS）将逐步退出历史舞台。<br><a title="什么是全栈工程师" class="internal-link" data-href="是指掌握多种技能，并能利用多种技能独立完成产品的人。" href="是指掌握多种技能，并能利用多种技能独立完成产品的人。" target="_self" rel="noopener nofollow">全栈工程师</a>在业务开发流程中起到了至关重要的作用。<br>脚注内容请拉到最下面观看。<br><br>
支持平台：微信代码主题仅支持微信公众号！其他主题无限制。
<br>如果在一个行内需要引用代码，只要用反引号引起来就好，如下：<br>Use the printf() function.<br>在需要高亮的代码块的前一行及后一行使用三个反引号，同时第一行反引号后面表示代码块所使用的语言，如下：<br>// FileName: HelloWorld.java
public class HelloWorld {
  // Java 入口程序，程序从此入口
  public static void main(String[] args) {
    System.out.println("Hello,World!"); // 向控制台打印一条语句
  }
}
<br>支持以下语言种类：<br>bash
clojure，cpp，cs，css
dart，dockerfile, diff
erlang
go，gradle，groovy
haskell
java，javascript，json，julia
kotlin
lisp，lua
makefile，markdown，matlab
objectivec
perl，php，python
r，ruby，rust
scala，shell，sql，swift
tex，typescript
verilog，vhdl
xml
yaml
<br>diff 不能同时和其他语言的高亮同时显示，且需要调整代码主题为微信代码主题以外的代码主题才能看到 diff 效果，使用效果如下:<br>+ 新增项
- 删除项
<br>其他主题不带行号，可自定义是否换行，代码大小与当前编辑器一致<br><br>
支持平台：微信公众号、知乎。
<br>行内公式使用方法，比如这个化学公式：<br>块公式使用方法如下：<br><br>矩阵：<br><br>公式由于微信不支持，目前的解决方案是转成 svg 放到微信中，无需调整，矢量不失真。<br>目前测试如果公式量过大，在 Chrome 下会存在粘贴后无响应，但是在 Firefox 中始终能够成功。<br><br>
支持平台：微信公众号、知乎。
<br>TOC 全称为 Table of Content，列出全部标题。<br>[TOC]<br>由于微信只支持到二级列表，本工具仅支持二级标题和三级标题的显示。<br><br>
支持平台：微信公众号。
<br>支持注音符号，用法如下：<br>Markdown Nice 这么好用，简直是{喜大普奔|hē hē hē hē}呀！<br><br>
支持平台：微信公众号。
<br>通过&lt;![](url),![](url)&gt;这种语法设置横屏滑动滑动片，具体用法如下：<br><a data-tooltip-position="top" aria-label="![蓝1](https://markdown.com.cn/images/blue.jpg),![绿2](https://markdown.com.cn/images/green.jpg),![红3](https://markdown.com.cn.jpg)" rel="noopener nofollow" class="external-link" href="![蓝1](https:\\markdown.com.cn\images\blue.jpg),![绿2](https:\\markdown.com.cn\images\green.jpg),![红3](https:\\markdown.com.cn.jpg)" target="_blank">![蓝1](https://markdown.com.cn/images/blue.jpg),![绿2](https://markdown.com.cn/images/green.jpg),![红3](https://markdown.com.cn.jpg)</a><br><br><br>支持原生 HTML 语法，请写内联样式，如下：<br>橙色居右<br>
橙色居中<br><br>不支持，推荐使用开源工具https://draw.io/制作后再导入图片<br><br>
<br>歌词经理 <a data-tooltip-position="top" aria-label="https://github.com/lyricat/wechat-format" rel="noopener nofollow" class="external-link" title="灵感来源" href="https://github.com/lyricat/wechat-format" target="_blank">wechat-fromat</a>
<br>颜家大少 <a data-tooltip-position="top" aria-label="http://md.aclickall.com/" rel="noopener nofollow" class="external-link" title="MdA2All" href="http://md.aclickall.com/" target="_blank">MD2All</a>
01-markdown语法<br><br><br>修改语言为简体中文asd <br><br>默认配置接即可<br>
显示行号 ：<br>
options-&gt;Editor-&gt;show line number<br><br>
<br>删除文件移动至.trash (如果你是多终端用git来同步的话，删除的文件也会同步至各终端，便于找回)
<br>始终更新内部链接 开<a rel="noopener nofollow" class="external-link" href="" target="_blank"></a>
<br>新建笔记位置(个人选择当前文件所在文件夹)
<br>检测所有文件链接(目前还没用到，有用pdf之类的可以开一下)
<br>附件默认存放路径（子路径: /assets）
<br><br>
<br>主题，字体随意
<br>zoom level(个人喜欢小一点的，91%觉得合适)
<br>ribbon menu 	<br>
<img src="00-obsidian的使用\assets\pasted-image-20221226135034.png">34.png)<br>
东西不多  后面安装了<a class="internal-link" data-href="03-插件.md" href="00-obsidian的使用\03-插件.html" target="_self" rel="noopener nofollow">03-插件</a>之后可选的东西会很多
<br><br>ctrl + p 最好用的也是最常用的 没有之一  <br><br>obsidian插入图片 默认是  [[]] 这样的格式  这种格式在不支持双链的软件中没法使用  关掉这个配置就是用默认的markdown格式<br>检测所有类型文件打开后  可以监测非markdown文件 pdf,word等等<br>
<img src="00-obsidian的使用\assets\use-wikilink.png"><br><br>在左侧目录树种聚焦当前打开的文件<br>
reveal file in navigation<br><br>blue topaz<br>
things<br>更多使用可参考：<br>
<a data-tooltip-position="top" aria-label="https://publish.obsidian.md/hub/00+-+Start+here" rel="noopener nofollow" class="external-link" href="https://publish.obsidian.md/hub/00+-+Start+here" target="_blank">obsidian hub</a>02-基础设置<br><br><br><br><br><br><br>点击这里展开  默认就是这四个<br>
<img src="00-obsidian的使用\assets\pasted-image-20221228165318.png"><br><br>Workspaces 插件允许您根据任务（例如日记、阅读或写作）在不同的应用程序布局之间进行管理和切换。<br>
工作区包含有关打开的文件和窗格的信息，以及每个侧边栏的宽度和可见性。<br><br><br><br>使用最多的就是最实用的东西<br>
| 姓名 | 年龄 | 性别 |<br>
| ---- | ---- | ---- |<br>
| 1    | 2    | 3    |<br>
| 4    | 5    | 6    |<br><br>typewrite scroll<br><br><br>如果不用官方的收费同步服务的话  git无疑是最好的选择，用了这个插件  操作能更丝滑一些，不喜欢的话其实命令行也无所谓<br><br><br>file tree alternative<br><br><a data-tooltip-position="top" aria-label="https://github.com/dy-sh/obsidian-consistent-attachments-and-links" rel="noopener nofollow" class="external-link" href="https://github.com/dy-sh/obsidian-consistent-attachments-and-links" target="_blank">obsidian-consistent-attachments-and-links</a><br>保持附件的一致性  使用markdown<br><br>Required Obsidian settings for the plugin to work properly:<br>
插件正常工作所需的黑曜石设置：<br>
<br>"Files &amp; Links &gt; Automatically update internal links": disabled.&nbsp;The plugin itself is responsible for updating the links. When Obsidian shows a dialog asking to update links, refuse.<br>
“文件和链接&gt;自动更新内部链接”：已禁用。插件本身负责更新链接。当黑曜石显示要求更新链接的对话框时，请拒绝。<br>

<br>"New link format": Relative path to file.&nbsp;Otherwise, strict compliance of the links cannot be guaranteed.<br>
“新链接格式”：文件的相对路径。否则，无法保证严格遵守链接。<br>

<br>"Use <a class="internal-link" data-href="Wikilinks" href="Wikilinks" target="_self" rel="noopener nofollow">Wikilinks</a>": disabled. Wikilinks are not a markdown standard.<br>
“使用<a class="internal-link" data-href="维基链接" href="维基链接" target="_self" rel="noopener nofollow">维基链接</a>”：禁用。维基链接不是降价标准。<br>

<br>Recommended additional settings (not required for the plugin to work):<br>
建议的附加设置（插件工作不需要）：<br>
<br>"Default location for new attachments":In subfolder under current folder. This is not required, but this ensures that attachments are always next to your notes. The option "Same folder as current file" is also suitable.<br>
“新附件的默认位置”：在当前文件夹下的子文件夹中。这不是必需的，但这可确保附件始终位于笔记旁边。选项“与当前文件相同的文件夹”也是合适的。<br>

<br>"Subfolder name": "_attachments". Or any other.<br>
“子文件夹名称”：“_attachments”。或任何其他。
<br><br><br><a rel="noopener nofollow" class="external-link" href="https://github.com/aidenlx/media-extended" target="_blank">https://github.com/aidenlx/media-extended</a><br>演示视频：<br>0:000:00/0:00|实测！房东送的五级能效空调，到底赚走多少电费？.mp4<br>
<a data-href="00-obsidian的使用/assets/实测！房东送的五级能效空调，到底赚走多少电费？.mp4#t=05:16.150" href="00-obsidian的使用\assets\实测！房东送的五级能效空调，到底赚走多少电费？.mp4#t=05:16.150" class="internal-link" target="_self" rel="noopener nofollow">00-obsidian的使用/assets/实测！房东送的五级能效空调，到底赚走多少电费？.mp4 &gt; t=05:16.150</a><br>注意：<br>
1. 需要将视频单独打开一个tab页并且要关联两个tab页<br>
2. 以上生成的链接  需要预览模式才能跳转到指定的分钟数<br><br><br><br><br><a class="internal-link" data-href="99-剪藏/02-免费直接把笔记发布成网站Obsidian&amp;GitHub&amp;Netlify.md" href="00-obsidian的使用\99-剪藏\02-免费直接把笔记发布成网站obsidian&amp;github&amp;netlify.html" target="_self" rel="noopener nofollow">02-免费直接把笔记发布成网站Obsidian&amp;GitHub&amp;Netlify</a><br><br><br>现在叫 Export to Anki <br><br>配置<br>
<img src="00-obsidian的使用\assets\pasted-image-20240603093855.png"><br><br>插件使用教程参考：<br>
<a data-tooltip-position="top" aria-label="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki" rel="noopener nofollow" class="external-link" href="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki" target="_blank">wiki</a><br>一下是简化版的<br>
安装后打开插件的设置页面<br>
<img src="00-obsidian的使用\assets\img-2024.06.04-04.03.07.jpg"><br>
模板的配置打开后，会列出anki中的所有模板<br>
下图配置的正则 就是会把当前打开的md文件中符合正则的内容 制作成anki卡片，推送到指定/默认的牌组中；<br>
正则参见：<br>
<a data-tooltip-position="top" aria-label="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki/Regex" rel="noopener nofollow" class="external-link" href="https://github.com/ObsidianToAnki/Obsidian_to_Anki/wiki/Regex" target="_blank">wiki/Regex</a><br>
<img src="00-obsidian的使用\assets\pasted-image-20240604174419.png"><br>比如上图中 配置的是闪卡的正则，<br>
当我们在有如下内容 点击 推送按钮后 就会生成卡片<br>
<img src="00-obsidian的使用\assets\pasted-image-20240605095749.png"><br>
生成后，会在卡片内容后追加id 后续再推送时就不是新增卡片 而是更新卡片<br>
<img src="00-obsidian的使用\assets\pasted-image-20240605100158.png">03-插件<br>obsidian的使用]]></description><link>00-obsidian的使用\obsidian的使用.html</link><guid isPermaLink="false">00-obsidian的使用/obsidian的使用.canvas</guid><pubDate>Thu, 27 Apr 2023 06:49:46 GMT</pubDate><enclosure url="https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://www.nginx.cn/wp-content/uploads/2020/03/qrcode_for_gh_82cf87d482f0_258.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-什么是hash]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://samwho.dev/hashing/" target="_blank">https://samwho.dev/hashing/</a>]]></description><link>01-数据结构与算法\01-hash\01-什么是hash.html</link><guid isPermaLink="false">01-数据结构与算法/01-hash/01-什么是hash.md</guid><pubDate>Tue, 29 Aug 2023 09:10:57 GMT</pubDate></item><item><title><![CDATA[00-基本类型]]></title><description><![CDATA[ 
 <br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/zcl_love_wx/article/details/51504224" target="_blank">https://blog.csdn.net/zcl_love_wx/article/details/51504224</a><br>new String()  堆内存新建对象<br>
String a = "xxx"  常量池<br>当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用<br><br><a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/40310802" target="_blank">https://zhuanlan.zhihu.com/p/40310802</a>]]></description><link>02-编程语言\01-java\00-基础\00-基本类型.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/00-基础/00-基本类型.md</guid><pubDate>Wed, 10 Apr 2024 07:01:42 GMT</pubDate></item><item><title><![CDATA[2018年最全Java面试通关秘籍汇总集]]></title><description><![CDATA[ 
 <br><br><br><br>final, finally, finalize 的区别 &nbsp;<br>final：修饰符（关键字）有三种用法：如果一个类被声明为final，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。将变量声明为final，可以保证它们在使用中不被改变，被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为final 的方法也同样只能使用，不能在子类中被重写。finally：通常放在try…catch的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。finalize：Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。<br>String 和StringBuilder、StringBuffer 的区别 &nbsp;<br>Java 平台提供了两种类型的字符串：String和StringBuffer / StringBuilder，它们可以储存和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer和StringBuilder类表示的字符串对象可以直接进行修改。StringBuilder是JDK 1.5中引入的，它和StringBuffer的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized修饰，因此它的效率也比StringBuffer略高。<br>抽象类和接口有什么区别 &nbsp; &nbsp;<br>抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。<br>说说反射的用途及实现<br>它允许运行中的 Java 程序获取自身的信息，并且可以操作类和对象的内部属性。程序中一般的对象类型都是在编译期就确定下来的，而Java 反射机制可以动态的创建对象并调用其属性，通过反射，我们可以在运行时获得程序或程序集中每一个类型成员和成员变量的信息；开发各种通用框架<br>自定义注解<br><a rel="noopener nofollow" class="external-link" href="http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html" target="_blank">http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html</a><br>Session与Cookie区别<br>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗<br>&nbsp; &nbsp;考虑到安全应当使用session。<br>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能<br>&nbsp; &nbsp;考虑到减轻服务器性能方面，应当使用COOKIE。<br>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br>5、所以个人建议：<br>&nbsp; &nbsp;将登陆信息等重要信息存放为SESSION<br>&nbsp; &nbsp;其他信息如果需要保留，可以放在COOKIE中<br>Java序列化和反序列化<br>序列化：把对象转换为字节序列的过程称为对象的序列化。<br>反序列化：把字节序列恢复为对象的过程称为对象的反序列化<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/qq_27093465/article/details/78544505" target="_blank">https://blog.csdn.net/qq_27093465/article/details/78544505</a><br><br>HashSet 和 HashMap 区别<br>HashSet的实现原理总结如下：<br>①是基于HashMap实现的，默认构造函数是构建一个初始容量为16，负载因子为0.75 的HashMap。封装了一个 HashMap 对象来存储所有的集合元素，所有放入 HashSet 中的集合元素实际上由 HashMap 的 key 来保存，而 HashMap 的 value 则存储了一个 PRESENT，它是一个静态的 Object 对象。<br>②当我们试图把某个类的对象当成 HashMap的 key，或试图将这个类的对象放入 HashSet 中保存时，重写该类的equals(Object obj)方法和 hashCode() 方法很重要，而且这两个方法的返回值必须保持一致：当该类的两个的 hashCode() 返回值相同时，它们通过 equals() 方法比较也应该返回 true。通常来说，所有参与计算 hashCode() 返回值的关键属性，都应该用于作为 equals() 比较的标准。<br>③HashSet的其他操作都是基于HashMap的<br>hashMap原理：<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/vking_wang/article/details/14166593" target="_blank">https://blog.csdn.net/vking_wang/article/details/14166593</a><br><br>ThreadLocal为什么会出现OOM<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/GoGleTech/article/details/78318712" target="_blank">https://blog.csdn.net/GoGleTech/article/details/78318712</a><br><br>Java四种引用包括强引用，软引用，弱引用，虚引用。区别<br><a rel="noopener nofollow" class="external-link" href="https://www.cnblogs.com/yw-ah/p/5830458.html" target="_blank">https://www.cnblogs.com/yw-ah/p/5830458.html</a><br>avl树<br><a rel="noopener nofollow" class="external-link" href="http://lib.csdn.net/article/datastructure/9204" target="_blank">http://lib.csdn.net/article/datastructure/9204</a><br><br><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。<br>&nbsp; &nbsp; &nbsp;不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。<br>&nbsp; &nbsp; &nbsp;<br><br>&nbsp; &nbsp; &nbsp;不可变对象有很多优点:<br>&nbsp; &nbsp;（1）构造、测试和使用都很简单<br>&nbsp; &nbsp;（2）线程安全且没有同步问题，不需要担心数据会被其它线程修改<br>&nbsp; &nbsp;（3）当用作类的属性时不需要保护性拷贝<br>&nbsp; &nbsp;（4）可以很好的用作Map键值和Set元素<br>&nbsp; &nbsp; 不可变对象最大的缺点就是创建对象的开销，因为每一步操作都会产生一个新的对象。<br><br>&nbsp; &nbsp;&nbsp;可以遵照以下几点来编写一个不可变类:<br>（1）确保类不能被继承 - 将类声明为final, 或者使用静态工厂并声明构造器为private<br>（2）声明属性为private&nbsp;和&nbsp;final<br>（3）不要提供任何可以修改对象状态的方法 - 不仅仅是set方法, 还有任何其它可以改变状态的方法<br>（4）如果类有任何可变对象属性, 那么当它们在类和类的调用者间传递的时候必须被保护性拷贝<br>String是不可变的  类似拼接、裁剪字符串等动作，每次对String的操作都会生成新的 String对象<br>StringBuffer是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。<br>StringBuilder是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，减小了开销，是绝大部分情况下进行字符串拼接的首选。<br>StringBuilder和StringBuffer的内部实现跟String类一样，都是通过一个char数组存储字符串的，不同的是String类里面的char数组是final修饰的，是不可变的，而StringBuilder和StringBuffer的char数组是可变的。所以在进行频繁的字符串操作时，建议使用StringBuffer和 StringBuilder来进行操作。 另外StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。<br><a rel="noopener nofollow" class="external-link" href="https://www.joshua317.com/article/241" target="_blank">https://www.joshua317.com/article/241</a>]]></description><link>02-编程语言\01-java\00-基础\01-xx.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/00-基础/01-xx.md</guid><pubDate>Tue, 21 May 2024 08:54:04 GMT</pubDate></item><item><title><![CDATA[aaa]]></title><description><![CDATA[ 
 <br><br><br><br><br><br>]]></description><link>02-编程语言\01-java\00-基础\untitled-mindmap.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/00-基础/Untitled mindmap.md</guid><pubDate>Tue, 21 May 2024 08:52:58 GMT</pubDate></item><item><title><![CDATA[01-map]]></title><description><![CDATA[ 
 <br><br>在 Java 的 HashMap 中，负载因子（load factor）的默认值为 0.75，它与 泊松分布（Poisson distribution）之间确实存在一定的数学关联。这种关联主要体现在设计 HashMap 时关于哈希冲突的概率分布分析和性能优化上。<br><br><br>
<br>
定义：负载因子是 HashMap 中 已存储元素数量与桶数量的比值，即：
复制
load factor = number of elements / number of buckets

当负载因子达到或超过阈值时，HashMap 会触发 动态扩容（rehashing），将桶的数量加倍，并将现有元素重新分配到新的桶中。

<br>
默认值 0.75 的原因：

<br>空间与时间的权衡：负载因子过小（如 0.5）会导致桶的使用率过低，浪费内存；负载因子过大（如 1.0 或更高）会增加哈希冲突的概率，从而降低查询和插入的性能。0.75 是一个合理的中间值。
<br>概率分析：负载因子为 0.75 时，哈希冲突的概率相对较低，且桶内链表长度符合理想分布，能保证较好的性能。


<br><br><br>泊松分布是离散概率分布，常用于描述单位时间或单位空间内事件发生的次数（如随机事件分布）。在 HashMap 中，可以将其应用于分析哈希冲突的分布：<br>
<br>
桶内元素数量分布：

<br>在 HashMap 中，假设哈希函数是均匀分布的，那么每个元素被分配到某个桶的概率是相等的，且彼此独立。
<br>对于一个具有 n 个桶的 HashMap，如果总共有 k 个元素，且每个桶的元素分布是随机的，则可以用泊松分布来近似描述每个桶中元素的数量分布：
  复制
P(X = k) = (λ^k * e^(-λ)) / k!

  其中：

<br>P(X = k) 是单个桶中恰好有 k 个元素的概率。
<br>λ 是平均负载（即 λ = load factor = k / n）。
<br>k! 是阶乘。




<br>
负载因子与泊松分布的关系：

<br>当负载因子为 0.75 时，意味着平均每个桶中的元素数为 λ = 0.75。
<br>根据泊松分布的性质，当 λ 较小（如 0.75）时，大多数桶中元素数量会接近 λ，即 0 或 1 的概率较高，而出现更高数量（如 2 或 3）的概率迅速下降。
<br>这使得 HashMap 在负载因子为 0.75 时，桶内链表的长度较短，大多数情况下查询和插入的时间复杂度接近 O(1)。


<br>
具体概率计算（假设负载因子为 λ = 0.75）：

<br>单个桶中有 0 个元素的概率：
  apache
  复制
P(X = 0) = (0.75^0 * e^(-0.75)) / 0! = e^(-0.75) ≈ 0.472

  即，约 47.2% 的桶是空的。
<br>单个桶中有 1 个元素的概率：
  apache
  复制
P(X = 1) = (0.75^1 * e^(-0.75)) / 1! = 0.75 * e^(-0.75) ≈ 0.354

  即，约 35.4% 的桶中恰有 1 个元素。
<br>单个桶中有 2 个元素的概率：
  apache
  复制
P(X = 2) = (0.75^2 * e^(-0.75)) / 2! = 0.28125 * e^(-0.75) ≈ 0.133

  即，约 13.3% 的桶中有 2 个元素。
<br>单个桶中有 3 个元素的概率：
  apache
  复制
P(X = 3) = (0.75^3 * e^(-0.75)) / 3! = 0.2109375 * e^(-0.75) ≈ 0.033

  即，约 3.3% 的桶中有 3 个元素。

结论：当负载因子为 0.75 时，大多数桶中元素数量为 0 或 1，少数桶中有 2 个或更多元素。这种分布使得哈希冲突较少，查询和插入性能较高。

<br>
高负载因子对泊松分布的影响：

<br>如果负载因子增大（如 1.0 或更高），则 λ 增大，泊松分布的尾部会变长，意味着出现长链表的概率增大，从而降低性能。
<br>如果负载因子减小（如 0.5），则大部分桶会变为空，内存利用率下降，但性能稍有提升。


<br><br><br>HashMap 的默认负载因子 0.75 是基于工程经验和数学分析得出的平衡值。它与泊松分布的关系在于：<br>
<br>负载因子决定了每个桶的平均负载（λ），进而影响桶内元素数量的概率分布。
<br>当负载因子为 0.75 时，泊松分布表明绝大多数桶的元素数为 0 或 1，哈希冲突少，性能接近 O(1)。
<br>这种设计在时间复杂度和空间利用率之间找到了一个较优的平衡点。
<br><a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/79219960" target="_blank">https://zhuanlan.zhihu.com/p/79219960</a><br><br>hashMap 链表+数组 扩容时，需要从新计算hash,线程1和2同时进入扩容操作，2挂起，1扩容完毕，2继续，导致环形链表，get操作就会死循环<br>put流程图<br>
<img src="02-编程语言\01-java\01-集合\assets\hashmap的put操作流程图.png"><br><br>避免hash冲突 重写hashCode equals<br><br><a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/6844903951385493518#heading-1" target="_blank">https://juejin.cn/post/6844903951385493518#heading-1</a><br>concurrentHashMap相关<br>1.8之前采用分段锁，降低锁的粒度<br>
取消了Segment分段锁的数据结构，取而代之的是数组+链表（红黑树）的结构。而对于锁的粒度，调整为对每个数组元素加锁（Node）。然后是定位节点的hash算法被简化了，这样带来的弊端是Hash冲突会加剧。因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。这样一来，查询的时间复杂度就会由原先的O(n)变为O(logN)<br>
1.8之后cas思想<br>
CAS采用乐观锁思想达到lock free<br>CAS:CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做]]></description><link>02-编程语言\01-java\01-集合\01-map.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/01-集合/01-map.md</guid><pubDate>Fri, 14 Feb 2025 09:11:28 GMT</pubDate><enclosure url="02-编程语言\01-java\01-集合\assets\hashmap的put操作流程图.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\01-集合\assets\hashmap的put操作流程图.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02-线程安全的集合]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://worktile.com/kb/ask/30179.html" target="_blank">https://worktile.com/kb/ask/30179.html</a><br><br>Vector、Hashtable<br>
是怎么保证线程安排的：使用synchronized修饰方法<br>
缺点：效率低下<br><br>ArrayList、HashMap<br>
线程不安全，但是性能好，用来替代Vector、Hashtable<br>
使用ArrayList、HashMap,需要线程安全怎么办呢？<br>
Collections.synchronizedList(list);Collections.synchronizedMap(m);<br>
底层使用synchronized代码块锁虽然也是锁住了所有的代码，但是锁在方法里边，并所在方法外边性能可以理解<br>
为稍有提高吧。毕竟进方法本身就要分配资源的<br><br>在大量并发情况下如何提高集合的效率和安全呢？<br>
java.util.concurrent.<br>
ConcurrentHashMap:<br>
CopyOnWriteArrayList<br>
CopyOnWriteArraySet:注意不是CopyOnWriteHashSet<br>
底层大都采用Lock锁(1.8的ConcurrentHashMap不使用Lock锁)，保证安全的同时，性能也很高。]]></description><link>02-编程语言\01-java\01-集合\02-线程安全的集合.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/01-集合/02-线程安全的集合.md</guid><pubDate>Wed, 10 Apr 2024 07:01:52 GMT</pubDate></item><item><title><![CDATA[what's new in Java 8]]></title><description><![CDATA[ 
 <br><br>官网： <a rel="noopener nofollow" class="external-link" href="http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank">http://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html</a><br><br>lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为<br>
Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）<br>
以下是lambda表达式的重要特征:<br>

<br>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。   
<br>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。  
<br>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。   
<br>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。  

<br>demo:<br>class Test {

  public static void main(String[] args) {

    new Thread(new Runnable() {
      public void run() {
        System.out.println("java7");
      }
    }).start();

    //这是一个语法糖
    new Thread(() -&gt; System.out.println("java8")).start();

  }
}
<br>Lambda 表达式主要用来定义行内执行的方法类型接口,免去了使用匿名方法的麻烦    <br>  interface MathOperation {
    int operation(int a, int b);
  }

  // 类型声明
  MathOperation addition = (int a, int b) -&gt; a + b;

  private int operate(int a, int b, MathOperation mathOperation) {
    return mathOperation.operation(a, b);
  }

  public static void main(String args[]) {
    Java8Tester tester = new Java8Tester();
    System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
  }
<br><br>public class Java8Tester {
  public static void main(String args[]) {
    int num = 1;
    Converter&lt;Integer, String&gt; s = (param) -&gt; {
      System.out.println(String.valueOf(param + num++));//报错：Local variable num defined in an enclosing scope must be final or effectively final
    };
    s.convert(2); // 输出结果为 3
  }

  public interface Converter&lt;T1, T2&gt; {
    void convert(int i);
  }
}
<br><br><br>在学习lambda表达式之后，我们通常使用lambda表达式来创建匿名方法。然而，有时候我们仅仅是调用了一个已存在的方法。如下：  <br>Arrays.sort(arr,(s1,s2)-&gt;s1.compareToIgnoreCase(s2));
<br> 在Java8中，我们可以直接通过方法引用来简写lambda表达式中已经存在的方法。  <br>Arrays.sort(stringsArray, String::compareToIgnoreCase);
<br>这种特性就叫做方法引用(Method Reference)。<br>
方法引用的四种方式：<br>
类型	| 示例<br>
---|---<br>
引用静态方法 | ContainingClass::staticMethodName<br>
引用某个对象的实例方法	 | containingObject::instanceMethodName<br>
引用某个类型的任意对象的实例方法 | 	ContainingType::methodName<br>
引用构造方法	 | ClassName::new<br>class Test {

  public static int compare(String a, String b) {
    return a.compareTo(b);
  }

  public int compareObject(String a, String b) {
    return a.compareTo(b);
  }

  public static void main(String[] args) {

    String[] arr = {"a", "b", "c"};

    // 不使用lambda表达式的写法
    Arrays.sort(arr, new Comparator&lt;String&gt;() {
      public int compare(String a, String b) {
        return a.compareTo(b);
      }
    });

    // 静态引用  
    Arrays.sort(arr, Test::compare);    //因为arr是字符串数组，所以可以传入compare方法(字符串有compareTo方法)

    // 实例方法引用，可以是自己的方法，父类的，或者类型上的方法引用
    Arrays.sort(arr, new Test()::compareObject);// 当引用的方法有泛型时，泛型写在::之后，方法之前

    // 构造方法引用
    Supplier&lt;Test&gt; sup = () -&gt; new Test();

    Supplier&lt;Test&gt; supp = Test::new;
  }

}
<br><br>Java 8 新增了接口的默认方法。<br>
以前 接口的方法默认都是用   public abstract修饰的<br>
java8 之后 默认方法就是接口的方法用default修饰的时候可以有方法体，还可以有静态方法<br>class Test {
  interface inter {
    default void print() {
      System.out.println("inter");
    }

    static void staticPrint() {
      System.out.println("static inter");
    }
  }

  interface inter1 {
    default void print() {
      System.out.println("inter1");
    }

  }

  class inner implements inter, inter1 {
    // 当一个类实现的多个接口中有同名的默认方法时，需要指定其中一个接口的方法作为类的方法或者自己重写一个同名方法
    public void print() {
      inter.super.print();// 指定inter接口的print方法作为类的方法
    }

  }

  public static void main(String[] args) {
    // 可以直接调用接口的默认方法和静态方法，不需要重写
    inter.staticPrint();
    new Test().new inner().print();
  }
}
<br><br>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br>
@FunctionalInterface  修饰 表名这是一个函数式接口  只可以有一个抽象方法<br>
函数式接口可以被隐式转换为lambda表达式。<br>
函数式接口可以现有的函数友好地支持 lambda。<br>
JDK 1.8之前已有的函数式接口:<br>
java.lang.Runnable<br>
java.util.concurrent.Callable<br>
java.security.PrivilegedAction<br>
java.util.Comparator<br>
java.io.FileFilter<br>
java.nio.file.PathMatcher<br>
java.lang.reflect.InvocationHandler<br>
java.beans.PropertyChangeListener<br>
java.awt.event.ActionListener<br>
javax.swing.event.ChangeListener<br>
JDK 1.8 新增加的函数接口：<br>java.util.function<br>
java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有：<br>其中的四个核心  demo:<br>class Test {

  public static void main(String[] args) {

    /**
     * @name 消费型接口
     * @use Consumer&lt;T&gt;
     * @param T 传入参数
     * @fun 接受一个参数 无返回值
     */
    Consumer&lt;String&gt; con = (str) -&gt; System.out.println(str);
    con.accept("我是消费型接口!");

    /**
     * @name 供给型接口
     * @use Supplier&lt;R&gt;
     * @param R 返回值类型
     * @fun 无参数 有返回值
     */
    Supplier&lt;Date&gt; supp = Date::new;
    Date date = supp.get();
    System.out.println("当前时间:" + date);

    /**
     * @name 函数型接口
     * @use Function&lt;T,R&gt;
     * @param T 传入参数
     * @return R 返回值类型
     * @fun 接受一个参数 有返回值
     */
    Function&lt;String, String&gt; fun = (str) -&gt; "hello," + str;
    String str = fun.apply("123");
    System.out.println(str);
    /**
     * @name 断定型接口
     * @use Predicate&lt;T&gt;
     * @param T 传入参数
     * @return Boolean 返回一个Boolean型值
     * @fun 接受一个参数 返回Boolean型值
     */
    Predicate&lt;Integer&gt; pre = (num) -&gt; num &gt; 0;
    Boolean flag = pre.test(10);
    System.out.println(flag);
  }
}
<br><br>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。<br>
Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。<br>
Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。<br>
这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。<br>
元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。<br><br>Stream（流）是一个来自数据源的元素队列并支持聚合操作<br>
元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。<br>
数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。<br>
聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。   
<br>和以前的Collection操作不同， Stream操作还有两个基础的特征：<br>
Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。<br>
内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。    
<br><br>在 Java 8 中, 集合接口有两个方法来生成流：<br>
stream() − 为集合创建串行流。<br>
parallelStream() − 为集合创建并行流。  
<br>demo:<br> public static void main(String args[]){
      System.out.println("使用 Java 7: ");
        
      // 计算空字符串
      List&lt;String&gt; strings = Arrays.asList("abc", "", "bc", "efg", "abcd","", "jkl");
      System.out.println("列表: " +strings);
      long count = getCountEmptyStringUsingJava7(strings);
        
      System.out.println("空字符数量为: " + count);
      count = getCountLength3UsingJava7(strings);
        
      System.out.println("字符串长度为 3 的数量为: " + count);
        
      // 删除空字符串
      List&lt;String&gt; filtered = deleteEmptyStringsUsingJava7(strings);
      System.out.println("筛选后的列表: " + filtered);
        
      // 删除空字符串，并使用逗号把它们合并起来
      String mergedString = getMergedStringUsingJava7(strings,", ");
      System.out.println("合并字符串: " + mergedString);
      List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
        
      // 获取列表元素平方数
      List&lt;Integer&gt; squaresList = getSquares(numbers);
      System.out.println("平方数列表: " + squaresList);
      List&lt;Integer&gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19);
        
      System.out.println("列表: " +integers);
      System.out.println("列表中最大的数 : " + getMax(integers));
      System.out.println("列表中最小的数 : " + getMin(integers));
      System.out.println("所有数之和 : " + getSum(integers));
      System.out.println("平均数 : " + getAverage(integers));
      System.out.println("随机数: ");
        
      // 输出10个随机数
      Random random = new Random();
        
      for(int i=0; i &lt; 10; i++){
         System.out.println(random.nextInt());
      }
        
      System.out.println("使用 Java 8: ");
      System.out.println("列表: " +strings);
        
      count = strings.stream().filter(string-&gt;string.isEmpty()).count();
      System.out.println("空字符串数量为: " + count);
        
      count = strings.stream().filter(string -&gt; string.length() == 3).count();
      System.out.println("字符串长度为 3 的数量为: " + count);
        
      filtered = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.toList());
      System.out.println("筛选后的列表: " + filtered);
        
      mergedString = strings.stream().filter(string -&gt;!string.isEmpty()).collect(Collectors.joining(", "));
      System.out.println("合并字符串: " + mergedString);
        
      squaresList = numbers.stream().map( i -&gt;i*i).distinct().collect(Collectors.toList());
      System.out.println("Squares List: " + squaresList);
      System.out.println("列表: " +integers);
        
      IntSummaryStatistics stats = integers.stream().mapToInt((x) -&gt;x).summaryStatistics();
        
      System.out.println("列表中最大的数 : " + stats.getMax());
      System.out.println("列表中最小的数 : " + stats.getMin());
      System.out.println("所有数之和 : " + stats.getSum());
      System.out.println("平均数 : " + stats.getAverage());
      System.out.println("随机数: ");
        
      random.ints().limit(10).sorted().forEach(System.out::println);
        
      // 并行处理
      count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();
      System.out.println("空字符串的数量为: " + count);
   }
    
   private static int getCountEmptyStringUsingJava7(List&lt;String&gt; strings){
      int count = 0;
        
      for(String string: strings){
        
         if(string.isEmpty()){
            count++;
         }
      }
      return count;
   }
    
   private static int getCountLength3UsingJava7(List&lt;String&gt; strings){
      int count = 0;
        
      for(String string: strings){
        
         if(string.length() == 3){
            count++;
         }
      }
      return count;
   }
    
   private static List&lt;String&gt; deleteEmptyStringsUsingJava7(List&lt;String&gt; strings){
      List&lt;String&gt; filteredList = new ArrayList&lt;String&gt;();
        
      for(String string: strings){
        
         if(!string.isEmpty()){
             filteredList.add(string);
         }
      }
      return filteredList;
   }
    
   private static String getMergedStringUsingJava7(List&lt;String&gt; strings, String separator){
      StringBuilder stringBuilder = new StringBuilder();
        
      for(String string: strings){
        
         if(!string.isEmpty()){
            stringBuilder.append(string);
            stringBuilder.append(separator);
         }
      }
      String mergedString = stringBuilder.toString();
      return mergedString.substring(0, mergedString.length()-2);
   }
    
   private static List&lt;Integer&gt; getSquares(List&lt;Integer&gt; numbers){
      List&lt;Integer&gt; squaresList = new ArrayList&lt;Integer&gt;();
        
      for(Integer number: numbers){
         Integer square = new Integer(number.intValue() * number.intValue());
            
         if(!squaresList.contains(square)){
            squaresList.add(square);
         }
      }
      return squaresList;
   }
    
   private static int getMax(List&lt;Integer&gt; numbers){
      int max = numbers.get(0);
        
      for(int i=1;i &lt; numbers.size();i++){
        
         Integer number = numbers.get(i);
            
         if(number.intValue() &gt; max){
            max = number.intValue();
         }
      }
      return max;
   }
    
   private static int getMin(List&lt;Integer&gt; numbers){
      int min = numbers.get(0);
        
      for(int i=1;i &lt; numbers.size();i++){
         Integer number = numbers.get(i);
        
         if(number.intValue() &lt; min){
            min = number.intValue();
         }
      }
      return min;
   }
    
   private static int getSum(List numbers){
      int sum = (int)(numbers.get(0));
        
      for(int i=1;i &lt; numbers.size();i++){
         sum += (int)numbers.get(i);
      }
      return sum;
   }
    
   private static int getAverage(List&lt;Integer&gt; numbers){
      return getSum(numbers) / numbers.size();
   }
<br><br>Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。<br>
Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。<br>
Optional 类的引入很好的解决空指针异常。  <br>demo:<br>class Test {
  public static void main(String args[]) {

    Test java8Tester = new Test();
    Integer value1 = null;
    Integer value2 = new Integer(10);

    // Optional.ofNullable - 允许传递为 null 参数
    Optional&lt;Integer&gt; a = Optional.ofNullable(value1);

    // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException
    Optional&lt;Integer&gt; b = Optional.of(value2);
    System.out.println(java8Tester.sum(a, b));
  }

  public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) {

    // Optional.isPresent - 判断值是否存在

    System.out.println("第一个参数值存在: " + a.isPresent());
    System.out.println("第二个参数值存在: " + b.isPresent());

    // Optional.orElse - 如果值存在，返回它，否则返回默认值
    Integer value1 = a.orElse(new Integer(0));

    // Optional.get - 获取值，值需要存在
    Integer value2 = b.get();
    return value1 + value2;
  }
}
<br>只能解决空指针null问题  对于字符串  是否是空字符串等的判断还是需要<br><br>Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。<br>
在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：  <br>
非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。<br>
设计很差− Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。<br>
时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。  
<br>Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：  <br>
Local(本地)− 简化了日期时间的处理，没有时区的问题。<br>
Zoned(时区) − 通过制定的时区处理日期时间。  
<br>新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。  <br>local demo : <br>class Test {
  public static void main(String args[]) {
    Test java8tester = new Test();
    java8tester.testLocalDateTime();
  }

  public void testLocalDateTime() {

    // 获取当前的日期时间
    LocalDateTime currentTime = LocalDateTime.now();
    System.out.println("当前时间: " + currentTime);

    LocalDate date1 = currentTime.toLocalDate();
    System.out.println("date1: " + date1);

    Month month = currentTime.getMonth();
    int day = currentTime.getDayOfMonth();
    int seconds = currentTime.getSecond();

    System.out.println("月: " + month + ", 日: " + day + ", 秒: " + seconds);

    LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012);
    System.out.println("date2: " + date2);

    // 12 december 2014
    LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12);
    System.out.println("date3: " + date3);

    // 22 小时 15 分钟
    LocalTime date4 = LocalTime.of(22, 15);
    System.out.println("date4: " + date4);

    // 解析字符串
    LocalTime date5 = LocalTime.parse("20:15:30");
    System.out.println("date5: " + date5);
  }
}
<br>zone demo:<br>class Test {
  public static void main(String args[]){
    Test java8tester = new Test();
    java8tester.testZonedDateTime();
 }
  
 public void testZonedDateTime(){
  
    // 获取当前时间日期
    ZonedDateTime date1 = ZonedDateTime.parse("2015-12-03T10:15:30+05:30[Asia/Shanghai]");
    System.out.println("date1: " + date1);
      
    ZoneId id = ZoneId.of("Europe/Paris");
    System.out.println("ZoneId: " + id);
      
    ZoneId currentZone = ZoneId.systemDefault();
    System.out.println("当期时区: " + currentZone);
 }
}
<br>]]></description><link>02-编程语言\01-java\01-jdk版本特性\01-java8特性.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/01-JDK版本特性/01-java8特性.md</guid><pubDate>Wed, 10 Apr 2024 07:01:56 GMT</pubDate></item><item><title><![CDATA[02-多线程]]></title><description><![CDATA[<a class="tag" href="?query=tag:673ab7" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#673ab7</a> 
 <br><a data-tooltip-position="top" aria-label="https://github.com/RedSpider1/concurrent" rel="noopener nofollow" class="external-link" href="https://github.com/RedSpider1/concurrent" target="_blank">RedSpider社区成员原创与维护的Java多线程系列文章</a><br><br>线程状态图<br><img src="02-编程语言\01-java\02-多线程\assets\线程状态图.png"><br>
线程状态图2<br>
<img src="02-编程语言\01-java\02-多线程\assets\线程状态图2.png"><br><br>新建状态(New)<br>当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread();<br>就绪状态(Runnable)<br>当调用线程对象的start()方法(t.start();)，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；<br>运行状态(Running)<br>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就 &nbsp; &nbsp; 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；<br>阻塞状态(Blocked)<br>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：<br>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；<br>2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；<br>3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。<br>死亡状态(Dead)<br>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。<br><br>sleep() &nbsp;<br>　　sleep()方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入阻塞状态，该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。但是sleep()方法不会释放“锁标志”，也就是说如果有synchronized同步块，其他线程仍然不能访问共享数据。 &nbsp;<br>wait() &nbsp;<br>　　wait()方法需要和notify()及notifyAll()两个方法一起介绍，这三个方法用于协调多个线程对共享数据的存取，所以必须在synchronized语句块内使用，也就是说，调用wait()，notify()和notifyAll()的任务在调用这些方法前必须拥有对象的锁。注意，它们都是Object类的方法，而不是Thread类的方法。 &nbsp;<br>　　wait()方法与sleep()方法的不同之处在于，wait()方法会释放对象的“锁标志”。当调用某一对象的wait()方法后，会使当前线程暂停执行，并将当前线程放入对象等待池中，直到调用了notify()方法后，将从对象等待池中移出任意一个线程并放入锁标志等待池中，只有锁标志等待池中的线程可以获取锁标志，它们随时准备争夺锁的拥有权。当调用了某个对象的notifyAll()方法，会将对象等待池中的所有线程都移动到该对象的锁标志等待池。 &nbsp;<br>　　除了使用notify()和notifyAll()方法，还可以使用带毫秒参数的wait(long timeout)方法，效果是在延迟timeout毫秒后，被暂停的线程将被恢复到锁标志等待池。 &nbsp;<br>　　此外，wait()，notify()及notifyAll()只能在synchronized语句中使用，但是如果使用的是ReenTrantLock实现同步，该如何达到这三个方法的效果呢？解决方法是使用ReenTrantLock.newCondition()获取一个Condition类对象，然后Condition的await()，signal()以及signalAll()分别对应上面的三个方法。<br>yield() &nbsp;<br>　　yield()方法和sleep()方法类似，也不会释放“锁标志”，区别在于，它没有参数，即yield()方法只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行，另外yield()方法只能使同优先级或者高优先级的线程得到执行机会，这也和sleep()方法不同。<br>join() &nbsp;<br>　　join()方法会使当前线程等待调用join()方法的线程结束后才能继续执行<br>
join的使用实例<br>
```java<br>
public class JoinExample implements Runnable {<br>
public void run() {<br>
System.out.println(Thread.currentThread().getName() + " is running");<br>
try {<br>
Thread.sleep(1000);<br>
} catch (InterruptedException e) {<br>
e.printStackTrace();<br>
}<br>
System.out.println(Thread.currentThread().getName() + " is done");<br>
}<br>public static void main(String[] args) {
    Thread t1 = new Thread(new JoinExample(), "Thread 1");
    Thread t2 = new Thread(new JoinExample(), "Thread 2");

    t1.start();
    t2.start();

    try {
        t1.join(); // 等待t1线程执行完毕
        t2.join(); // 等待t2线程执行完毕
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    System.out.println("All threads are done");
}
<br>}<br>
/<br>
输出结果：<br>
Thread 1 is running<br>
Thread 2 is running<br>
Thread 2 is done<br>
Thread 1 is done<br>
All threads are done<br>
  可见 join只是让其他现场加入当前线程并且在加入的线程执行完后当前线程才继续执行，假如加入多个线程，并不保证这多个线程的执行顺序/<br>
```java

public static void main(String[] args) throws InterruptedException {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final ExecutorService exec = Executors.newFixedThreadPool(4);//线程池容量4

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final ReentrantLock lock = new ReentrantLock();

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final Condition con = lock.newCondition();

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final int time = 2;

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final Runnable add = new Runnable() {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; public void run() {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.lock();

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println("Pre " + lock);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; try {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; con.await(time, TimeUnit.SECONDS);//await方法会释放锁

// &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Thread.sleep(2000);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } catch (InterruptedException e) {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; e.printStackTrace();

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } finally {

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; System.out.println("Post " + lock.toString());

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; lock.unlock();

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(int index = 0; index &lt; 4; index++)

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exec.submit(add);

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exec.shutdown();

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }

<br>输出：四个pre,延迟2s,四个post<br>
Pre java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-1]

Pre java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-2]

Pre java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-3]

Pre java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-4]

Post java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-3]

Post java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-1]

Post java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-4]

Post java.util.concurrent.locks.ReentrantLock@4cd1355d[Locked by thread pool-1-thread-2]

<br>如果改成Thread.sleep(),输出:每个pre延迟2s,然后post<br>
Pre java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-1]

Post java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-1]

Pre java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-2]

Post java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-2]

Pre java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-3]

Post java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-3]

Pre java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-4]

Post java.util.concurrent.locks.ReentrantLock@fb77e4c[Locked by thread pool-1-thread-4]

<br>wait(),notify(),notifyAll()同理：<br>
  public static void main(String[] args) throws InterruptedException {

        final ExecutorService exec = Executors.newFixedThreadPool(4);

        final Runnable add = new Runnable() {

          public synchronized  void run() {

            System.out.println("Pre " + Thread.currentThread().getName());

            try {

//              Thread.sleep(5000);

              this.wait(2000);

            } catch (InterruptedException e) {

              e.printStackTrace();

            } finally {

              System.out.println("Post " + Thread.currentThread().getName());

            }

          }

        };

        for(int index = 0; index &lt; 4; index++)

          exec.submit(add);

        exec.shutdown();

      }

<br><br>Java中的wait()和notify()方法是用于线程同步的基本方法，它们通常是在生产者和消费者模式中使用的。具体来说，当多个线程需要共享同一个资源时，就需要使用这些方法来协调线程之间的通信。<br>wait()方法是一个对象级别的方法，用于将当前线程置于对象的等待池中，并释放该对象的锁。当线程调用wait()方法时，它就会释放所持有的对象锁，进入等待状态，直到其他线程调用该对象的notify()方法唤醒它。wait()方法可以指定一个超时时间，如果在超时时间内没有被唤醒，那么线程就会自动唤醒。<br>notify()方法也是一个对象级别的方法，用于唤醒在对象等待池中等待的一个线程。当线程调用notify()方法时，它会通知在该对象等待池中等待的某个线程，使其从等待池中出队，并重新尝试获取该对象的锁。<br>下面是一个使用wait()和notify()方法的示例代码：<br>
<a rel="noopener nofollow" class="external-link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1306580911915042" target="_blank">https://www.liaoxuefeng.com/wiki/1252599548343744/1306580911915042</a><br>import java.util.*;  
  
public class WaitNotifyExample {  
    public static void main(String[] args) throws InterruptedException {  
        var q = new TaskQueue();  
        var ts = new ArrayList&lt;Thread&gt;();  
        for (int i=0; i&lt;5; i++) {  
            var t = new Thread() {  
                public void run() {  
                    // 执行task:  
                    while (true) {  
                        try {  
                            String s = q.getTask();  
                            System.out.println(Thread.currentThread().getName() + "execute task: " + s);  
                        } catch (InterruptedException e) {  
                            return;  
                        }  
                    }  
                }  
            };  
            t.start();  
            ts.add(t);  
        }  
        var add = new Thread(() -&gt; {  
            for (int i=0; i&lt;20; i++) {  
                // 放入task:  
                String s = "t-" + Math.random();  
                System.out.println("add task: " + s);  
                q.addTask(s);  
                try { Thread.sleep(100); } catch(InterruptedException e) {}  
            }  
        });  
        add.start();  
        add.join();  
        Thread.sleep(100);  
        for (var t : ts) {  
	        // 队列中的task都执行完了  中断等待的线程
            t.interrupt();  
        }  
    }  
}  
  
class TaskQueue {  
    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();  
  
    public synchronized void addTask(String s) {  
        this.queue.add(s);  
        this.notify();  
        // this.notifyAll();  //一样的
    }  
  
    public synchronized String getTask() throws InterruptedException {  
        while (queue.isEmpty()) {  
            this.wait();  
        }  
        return queue.remove();  
    }  
}

<br>在这个示例中，我们定义了一个WaitNotifyExample类，其中包含一个布尔型的flag变量。waitForFlag()方法通过while循环来检查flag变量的值，如果它为false，则调用wait()方法将线程置于等待状态。setFlag()方法用于将flag变量设置为true，并调用notifyAll()方法来唤醒在等待池中等待的所有线程。<br>在使用wait()和notify()方法时，需要注意以下几点：<br>
<br>wait()和notify()方法只能用于同步方法或同步块中，否则会抛出IllegalMonitorStateException异常。
<br>wait()方法和notify()方法必须在同一个对象上调用，否则也会抛出IllegalMonitorStateException异常。
<br>wait()方法和notify()方法应该始终使用while循环进行调用，以避免虚假唤醒问题。
<br>wait()方法可以指定超时时间，如果在超时时间内没有被唤醒，那么线程就会自动唤醒。
<br>notify()方法只会唤醒在等待池中等待的一个线程，如果需要唤醒所有等待的线程，可以使用notifyAll()方法。
<br><br>知道了如何使用，就得知道他的原理到底是什么？<br>首先我们看，使用这两个方法的顺序一般是什么？<br>
<br>使用 wait ，notify 和 notifyAll 时需要先对调用对象加锁。
<br>调用 wait 方法后，线程状态有 Running 变为 Waiting，并将当前线程放置到对象的 等待队列。
<br>notify 或者 notifyAll 方法调用后， 等待线程依旧不会从 wait 返回，需要调用 noitfy 的线程释放锁之后，等待线程才有机会从 wait 返回。
<br>notify 方法将等待队列的一个等待线程从等待队列种移到同步队列中，而 notifyAll 方法则是将等待队列种所有的线程全部移到同步队列，被移动的线程状态由 Waiting 变为 Blocked。
<br>从 wait 方法返回的前提是获得了调用对象的锁。
<br>从上述细节可以看到，等待/通知机制依托于同步机制，其目的就是确保等待线程从 wait 方法返回后能够感知到通知线程对变量做出的修改。<br>该图描述了上面的步骤：<br><img src="02-编程语言\01-java\02-多线程\assets\wait,notify原理图.png"><br>WaitThread 获得了对象的锁，调用对象的 wait 方法，放弃了锁，进入的等待队列，然后 NotifyThread 拿到了对象的锁，然后调用对象的 notify 方法，将 WatiThread 移动到同步队列中，最后，NotifyThread 执行完毕，释放锁， WaitThread 再次获得锁并从 wait 方法返回继续执行。<br><br>java中要开启一个线程，只能是新建一个Thread的实例或者继承了Thread的子类的实例，调用start方法，便开启了 线程 &nbsp;进入Runnable状态<br>
@Test

    public void demo1() {

          new Thread().start();

    }

<br>上面代码就创建了并启用了一个线程 &nbsp; 只是因为没有传入实现Runnable接口的实例对象或者集成Thread并重写了run()方法的对象，所以什么也没执行，线程就执行完毕，消亡掉了。<br><br>
<br>继承Thread类，重写该类的run()方法
<br>实现 Runnable 接口
<br>实现 Callable 接口
<br>使用线程池
<br>import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

public class CallableExample {
    public static void main(String[] args) throws Exception {
        ExecutorService executor = Executors.newSingleThreadExecutor();

        Callable&lt;Integer&gt; task = new Callable&lt;Integer&gt;() {
            public Integer call() {
                int sum = 0;
                for (int i = 1; i &lt;= 10; i++) {
                    sum += i;
                }
                return sum;
            }
        };

        Future&lt;Integer&gt; future = executor.submit(task);

        System.out.println("Result: " + future.get());

        executor.shutdown();
    }
}

<br><br>Runnable&nbsp;接口run 方法无返回值；Callable&nbsp;接口call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果&nbsp;Runnable&nbsp;接口run 方法只能抛出运行时异常，且无法捕获处理；Callable&nbsp;接口call 方法允许抛出异常，可以获取异常信息<br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/Somhu/article/details/78874634" target="_blank">https://blog.csdn.net/Somhu/article/details/78874634</a><br>在JDK5.0版本之前，重入锁的性能远远好于synchronized关键字，JDK6.0版本之后synchronized 得到了大量的优化，二者性能也不分伯仲，但是重入锁是可以完全替代synchronized关键字的.<br>重入锁和synchronized最大的区别是锁是可重入的 所以释放锁也要多次释放（和获取锁的次数相同），这样才能释放锁 ，重入锁的获取锁和释放锁都是显示的<br>
public class ReentrantLockTest implements Runnable{

    public static ReentrantLock lock = new ReentrantLock();

    public static int i = 0;

    @Override

    public void run() {

        for (int j = 0; j &lt; 10000; j++) {

            lock.lock();  // 看这里就可以

            //lock.lock(); ①

            try {

                i++;

            } finally {

                lock.unlock(); // 看这里就可以

                //lock.unlock();②

            }

        }

    }

    public static void main(String[] args) throws InterruptedException {

        ReentrantLockTest test = new ReentrantLockTest();

        Thread t1 = new Thread(test);

        Thread t2 = new Thread(test);

        t1.start();t2.start();

        t1.join(); t2.join(); // main线程会等待t1和t2都运行完再执行以后的流程

        System.err.println(i);

    }

}

<br>t1.join(),t2,join()方法 这样 主线程打印的是20000，注释掉 可能是0-20000之间的任何数 &nbsp; &nbsp;join()的用法体现<br>①②处的注释放开就体现了重入锁锁的可重入性 &nbsp;只放开②会报 java.lang.IllegalMonitorStateException 异常 只放开①会造成死锁<br>为什么要引入可重入锁呢？开始我以为synchronized是不可重入的<br>
public class SynchronizedDemo implements Runnable{

    public static int i = 0;

    @Override

    public synchronized void  run() {

      while(i&lt;10000) {

        i++;

        run();

      }

    }

    public static void main(String[] args) throws InterruptedException {

      SynchronizedDemo test = new SynchronizedDemo();

        Thread t1 = new Thread(test);

        t1.start();

        t1.join();  // main线程会等待t1和t2都运行完再执行以后的流程

        System.err.println(i);

    }

}

<br>可重入和不可重入的概念：当一个线程获得了当前实例的锁，并进入方法A，则这个线程在没有释放这把锁的时候，能否再次进入方法A呢？<br>本来以为这样会导致死锁，发现没有，说明synchronized是可重入的（jdk1.8可能之前不能，只有对synchronized有过优化？）<br>那么为什么引入synchronized呢？仅仅是因为它能显示的加锁释放锁么？<br>ReenTrantLock独有的能力：<br>
<br>&nbsp; &nbsp; &nbsp;ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。
<br>
public ReentrantLock(boolean fair) {

    sync = fair ? new FairSync() : new NonfairSync();

}

<br>
<br>&nbsp; &nbsp; &nbsp;ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。
<br>lock.newCondition()<br>condition.await() &nbsp; &nbsp; &nbsp;obj.wait()<br>condition.signal() &nbsp; &nbsp;obj.notify() &nbsp; &nbsp;调用signal()方法前需要获取到创建该对象的锁否则会产生<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // java.lang.IllegalMonitorStateException异常<br>condition.signalAll() &nbsp;obj.notifyAll()<br>
<br>&nbsp; &nbsp; &nbsp;ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。
<br>对于synchronized块来说，要么获取到锁执行，要么持续等待。而重入锁的中断响应功能就合理地避免了这样的情况。比如，一个正在等待获取锁的线程被“告知”无须继续等待下去，就可以停止工作了。直接上代码，来演示使用重入锁如何解决死锁：<br>
public class KillDeadlock implements Runnable{

    public static ReentrantLock lock1 = new ReentrantLock();

    public static ReentrantLock lock2 = new ReentrantLock();

    int lock;

    public KillDeadlock(int lock) {

        this.lock = lock;

    }

    @Override

    public void run() {

        try {

            if (lock == 1) {

                lock1.lockInterruptibly();  // 以可以响应中断的方式加锁

                try {

                    Thread.sleep(500);

                } catch (InterruptedException e) {}

                lock2.lockInterruptibly();

            } else {

                lock2.lockInterruptibly();  // 以可以响应中断的方式加锁

                try {

                    Thread.sleep(500);

                } catch (InterruptedException e) {}

                lock1.lockInterruptibly();

            }

        } catch (InterruptedException e) {

            e.printStackTrace();

        } finally {

            if (lock1.isHeldByCurrentThread()) lock1.unlock();  // 注意判断方式

            if (lock2.isHeldByCurrentThread()) lock2.unlock();

            System.err.println(Thread.currentThread().getId() + "退出！");

        }

    }

    public static void main(String[] args) throws InterruptedException {

        KillDeadlock deadLock1 = new KillDeadlock(1);

        KillDeadlock deadLock2 = new KillDeadlock(2);

        Thread t1 = new Thread(deadLock1);

        Thread t2 = new Thread(deadLock2);

        t1.start();t2.start();

        Thread.sleep(1000);

        //t2.interrupt(); // ③

    }

}

<br>三处的注释没加上的时候，是死锁，打开注释，可以运行<br>运行结果：<br>java.lang.InterruptedException<br>&nbsp; at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(Unknown Source)<br>&nbsp; at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(Unknown Source)<br>&nbsp; at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source)<br>&nbsp; at com.KillDeadlock.run(KillDeadlock.java:28)<br>&nbsp; at java.lang.Thread.run(Unknown Source)<br>10退出！<br>11退出！<br>可以看到<br>t2只是释放了锁，保证t1执行，自己的任务却没有执行。。。。<br>锁申请等待限时：<br>如同synchronized一样。lock.lock()方法是没有获取到锁的话，会持续等待，ReentrantLock提供tryLock()或者tryLock(long timeout, TimeUtil unit) 方法进行一次限时的锁等待。<br>前者不带参数，这时线程尝试获取锁，如果获取到锁则继续执行，如果锁被其他线程持有，则立即返回 false ，也就是不会使当前线程等待，所以不会产生死锁。<br>后者带有参数，表示在指定时长内获取到锁则继续执行，如果等待指定时长后还没有获取到锁则返回false。<br>synchronized实现死锁 &nbsp; 线程一持有锁1，要去获取锁额二，线程二持有锁二，要去获取锁一，因为线程都没有结束，所以都不会释放自己的锁，却都想获取对方的锁，就一直等待，造成死锁<br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/sunp823/article/details/51887215" target="_blank">https://blog.csdn.net/sunp823/article/details/51887215</a> &nbsp; &nbsp; &nbsp;引入最佳案例<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/LightOfMiracle/article/details/73456832" target="_blank">https://blog.csdn.net/LightOfMiracle/article/details/73456832</a> &nbsp; &nbsp;原理<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/zhutulang/article/details/48504487" target="_blank">https://blog.csdn.net/zhutulang/article/details/48504487</a> &nbsp; 与join的区别（join只能是所有相关线程任务都执行完毕，阻塞的线程才继续执行，latch则是相关线程执行到某一阶段，就调用countDown()方法，就不再阻塞）<br>
public class CountDownLatchDemo {

  public static void main(String[] args) throws InterruptedException{

    CountDownLatch countDownLatch = new CountDownLatch(2){

      @Override

      public void await() throws InterruptedException {

        super.await();

        System.out.println(Thread.currentThread().getName() +  " count down is ok");

      }

    };

    Thread thread1 = new Thread(new Runnable() {

      @Override

      public void run() {

        //do something

        try {

          Thread.sleep(1000);

        } catch (InterruptedException e) {

          e.printStackTrace();

        }

        System.out.println(Thread.currentThread().getName() + " is done");

        countDownLatch.countDown();

      }

    }, "thread1");

    Thread thread2 = new Thread(new Runnable() {

      @Override

      public void run() {

        //do something

        try {

          Thread.sleep(2000);

        } catch (InterruptedException e) {

          e.printStackTrace();

        }

        System.out.println(Thread.currentThread().getName() + " is done");

        countDownLatch.countDown();

      }

    }, "thread2");

    thread1.start();

    thread2.start();

    countDownLatch.await();    //主线程调用CountDownLatch实例的await()方法，除非状态值为0，不然主线程会一直阻塞

                               //例如:将thread2.start()注释掉，因为初始状态值为2，值调用一次countDown()，主线程一直阻塞

  }

}

<br>运行结果：<br>==thread1 is done &nbsp; &nbsp;//1000ms后thread1结束<br>thread2 is done &nbsp; &nbsp;//2000ms后thread2结束<br>main count down is ok <a href=".?query=tag:673ab7" class="tag" target="_blank" rel="noopener nofollow">#673ab7</a>==<br><br><a rel="noopener nofollow" class="external-link" href="https://juejin.im/post/5afb9ab3f265da0b736dd1e1" target="_blank">https://juejin.im/post/5afb9ab3f265da0b736dd1e1</a><br>juc包下的ReentrantLock,CyclicBarrier等都依赖同步器，方法都是内部定义了一个类继承AbstractQueuedSynchronizer()，通过重写同步器的方法来实现自己的同步逻辑。AQS基于一个FIFO双向队列实现，被设计给那些依赖一个代表状态的原子int值的同步器使用。我们都知道，既然叫同步器，那个肯定有个代表同步状态（临界资源）的东西，在AQS中即为一个叫state的int值，该值通过CAS进行原子修改<br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/liuchuanhong1/article/details/53539341" target="_blank">https://blog.csdn.net/liuchuanhong1/article/details/53539341</a><br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/carson0408/article/details/79471490" target="_blank">https://blog.csdn.net/carson0408/article/details/79471490</a><br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/qq_19431333/article/details/70212663" target="_blank">https://blog.csdn.net/qq_19431333/article/details/70212663</a><br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/carson0408/article/details/79477280" target="_blank">https://blog.csdn.net/carson0408/article/details/79477280</a><br>线程池<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/hsuxu/article/details/8985931" target="_blank">https://blog.csdn.net/hsuxu/article/details/8985931</a><br>ThreadLocal原理分析与使用场景<br><a rel="noopener nofollow" class="external-link" href="https://www.cnblogs.com/luxiaoxun/p/8744826.html" target="_blank">https://www.cnblogs.com/luxiaoxun/p/8744826.html</a>]]></description><link>02-编程语言\01-java\02-多线程\02-多线程.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/02-多线程/02-多线程.md</guid><pubDate>Wed, 08 May 2024 09:08:06 GMT</pubDate><enclosure url="02-编程语言\01-java\02-多线程\assets\线程状态图.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\02-多线程\assets\线程状态图.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[03-ThreadLocal]]></title><description><![CDATA[ 
 <br>ThreadLocal出现OOM内存溢出的场景和原理分析:<a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/GoGleTech/article/details/78318712" target="_blank">https://blog.csdn.net/GoGleTech/article/details/78318712</a><br><br>比如像用户登录令牌解密后的信息传递、用户权限信息、从用户系统中获取到的用户名<br><br>第一点（线程池里线程调用ThreadLocal）：因为线程池里对线程的管理都是线程复用的方法，所以在线程池里线程非常难结束，更有可能的是永远不会结束。这就意味着线程的持续时间是不可估测的，甚至会与JVM的生命周期一致。<br>第二点（在异步程序里）：ThreadLocal的参数传递是不可靠的，因为线程将请求发送后，不会在等待远程返回结果就继续向下运行了，真正的返回结果得到以后，可能是其它的线程在处理。<br>第三点：在使用完ThreadLocal，推荐要调用一下remove（）方法，这样会防止内存溢出这种情况的发生，因为ThreadLocal为弱引用。如果ThreadLocal在没有被外部强引用的情况下，在垃圾回收的时候是会被清理掉的，如果是强引用那就不会被清理。]]></description><link>02-编程语言\01-java\02-多线程\03-threadlocal.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/02-多线程/03-ThreadLocal.md</guid><pubDate>Wed, 10 Apr 2024 07:02:03 GMT</pubDate></item><item><title><![CDATA[04-线程池ThreadPoolExecutor]]></title><description><![CDATA[ 
 <br>优质博文：<br>
<a data-tooltip-position="top" aria-label="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" rel="noopener nofollow" class="external-link" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank">Java线程池实现原理及其在美团业务中的实践</a><br><br>常见的等待队列：<br>
<img src="02-编程语言\01-java\02-多线程\assets\常见的等待队列.png"><br>ArrayBlockingQueue源码分析:<br>
<a rel="noopener nofollow" class="external-link" href="https://www.cnblogs.com/tuyang1129/p/12683373.html" target="_blank">https://www.cnblogs.com/tuyang1129/p/12683373.html</a><br>什么叫阻塞呢？<br>
阻塞就是说在等待条件满足的过程中，你不可以去干其他的事情<br>为什么说 ArrayBlockingQueue是阻塞队列呢，就是因为它的put操作 是阻塞的<br>
所以如果用 add()  或者 offer()  就起不到阻塞队列的作用<br>  
public void put(E e) throws InterruptedException {
    // 判断元素是否为null，若为null将抛出异常
    checkNotNull(e);
    // 获取锁对象lock
    final ReentrantLock lock = this.lock;
    // 调用lock的lockInterruptibly方法加锁，lockInterruptibly可以响应中断
    // 加锁是为了防止多个线程同时操作队列，造成线程安全问题
    lock.lockInterruptibly();
    try {
        // 如果当前队列中的元素的个数为数组长度，表示队列满了，
        // 这时调用notFull.await()让当前线程阻塞，也就是让生产者阻塞
        // 而此处使用while循环而不是if，是考虑到线程被唤醒后，队列可能还是满的
        // 所以线程被唤醒后，需要再次判断，若依旧是满的，则再次阻塞
        while (count == items.length)
            notFull.await();
        
        // 调用enqueue方法将元素加入数组中
        enqueue(e);
    } finally {
        // 释放锁
        lock.unlock();
    }
}

/** 此方法将新元素加入到数组中 */
private void enqueue(E x) {
    // 获得存储元素的数组
    final Object[] items = this.items;
    // 将新元素x放入到数组中，且放入的位置就是putIndex指向的位置
    items[putIndex] = x;
    // putIndex加1，如果超过了数组的最大长度，则将其置为0，也就是数组的第一个位置
    if (++putIndex == items.length)
        putIndex = 0;
    // 元素数量+1
    count++;
    // 因为我们已经向队列中添加了元素，所以可以唤醒那些需要获取元素的线程，也就是消费者
    // 之前说过，notEmpty就是用来阻塞和唤醒消费者的
    notEmpty.signal();
}

// 判断元素是否为null
private static void checkNotNull(Object v) {
    if (v == null)
        throw new NullPointerException();
}
<br><br><img src="02-编程语言\01-java\02-多线程\assets\线程池参数设置的合理性.png"><br><br>动态化线程池的核心设计包括以下三个方面：<br>
<br>
&nbsp;简化线程池配置：线程池构造参数有8个，但是最核心的是3个：corePoolSize、maximumPoolSize，workQueue，它们最大程度地决定了线程池的任务分配和线程分配策略。考虑到在实际应用中我们获取并发性的场景主要是两种：（1）并行执行子任务，提高响应速度。这种情况下，应该使用同步队列，没有什么任务应该被缓存下来，而是应该立即执行。（2）并行执行大批次任务，提升吞吐量。这种情况下，应该使用有界队列，使用队列去缓冲大批量的任务，队列容量必须声明，防止任务无限制堆积。所以线程池只需要提供这三个关键参数的配置，并且提供两种队列的选择，就可以满足绝大多数的业务需求，Less is More。

<br>
&nbsp;参数可动态修改：为了解决参数不好配，修改参数成本高等问题。在Java线程池留有高扩展性的基础上，封装线程池，允许线程池监听同步外部的消息，根据消息进行修改配置。将线程池的配置放置在平台侧，允许开发同学简单的查看、修改线程池配置。

<br>
&nbsp;增加线程池监控：对某事物缺乏状态的观测，就对其改进无从下手。在线程池执行任务的生命周期添加监控能力，帮助开发同学了解线程池状态。

<br> 动态化线程池整体设计：<br>
<img src="02-编程语言\01-java\02-多线程\assets\动态化线程池整体设计.png"><br>
动态化线程池提供如下功能：<br>动态调参：支持线程池参数动态调整、界面化操作；包括修改线程池核心大小、最大核心大小、队列长度等；参数修改后及时生效。&nbsp;任务监控：支持应用粒度、线程池粒度、任务粒度的Transaction监控；可以看到线程池的任务执行情况、最大任务执行时间、平均任务执行时间、95/99线等。&nbsp;负载告警：线程池队列任务积压到一定值的时候会通过大象（美团内部通讯工具）告知应用开发负责人；当线程池负载数达到一定阈值的时候会通过大象告知应用开发负责人。&nbsp;操作监控：创建/修改和删除线程池都会通知到应用的开发负责人。&nbsp;操作日志：可以查看线程池参数的修改记录，谁在什么时候修改了线程池参数、修改前的参数值是什么。&nbsp;权限校验：只有应用开发负责人才能够修改应用的线程池参数。<br><img src="02-编程语言\01-java\02-多线程\assets\动态化线程池功能架构.png"><br>线程池参数动态化：<br>
<img src="02-编程语言\01-java\02-多线程\assets\线程池参数动态化.png"><br><br>场景1：快速响应用户请求<br>描述：用户发起的实时请求，服务追求响应时间。比如说用户要查看一个商品的信息，那么我们需要将商品维度的一系列信息如商品的价格、优惠、库存、图片等等聚合起来，展示给用户。<br>分析：从用户体验角度看，这个结果响应的越快越好，如果一个页面半天都刷不出，用户可能就放弃查看这个商品了。而面向用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程池这种简单的方式，将调用封装成任务并行的执行，缩短总体响应时间。另外，使用线程池也是有考量的，这种场景最重要的就是获取最大的响应速度去满足用户，所以应该不设置队列去缓冲并发任务，调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务。<br>
<img src="02-编程语言\01-java\02-多线程\assets\pasted-image-20230306161651.png"><br>场景2：快速处理批量任务<br>描述：离线的大量计算任务，需要快速执行。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。<br>分析：这种场景需要执行大量的任务，我们也会希望任务执行的越快越好。这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，这类场景任务量巨大，并不需要瞬时的完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量优先的问题。所以应该设置队列去缓冲并发任务，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程数过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。<br>
<img src="02-编程语言\01-java\02-多线程\assets\pasted-image-20230306161707.png"><br><br>In Java, a thread pool is a collection of pre-initialized threads that are used to execute tasks. The ThreadPoolExecutor class in Java provides a way to create and manage thread pools.<br>Both the execute and submit methods are used to submit a task to a thread pool for execution. However, there are some differences between them:<br>
<br>Return Value: The execute method has a void return type, while the submit method returns a Future object. This Future object can be used to check the status of the task, get the result of the task if it returns a value, and cancel the task.
<br>Exception Handling: The execute method does not throw any checked exceptions, while the submit method throws a RejectedExecutionException if the task cannot be accepted for execution.
<br>Task Parameters: The execute method takes a Runnable object as a parameter, while the submit method takes a Callable or a Runnable object as a parameter. The Callable interface is similar to the Runnable interface, but it allows the task to return a value.
<br>Execution: The execute method adds the task to the thread pool's queue and returns immediately, while the submit method submits the task to the thread pool and returns a Future object immediately. The task may not be executed immediately if all the threads in the thread pool are busy.
<br>In summary, the execute method is used to submit a task for execution without any expectation of a result, while the submit method is used to submit a task for execution and obtain a Future object that can be used to check the status and get the result of the task.<br>带返回值的 是阻塞的<br>import java.util.concurrent.*;  
  
public class TestCompletionService {  
    private static final String commandstr01 = "hahah";  
    private static final String commandstr02 = "hahah";  
  
  
    public static void main(String[] args) throws InterruptedException, ExecutionException {  
        //1、创建一个线程池  
        ExecutorService executorService = Executors.newCachedThreadPool();  
  
        CompletionService&lt;String&gt; completionService = new ExecutorCompletionService&lt;String&gt;(executorService);  
  
        Future&lt;String&gt; submit = completionService.submit(new MyThreadt33(commandstr01));  
        Future&lt;String&gt; submit1 = completionService.submit(new MyThreadt44(commandstr01));  
  
        executorService.shutdown();  
  
        System.out.println(completionService.take().get());  
        System.out.println(completionService.take().get());  
  
        System.out.println("submit: " + submit.get());  
        System.out.println("submit1: "+ submit1.get());  
    }  
}  
  
class MyThreadt33 implements Callable&lt;String&gt;{  
    private String commandstr;          // 要运行的mingling  
    public MyThreadt33(String commandstr) {  
        this.commandstr = commandstr;  
    }  
    @Override  
    public String call() throws Exception {  
        int sum = 0;  
        for (int i = 0; i &lt; 10; i++) {  
            Thread.sleep(200);  
            sum += i;  
            System.out.println("Mythread3: "+i);  
        }  
        return String.valueOf(sum+300000);  
    }  
}  
  
class MyThreadt44 implements Callable&lt;String&gt;{  
    private String commandstr;          // 要运行的mingling  
    public MyThreadt44(String commandstr) {  
        this.commandstr = commandstr;  
    }  
    @Override  
    public String call() throws Exception {  
        int sum = 0;  
        for (int i = 0; i &lt; 5; i++) {  
            Thread.sleep(200);  
            sum += i;  
            System.out.println("Mythread4: "+i);  
        }  
        return String.valueOf(sum+400000);  
    }  
}
<br>Mythread4: 0
Mythread3: 0
Mythread4: 1
Mythread3: 1
Mythread3: 2
Mythread4: 2
Mythread3: 3
Mythread4: 3
Mythread3: 4
Mythread4: 4
400010
Mythread3: 5
Mythread3: 6
Mythread3: 7
Mythread3: 8
Mythread3: 9
300045
submit: 300045
submit1: 400010
]]></description><link>02-编程语言\01-java\02-多线程\04-线程池threadpoolexecutor.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/02-多线程/04-线程池ThreadPoolExecutor.md</guid><pubDate>Wed, 08 May 2024 09:08:03 GMT</pubDate><enclosure url="02-编程语言\01-java\02-多线程\assets\常见的等待队列.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\02-多线程\assets\常见的等待队列.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05-多线程jvm实现(volatile,synchronized)]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/138819184" target="_blank">https://zhuanlan.zhihu.com/p/138819184</a><br>最近，在一篇文章中了解到了 volatile 关键字，在强烈的求知欲趋使下，我查阅了一些相关资料进行了学习，并将学习笔记记录如下，希望能给小伙伴们带来一些帮助。如果文章内容存在一些错误，也请小伙伴们指正，感谢。<br>这里先给大家分享一个我在 B 站发现的讲解 volitle 关键字的视频，有兴趣的同学可以认真看一下，挺不错的，我就是通过它进行的学习。<br>视频地址：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1BJ411j7qb%3Ffrom%3Dsearch%26seid%3D7212869160158812321" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1BJ411j7qb%3Ffrom%3Dsearch%26seid%3D7212869160158812321" target="_blank">https://www.bilibili.com/video/BV1BJ411j7qb?from=search&amp;seid=7212869160158812321</a>。<br><br>大家都应该知道 volatile 的主要作用有两点： - 保证变量的内存可见性 - 禁止指令重排序<br>那么，什么是内存可见性，什么是指令重排序，以及它们涉及了那些机制呢？下面就让我们来看看吧。<br>在这里提醒一下，各位小伙伴要有个心理准备，就一个 volatile 关键字所涉及的知识点超乎你的想象哟。<br><br>在理解 volatile 的内存可见性前，我们先来看看这个比较常见的多线程访问共享变量的例子。<br>/**
 * 变量的内存可见性例子
 *
 * @author star
 */
public class VolatileExample {

    /**
     * main 方法作为一个主线程
     */
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        // 开启线程
        myThread.start();

        // 主线程执行
        for (; ; ) {
            if (myThread.isFlag()) {
                System.out.println("主线程访问到 flag 变量");
            }
        }
    }

}

/**
 * 子线程类
 */
class MyThread extends Thread {

    private boolean flag = false;

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 修改变量值
        flag = true;
        System.out.println("flag = " + flag);
    }

    public boolean isFlag() {
        return flag;
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
<br>执行上面的程序，你会发现，控制台永远都不会输出 “主线程访问到 flag 变量” 这句话。我们可以看到，子线程执行时已经将 flag 设置成 true，但主线程执行时没有读到 flag 的最新值，导致控制台没有输出上面的句子。<br>那么，我们思考一下为什么会出现这种情况呢？这里我们就要了解一下 Java 内存模型（简称 JMM）。<br>Java 内存模型<br>JMM（Java Memory Model）：Java 内存模型，是 Java 虚拟机规范中所定义的一种内存模型，Java 内存模型是标准化的，屏蔽掉了底层不同计算机的区别。也就是说，JMM 是 JVM 中定义的一种并发编程的底层模型机制。<br>JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程以读/写共享变量的副本。<br>JMM 的规定：<br>
- 所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。<br>
<br>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。  
<br>线程对变量的所有的操作（读，取）都必须在工作内存中完成，而不能直接读写主内存中的变量。  
<br>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。  
<br>JMM 的抽象示意图：<br><img src="02-编程语言\01-java\02-多线程\assets\jmm抽象示意图.png"><br>JMM 示意图<br>然而，JMM 这样的规定可能会导致线程对共享变量的修改没有即时更新到主内存，或者线程没能够即时将共享变量的最新值同步到工作内存中，从而使得线程在使用共享变量的值时，该值并不是最新的。<br>正因为 JMM 这样的机制，就出现了可见性问题。也就是我们上面那个例子出现的问题。<br>那我们要如何解决可见性问题呢？接下来我们就聊聊内存可见性以及可见性问题的解决方案。<br><br>内存可见性是指当一个线程修改了某个变量的值，其它线程总是能知道这个变量变化。也就是说，如果线程 A 修改了共享变量 V 的值，那么线程 B 在使用 V 的值时，能立即读到 V 的最新值。<br><br>我们如何保证多线程下共享变量的可见性呢？也就是当一个线程修改了某个值后，对其他线程是可见的。<br>这里有两种方案：加锁 和 使用 volatile 关键字。<br>下面我们使用这两个方案对上面的例子进行改造。<br>加锁<br>使用 synchronizer 进行加锁。<br>/**
  * main 方法作为一个主线程
  */
  public static void main(String[] args) {
      MyThread myThread = new MyThread();
      // 开启线程
      myThread.start();

      // 主线程执行
      for (; ; ) {
          synchronized (myThread) {
              if (myThread.isFlag()) {
                  System.out.println("主线程访问到 flag 变量");
                }
          }
      }
  }
<br>这里大家应该有个疑问是，为什么加锁后就保证了变量的内存可见性了？ 因为当一个线程进入 synchronizer 代码块后，线程获取到锁，会清空本地内存，然后从主内存中拷贝共享变量的最新值到本地内存作为副本，执行代码，又将修改后的副本值刷新到主内存中，最后线程释放锁。<br>这里除了 synchronizer 外，其它锁也能保证变量的内存可见性。<br>使用 volatile 关键字<br>使用 volatile 关键字修饰共享变量。<br>/**
 * 子线程类
 */
class MyThread extends Thread {

    private volatile boolean flag = false;

    @Override
    public void run() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        // 修改变量值
        flag = true;
        System.out.println("flag = " + flag);
    }

    public boolean isFlag() {
        return flag;
    }

    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
<br>使用 volatile 修饰共享变量后，每个线程要操作变量时会从主内存中将变量拷贝到本地内存作为副本，当线程操作变量副本并写回主内存后，会通过 CPU 总线嗅探机制告知其他线程该变量副本已经失效，需要重新从主内存中读取。<br>volatile 保证了不同线程对共享变量操作的可见性，也就是说一个线程修改了 volatile 修饰的变量，当修改后的变量写回主内存时，其他线程能立即看到最新值。<br>接下来我们就聊聊一个比较底层的知识点：总线嗅探机制。<br>总线嗅探机制<br>在现代计算机中，CPU 的速度是极高的，如果 CPU 需要存取数据时都直接与内存打交道，在存取过程中，CPU 将一直空闲，这是一种极大的浪费，所以，为了提高处理速度，CPU 不直接和内存进行通信，而是在 CPU 与内存之间加入很多寄存器，多级缓存，它们比内存的存取速度高得多，这样就解决了 CPU 运算速度和内存读取速度不一致问题。<br>由于 CPU 与内存之间加入了缓存，在进行数据操作时，先将数据从内存拷贝到缓存中，CPU 直接操作的是缓存中的数据。但在多处理器下，将可能导致各自的缓存数据不一致（这也是可见性问题的由来），为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，而嗅探是实现缓存一致性的常见机制。<br><img src="https://pic2.zhimg.com/v2-77acfee471d8827a2121157c68f2485d_b.jpg" referrerpolicy="no-referrer"><br>处理器内存模型<br>
注意，缓存的一致性问题，不是多处理器导致，而是多缓存导致的。  
<br>嗅探机制工作原理：每个处理器通过监听在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从主内存中把数据读到处理器缓存中。<br>
注意：基于 CPU 缓存一致性协议，JVM 实现了 volatile 的可见性，但由于总线嗅探机制，会不断的监听总线，如果大量使用 volatile 会引起总线风暴。所以，volatile 的使用要适合具体场景。  
<br>可见性问题小结<br>上面的例子中，我们看到，使用 volatile 和 synchronized 锁都可以保证共享变量的可见性。相比 synchronized 而言，volatile 可以看作是一个轻量级锁，所以使用 volatile 的成本更低，因为它不会引起线程上下文的切换和调度。但 volatile 无法像 synchronized 一样保证操作的原子性。<br>下面我们来聊聊 volatile 的原子性问题。<br><br>所谓的原子性是指在一次操作或者多次操作中，要么所有的操作全部都得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。<br>在多线程环境下，volatile 关键字可以保证共享数据的可见性，但是并不能保证对数据操作的原子性。也就是说，多线程环境下，使用 volatile 修饰的变量是线程不安全的。<br>要解决这个问题，我们可以使用锁机制，或者使用原子类（如 AtomicInteger）。<br>这里特别说一下，对任意单个使用 volatile 修饰的变量的读 / 写是具有原子性，但类似于 flag = !flag 这种复合操作不具有原子性。简单地说就是，单纯的赋值操作是原子性的。<br><br>什么是重排序？<br>为了提高性能，在遵守 as-if-serial 语义（即不管怎么重排序，单线程下程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守。）的情况下，编译器和处理器常常会对指令做重排序。<br>一般重排序可以分为如下三种类型：<br>
<br>编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。  
<br>指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。  
<br>内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。  
<br>
数据依赖性：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。  
<br>从 Java 源代码到最终执行的指令序列，会分别经历下面三种重排序：<br><img src="https://pic2.zhimg.com/v2-8655d85c8a9df1bc2262485248b07d4d_b.jpg" referrerpolicy="no-referrer"><br>重排序顺序<br>为了更好地理解重排序，请看下面的部分示例代码：<br>int a = 0;
// 线程 A
a = 1;           // 1
flag = true;     // 2

// 线程 B
if (flag) { // 3
  int i = a; // 4
}
<br>单看上面的程序好像没有问题，最后 i 的值是 1。但是为了提高性能，编译器和处理器常常会在不改变数据依赖的情况下对指令做重排序。假设线程 A 在执行时被重排序成先执行代码 2，再执行代码 1；而线程 B 在线程 A 执行完代码 2 后，读取了 flag 变量。由于条件判断为真，线程 B 将读取变量 a。此时，变量 a 还根本没有被线程 A 写入，那么 i 最后的值是 0，导致执行结果不正确。那么如何程序执行结果正确呢？这里仍然可以使用 volatile 关键字。<br>这个例子中， 使用 volatile 不仅保证了变量的内存可见性，还禁止了指令的重排序，即保证了 volatile 修饰的变量编译后的顺序与程序的执行顺序一样。那么使用 volatile 修饰 flag 变量后，在线程 A 中，保证了代码 1 的执行顺序一定在代码 2 之前。<br>那么，让我们继续往下探索， volatile 是如何禁止指令重排序的呢？这里我们将引出一个概念：内存屏障指令<br>内存屏障指令<br>为了实现 volatile 内存语义（即内存可见性），JMM 会限制特定类型的编译器和处理器重排序。为此，JMM 针对编译器制定了 volatile 重排序规则表，如下所示：<br><img src="https://pic2.zhimg.com/v2-5004d1364ef68f4d71a730f719570dcd_b.jpg" referrerpolicy="no-referrer"><br>volatile 重排序规则<br>使用 volatile 修饰变量时，根据 volatile 重排序规则表，Java 编译器在生成字节码时，会在指令序列中插入内存屏障指令来禁止特定类型的处理器重排序。<br>内存屏障是一组处理器指令，它的作用是禁止指令重排序和解决内存可见性的问题。<br>JMM 把内存屏障指令分为下列四类：<br><img src="https://pic4.zhimg.com/v2-a992d2e50fc353edb9027683bf62ee2b_b.jpg" referrerpolicy="no-referrer"><br>内存屏障<br>
StoreLoad 屏障是一个全能型的屏障，它同时具有其他三个屏障的效果。所以执行该屏障开销会很大，因为它使处理器要把缓存中的数据全部刷新到内存中。  
<br>下面我们来看看 volatile 读 / 写时是如何插入内存屏障的，见下图：<br><img src="https://pic3.zhimg.com/v2-fdead3feef1123c1c225826559def686_b.jpg" referrerpolicy="no-referrer"><br>从上图，我们可以知道 volatile 读 / 写插入内存屏障规则：<br>
<br>在每个 volatile 读操作的后面插入 LoadLoad 屏障和 LoadStore 屏障。
<br>在每个 volatile 写操作的前后分别插入一个 StoreStore 屏障和一个 StoreLoad 屏障。
<br>也就是说，编译器不会对 volatile 读与 volatile 读后面的任意内存操作重排序；编译器不会对 volatile 写与 volatile 写前面的任意内存操作重排序。<br><br>上面我们讲述了重排序原则，为了提高处理速度， JVM 会对代码进行编译优化，也就是指令重排序优化，但是并发编程下指令重排序也会带来一些安全隐患：如指令重排序导致的多个线程操作之间的不可见性。为了理解 JMM 提供的内存可见性保证，让程序员再去学习复杂的重排序规则以及这些规则的具体实现，那么程序员的负担就太重了，严重影响了并发编程的效率。<br>所以从 JDK5 开始，提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。<br>happens-before 规则如下：<br>
<br>程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。  
<br>监视器锁规则：对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁。  
<br>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。  
<br>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。  
<br>start() 规则：Thread.start() 的调用会 happens-before 于启动线程里面的动作。  
<br>join() 规则：Thread 中的所有动作都 happens-before 于其他线程从 Thread.join() 中成功返回。
<br>这里特别说明一下，happens-before 规则不是描述实际操作的先后顺序，它是用来描述可见性的一种规则。<br>从 happens-before 的 volatile 变量规则可知，如果线程 A 写入了 volatile 修饰的变量 V，接着线程 B 读取了变量 V，那么，线程 A 写入变量 V 及之前的写操作都对线程 B 可见。<br><br>单例模式有 8 种，而懒汉式单例双重检测模式中就使用到了 volatile 关键字。<br>代码如下：<br>public class Singleton {
    // volatile 保证可见性和禁止指令重排序
    private static volatile Singleton singleton;

    public static Singleton getInstance() {
        // 第一次检查
        if (singleton == null) {
          // 同步代码块
          synchronized(this.getClass()) {
              // 第二次检查
              if (singleton == null) {
                    // 对象的实例化是一个非原子性操作
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
<br>上面代码中， new Singleton() 是一个非原子性操作，对象实例化分为三步操作：（1）分配内存空间，（2）初始化实例，（3）返回内存地址给引用。所以，在使用构造器创建对象时，编译器可能会进行指令重排序。假设线程 A 在执行创建对象时，（2）和（3）进行了重排序，如果线程 B 在线程 A 执行（3）时拿到了引用地址，并在第一个检查中判断 singleton != null 了，但此时线程 B 拿到的不是一个完整的对象，在使用对象进行操作时就会出现问题。<br>所以，这里使用 volatile 修饰 singleton 变量，就是为了禁止在实例化对象时进行指令重排序。<br><br>
<br>volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值；或者作为状态变量，如 flag = ture，实现轻量级同步。  
<br>volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为它没有提供原子性和互斥性。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。  
<br>volatile 只能作用于属性，我们用 volatile 修饰属性，这样编译器就不会对这个属性做指令重排序。  
<br>volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。  
<br>volatile 提供了 happens-before 保证，对 volatile 变量 V 的写入 happens-before 所有其他线程后续对 V 的读操作。  
<br>volatile 可以使纯赋值操作是原子的，如 boolean flag = true; falg = false。  
<br>volatile 可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性。  
<br><br>happen-before 俗解：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=http%3A//ifeve.com/easy-happens-before/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=http%3A//ifeve.com/easy-happens-before/" target="_blank">http://ifeve.com/easy-happens-before/</a><br>JMM Cookbook(一)指令重排：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=http%3A//ifeve.com/jmm-cookbook-reorderings/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=http%3A//ifeve.com/jmm-cookbook-reorderings/" target="_blank">http://ifeve.com/jmm-cookbook-reorderings/</a><br>JMM Cookbook(二)内存屏障：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=http%3A//ifeve.com/jmm-cookbook-mb/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=http%3A//ifeve.com/jmm-cookbook-mb/" target="_blank">http://ifeve.com/jmm-cookbook-mb/</a><br>深入理解 Java 内存模型（二）——重排序：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/java-memory-model-2/" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/java-memory-model-2/" target="_blank">https://www.infoq.cn/article/java-memory-model-2/</a><br>深入理解 Java 内存模型（四）——volatile：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/java-memory-model-4" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/java-memory-model-4" target="_blank">https://www.infoq.cn/article/java-memory-model-4</a><br>窥探真相：volatile 可见性实现原理：<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000020909627" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000020909627" target="_blank">https://segmentfault.com/a/1190000020909627</a><br>因为是个人学习笔记，难免存在一些错误或纰漏，也请小伙伴们指正。
]]></description><link>02-编程语言\01-java\02-多线程\05-多线程jvm实现(volatile,synchronized).html</link><guid isPermaLink="false">02-编程语言/01-JAVA/02-多线程/05-多线程jvm实现(volatile,synchronized).md</guid><pubDate>Wed, 08 May 2024 09:07:59 GMT</pubDate><enclosure url="02-编程语言\01-java\02-多线程\assets\jmm抽象示意图.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\02-多线程\assets\jmm抽象示意图.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[06-synchronized]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://github.com/h2pl/Java-Tutorial#%E5%B9%B6%E5%8F%91" target="_blank">https://github.com/h2pl/Java-Tutorial#%E5%B9%B6%E5%8F%91</a><br><br>之前谈到过，每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。<br><br>Lock是显式加锁，锁释放。而synchronized是隐式锁<br>
Lock只有代码块锁，synchronized有代码块锁和方法锁<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/dl962454/article/details/112909140" target="_blank">https://blog.csdn.net/dl962454/article/details/112909140</a>]]></description><link>02-编程语言\01-java\02-多线程\06-synchronized.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/02-多线程/06-synchronized.md</guid><pubDate>Wed, 10 Apr 2024 07:02:09 GMT</pubDate></item><item><title><![CDATA[07-线程-集合]]></title><description><![CDATA[ 
 <br><br>Collections.synchronized()<br>
<a rel="noopener nofollow" class="external-link" href="https://www.jianshu.com/p/9cca82a65b41" target="_blank">https://www.jianshu.com/p/9cca82a65b41</a><br>
我们清楚的看到 mutex = this; 这个锁就是对象自己!<br>
通过上面的源码我们可以知道了,synchronizedList实现线程安全的方法就是对自己暴力加锁，这效率能不低下吗？<br><br>官方文档就是如此使用synchronizedList的：<br>List list = Collections.synchronizedList(new ArrayList());
      ...
  synchronized (list) {
      Iterator i = list.iterator(); // Must be in synchronized block
      while (i.hasNext())
          foo(i.next());
  }
<br>问题来了:既然封装类内部已经加了对象锁，为什么外部还要加一层对象锁？]]></description><link>02-编程语言\01-java\02-多线程\07-线程-集合.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/02-多线程/07-线程-集合.md</guid><pubDate>Wed, 10 Apr 2024 07:02:11 GMT</pubDate></item><item><title><![CDATA[00-spring]]></title><description><![CDATA[ 
 <br>　　IOC-Inversion of Control，即控制反转。它不是什么技术，而是一种设计思想。<br>　　 &nbsp; &nbsp;传统的创建对象的方法是直接通过 new 关键字，而 spring 则是通过 IOC 容器来创建对象，也就是说我们将创建对象的控制权交给了 IOC 容器。我们可以用一句话来概括 IOC：<br>IOC 让程序员不在关注怎么去创建对象，而是关注与对象创建之后的操作，把对象的创建、初始化、销毁等工作交给spring容器来做<br>
public class HelloWorldPo {

  private String name;

  public String getName() {

    return name;

  }

  public void setName(String name) {

    this.name = name;

  }

    //静态工厂方法

    public static HelloWorldPo getInstances(){

        return new HelloWorldPo();

    }

  @Override

  public String toString() {

    return "HelloWorldPo [name=" + name + "]";

  }

}

<br>传统的创建对象的方式<br>
  @Test

  public void testHello(){

    //通过new创建实例对象

    HelloWorldPo helloWorldPo=new HelloWorldPo();

    helloWorldPo.setName("张三");

    System.out.println(helloWorldPo.toString());

  }

  //通过反射创建实例对象

  @Test

  public void testInvoke() throws Exception{

    Class class1 = Class.forName("com.oaec.po.HelloWorldPo");

    //获取属性对象

    Field field = class1.getDeclaredField("name");

    //获取方法对象

    Method method = class1.getMethod("setName", String.class);

    //通过反射创建实例对象

    HelloWorldPo helloWorldPo=(HelloWorldPo) class1.newInstance();

    //通过反射调用方法

    method.invoke(helloWorldPo, "王五");

    System.out.println(helloWorldPo.toString());

  }

<br>使用spring容器创建对象<br>1.使用默认的构造函数<br>首先，在项目的src根路径创建applicationContext.xml<br>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"

    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"

    xsi:schemaLocation="http://www.springframework.org/schema/beans

        http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

      &lt;!-- id:bean的名称，在IOC容器中必须唯一，推荐指定名称，不要省略，

    如果省略的话，会使用类名作为id

    class:全类名，在IOC容器中通过反射创建实例，所以要求必须有class属性，

        在继承的继承的情况下可以省略，

            property:属性注入

     --&gt;

    &lt;!-- 默认情况下，启动 spring 容器便创建对象（遇到bean便创建对象）

    　   在spring的配置文件bean中有一个属性 lazy-init="default/true/false"

 　　　　如果lazy-init为"default/false"在启动spring容器时创建对象（默认情况）

　　　　 如果lazy-init为"true",在context.getBean时才要创建对象

 　　 在第一种情况下可以在启动spring容器的时候，检查spring容器配置文件的正确性，

    如果再结合tomcat,如果spring容器不能正常启动，整个tomcat就不能正常启动。

    但是这样的缺点是把一些bean过早的放在了内存中，如果有数据，则对内存来是一个消耗。

　　    反过来，在第二种情况下，可以减少内存的消耗，但是不容易发现错误--&gt;

    &lt;!-- Spring框架支持以下五种bean的作用域：

    singleton : bean在每个Spring ioc 容器中只有一个实例。

    prototype：一个bean的定义可以有多个实例。

    request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。

    session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。

    global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。

    缺省的Spring bean 的作用域是Singleton。 --&gt;

  &lt;!-- 默认构造函数 --&gt;

  &lt;bean id="helloWorldByDefaultConstructor" class="com.po.HelloWorldPo"&gt;

    &lt;property name="name" value="构造"&gt;&lt;/property&gt;

  &lt;/bean&gt;

  &lt;!-- 静态工厂 --&gt;

  &lt;bean id="helloWorldByStaticFactory" factory-method="getInstances" class="com.po.HelloWorldPo"&gt;

  &lt;property name="name" value="静态"&gt;&lt;/property&gt;

  &lt;/bean&gt;

  &lt;!-- 实例工厂 --&gt;

  &lt;bean id="instanceFactory" class="com.po.HelloWorldInstanceFactory"&gt;&lt;/bean&gt;

  &lt;bean id="helloWorldByInstanceFactory" factory-bean="instanceFactory" class="com.po.HelloWorldPo"&gt;

  &lt;property name="name" value="实例"&gt;&lt;/property&gt;

  &lt;/bean&gt;

&lt;/beans&gt;

<br>测试方法<br>
  //构造方法

  @Test

  public void testConstructor(){

    //spring是个容器，负责管理对象的生命周期

//    需要实例化IOC容器，容器产生哪些实例，是根据配置文件来产生的

//    容器实例化之后，才可以从IOC容器获取Bean的实例并使用

//    如何实例化IOC容器

//    1.BeanFacotry .IOC容器的基本实现，面向的是Spring本身

//    2.ApplicationContxt.是BeanFactory的子接口，ApplicationContext是面向

//    spring框架的使用者，所有的应用基本上都是满足

//    ApplicationContext实现类：

//      1.ClassPathXmlApplicationContext 从类路径下加载配置文件（src）

//        2.FileSystemXmlApplicationContext 从系统文件中加载配置文件（F://cxx/xxx/xxx.xml）

//    ConfigurableApplicationContext 扩展ApllicationContext.

//    功能：启动，刷新，关闭上下文的功能

//      ApplicationContext 特点：在初始化上下文时就已经实例化好所有的的实例（单例）

//             针对web项目，上下文使用 WebApplicationContext  

    AbstractApplicationContext applicationContext

    = new ClassPathXmlApplicationContext("applicationContext.xml");

    //在容器中获取 class类型为HelloWorldPo 的bean

    //容器中只有一个class类型相同的bean 才可以使用 getBean(Class);

    HelloWorldPo helloWorldPo=(HelloWorldPo) applicationContext.getBean("helloWorldByDefaultConstructor");

    System.out.println(helloWorldPo.toString());

  }

<br>2.静态工厂方法 &nbsp; &nbsp;<br>
  //静态工厂

  @Test

  public void testStaticFactory(){

    //spring是个容器，负责管理对象的生命周期

    AbstractApplicationContext applicationContext

    = new ClassPathXmlApplicationContext("applicationContext.xml");

    HelloWorldPo helloWorldPo=(HelloWorldPo) applicationContext.getBean("helloWorldByStaticFactory");

    System.out.println(helloWorldPo.toString());

  }

<br>3.实例工厂<br>创建实例工厂类<br>
public class HelloWorldInstanceFactory {

  public HelloWorldPo getInstance() {

    HelloWorldPo helloWorldPo = new HelloWorldPo();

    return helloWorldPo;

  }

}

<br>
  //实例工厂

  @Test

  public void testInstanceFactory(){

    //spring是个容器，负责管理对象的生命周期

    AbstractApplicationContext applicationContext

    = new ClassPathXmlApplicationContext("applicationContext.xml");

    HelloWorldPo helloWorldPo=(HelloWorldPo) applicationContext.getBean("helloWorldByInstanceFactory");

    System.out.println(helloWorldPo.toString());

  }

<br>bean的继承<br>
&lt;!-- 子 Bean 从父 Bean 中继承配置, 包括 Bean 的属性配置

子 Bean 也可以覆盖从父 Bean 继承过来的配置

父 Bean 可以作为配置模板, 也可以作为 Bean 实例.

若只想把父 Bean 作为模板, 可以设置 &lt;bean&gt; 的abstract 属性为 true, 这样 Spring 将不会实例化这个 Bean

并不是 &lt;bean&gt; 元素里的所有属性都会被继承. 比如: autowire, abstract 等.

也可以忽略父 Bean 的 class 属性, 让子 Bean 指定自己的类,

而共享相同的属性配置. 但此时 abstract 必须设为 true

 --&gt;

&lt;!-- 父bean --&gt;

 &lt;bean id="father"

 p:name="父亲" p:car-ref="car"

 abstract="true"

  &gt;&lt;/bean&gt;

  &lt;bean id="son1" class="com.oaec.po.Person"

  parent="father"

  p:name="大儿子"

  scope="prototype"

  &gt;&lt;/bean&gt;

<br>加载配置文件<br>创建jdbc.properties<br>
jdbc.driverClass=com.mysql.jdbc.Driver

jdbc.url=jdbc:mysql://localhost:3306/mybatis2?characterEncoding=utf-8

jdbc.user=root

jdbc.password=123456

<br>
  &lt;!-- 加载配置文件 --&gt;

  &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;

  &lt;bean id="jdbcTool" class="com.oaec.po.JDBCtool"

  p:driver="${jdbc.driverClass}"

   p:url="${jdbc.url}"

   p:username="${jdbc.user}"

   p:password="${jdbc.password}"

  &gt;&lt;/bean&gt;

<br>前置后置的配置<br>
/**

 * 1.构造方法、工厂方法初始化bean

 * 2.属性赋值

 * 3.后置处理器的before方法

 * 4.bean的初始化方法

 * 5.后置处理器的after方法

 * 6.bean可以使用

 * 7.容器关闭，销毁bean

 *

 */

public class MyProcessor implements BeanPostProcessor{

  //在初始化之前调用    

  /**

   * obj:当前执行生命周期的对象

   * id：当前执行声明周期的对象的id

   */

  @Override

  public Object postProcessBeforeInitialization(Object obj, String id)

      throws BeansException {

    System.out.println("后置处理器before.obj="+obj+",id="+id);

    return obj;

  }

  //在初始化方法之后调用

    @Override

    public Object postProcessAfterInitialization(Object obj, String id)

        throws BeansException {

      System.out.println("后置处理器after.obj="+obj+",id="+id);

      return obj;

    }

}

<br>
  &lt;!-- 初始化后置处理器 --&gt;

  &lt;bean class="com.oaec.po.MyProcessor"&gt;&lt;/bean&gt;

  &lt;!-- 指定此bean的初始化方法和销毁方法

  1、构造方法或者工厂创建car实例

  2、对属性赋值或者关联其他对象

  3、调用初始化方法

  4、此bean可以使用

  5、当容器关闭时，调用bean的销毁方法

   --&gt;

  &lt;bean id="car" class="com.oaec.po.Car"

  p:name="dazhong" p:price="300" p:color="red"

  &gt;&lt;/bean&gt;

<br>
  @Test

  public void testLife() {

      ConfigurableApplicationContext ac=

          new ClassPathXmlApplicationContext("bean-life.xml");

      Car car=(Car) ac.getBean("car");

      System.out.println(car.toString());

      ac.close();

  }

/*  运行结果

  car 构造方法

  car ...setName...

  后置处理器before.obj=Car [name=dazhong, color=red, price=300],id=car

  后置处理器after.obj=Car [name=dazhong, color=red, price=300],id=car

  Car [name=dazhong, color=red, price=300]*/

<br>配置注解的方式实现IOC<br>
  &lt;context:component-scan base-package="com.oaec.scan" use-default-filters="true"&gt;

    &lt;context:include-filter type="assignable" expression="com.dao.UserDao"/&gt;

      &lt;context:exclude-filter type="annotation"

       expression="org.springframework.stereotype.Controller"/&gt;

  &lt;/context:component-scan&gt;

&lt;!--  base-package:设置要扫描的包名

    扫描包下所有的java文件，

    use-default-filters 为true的话会扫描@Component的所有子类注解

    自定义注解扫描细节的话 设置成false

  context:include-filter:要包含哪些注解/类

  context:exclude-filter:不包含哪些注解/类

  type：扫描的类型

      1、annotation 是否标注了特定的注解

      2、assignable 目标类是否继承或者实现了某个特定的类 --&gt;

<br>在配置文件中导入其他配置文件<br>
&lt;!-- 导入其他配置文件 --&gt;

  &lt;import resource="classpath:bean-ref.xml"/&gt;

]]></description><link>02-编程语言\01-java\03-spring\00-spring.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/00-spring.md</guid><pubDate>Wed, 10 Apr 2024 07:02:26 GMT</pubDate></item><item><title><![CDATA[00-spring核心思想]]></title><description><![CDATA[ 
 <br>Spring IOC容器是Spring框架的核心，它的源码解析可以让我们深入了解Spring框架的设计思想和实现原理。下面是Spring IOC的源码解析：<br>
<br>BeanFactory接口：BeanFactory是Spring IOC容器的核心接口，它定义了容器的基本功能和操作方法。其中，getBean方法是最重要的方法之一，它用于获取容器中的Bean实例对象。
<br>ApplicationContext接口：ApplicationContext是BeanFactory的子接口，它是Spring应用上下文的核心接口。除了BeanFactory的基本功能外，ApplicationContext还提供了更多的企业级功能，例如国际化支持、事件传递等。
<br>AbstractApplicationContext抽象类：AbstractApplicationContext是ApplicationContext接口的实现类，它提供了通用的ApplicationContext实现。它通过XmlBeanDefinitionReader类来读取XML配置文件中的Bean定义，并将其转换为BeanDefinition对象。然后，将BeanDefinition对象注册到BeanFactory中，并通过BeanFactory来创建Bean实例。
<br>XmlBeanDefinitionReader类：XmlBeanDefinitionReader是AbstractApplicationContext的内部类，它用于读取XML配置文件中的Bean定义。XmlBeanDefinitionReader继承了DefaultBeanDefinitionDocumentReader类，它通过解析XML文件中的&lt;bean&gt;标签和其他相关标签来创建BeanDefinition对象。
<br>BeanDefinition接口：BeanDefinition是Spring IOC容器中的一个核心概念，它定义了Bean的基本属性和依赖关系。每个Bean在容器中都对应一个唯一的BeanDefinition对象，它包含了Bean的名称、类名、构造方法参数、属性值等信息。
<br>DefaultListableBeanFactory类：DefaultListableBeanFactory是BeanFactory接口的默认实现类，它是Spring IOC容器的核心实现类。它继承了AbstractAutowireCapableBeanFactory类，可以自动装配Bean的依赖关系，并提供了Bean的注册、获取和管理等基本功能。
<br>AutowireCapableBeanFactory接口：AutowireCapableBeanFactory是BeanFactory的子接口，它定义了Bean的自动装配功能。当容器创建Bean的实例对象时，AutowireCapableBeanFactory会根据Bean的属性值和类型，自动注入所依赖的其他Bean。
<br>总之，Spring IOC的源码解析主要涉及到BeanFactory、ApplicationContext、AbstractApplicationContext、XmlBeanDefinitionReader、BeanDefinition、DefaultListableBeanFactory和AutowireCapableBeanFactory等核心接口和类。通过对这些类的源码分析，我们可以更好地理解Spring框架的设计思想和实现原理。]]></description><link>02-编程语言\01-java\03-spring\00-spring核心思想.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/00-spring核心思想.md</guid><pubDate>Wed, 10 Apr 2024 07:02:28 GMT</pubDate></item><item><title><![CDATA[01-bean的生命周期]]></title><description><![CDATA[ 
 <br><br>Bean 的生命周期概括起来就是&nbsp;4 个阶段：<br>
<br>实例化（Instantiation）
<br>属性赋值（Populate）
<br>初始化（Initialization）
<br>销毁（Destruction）
<br><br><img src="02-编程语言\01-java\03-spring\assets\bean的生命周期.png"><br>
<br>实例化：第 1 步，利用反射实例化一个 bean 对象，分配内存空间；
<br>属性赋值：第 2 步，为 bean 设置相关属性和依赖；
<br>初始化：第 3~7 步，步骤较多，其中第 5、6 步为初始化操作，第 3、4 步为在初始化前执行，第 7 步在初始化后执行，该阶段结束，才能被用户使用；
<br>销毁：第 8~10步，第8步不是真正意义上的销毁（还没使用呢），而是先在使用前注册了销毁的相关调用接口，为了后面第9、10步真正销毁 bean 时再执行相应的方法。
<br>1.实例化：为 Bean 分配内存空间；<br>
2.设置属性：将当前类依赖的 Bean 属性，进行注入和装配；<br>
3.初始化：<br>
<br>执行各种通知。
<br>执行初始化的前置方法。
<br>执行初始化方法。
<br>执行初始化的后置方法。
<br>4.使用 Bean：在程序中使用 Bean 对象；5.销毁 Bean：将 Bean 对象进行销毁操作。<br><br><br>若 Spring 检测到 bean 实现了 Aware 接口，则会为其注入相应的依赖。所以通过让bean 实现 Aware 接口，则能在 bean 中获得相应的 Spring 容器资源。<br>Spring 中提供的 Aware 接口有：<br>
<br>BeanNameAware：注入当前 bean 对应 beanName；
<br>BeanClassLoaderAware：注入加载当前 bean 的 ClassLoader；
<br>BeanFactoryAware：注入 当前BeanFactory容器 的引用。
<br>其代码实现如下：<br>// AbstractAutowireCapableBeanFactory.java
private void invokeAwareMethods(final String beanName, final Object bean) {
    if (bean instanceof Aware) {
        if (bean instanceof BeanNameAware) {
            ((BeanNameAware) bean).setBeanName(beanName);
        }
        if (bean instanceof BeanClassLoaderAware) {
            ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);
            
        }
        if (bean instanceof BeanFactoryAware) {
            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
        }
    }
}
复制代码
<br>以上是针对 BeanFactory 类型的容器，而对于 ApplicationContext 类型的容器，也提供了 Aware 接口，只不过这些 Aware 接口的注入实现，是通过 BeanPostProcessor 的方式注入的，但其作用仍是注入依赖。<br>
<br>EnvironmentAware：注入 Enviroment，一般用于获取配置属性；
<br>EmbeddedValueResolverAware：注入 EmbeddedValueResolver（Spring EL解析器），一般用于参数解析；
<br>ApplicationContextAware（ResourceLoader、ApplicationEventPublisherAware、MessageSourceAware）：注入 ApplicationContext 容器本身。
<br>其代码实现如下：<br>// ApplicationContextAwareProcessor.java
private void invokeAwareInterfaces(Object bean) {
    if (bean instanceof EnvironmentAware) {
        ((EnvironmentAware)bean).setEnvironment(this.applicationContext.getEnvironment());
    }

    if (bean instanceof EmbeddedValueResolverAware) {
        ((EmbeddedValueResolverAware)bean).setEmbeddedValueResolver(this.embeddedValueResolver);
    }

    if (bean instanceof ResourceLoaderAware) {
        ((ResourceLoaderAware)bean).setResourceLoader(this.applicationContext);
    }

    if (bean instanceof ApplicationEventPublisherAware) {
        ((ApplicationEventPublisherAware)bean).setApplicationEventPublisher(this.applicationContext);
    }

    if (bean instanceof MessageSourceAware) {
        ((MessageSourceAware)bean).setMessageSource(this.applicationContext);
    }

    if (bean instanceof ApplicationContextAware) {
        ((ApplicationContextAware)bean).setApplicationContext(this.applicationContext);
    }

}
<br><br>BeanPostProcessor 是 Spring 为修改 bean提供的强大扩展点，其可作用于容器中所有 bean，其定义如下：<br>public interface BeanPostProcessor {

	// 初始化前置处理
	default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}

	// 初始化后置处理
	default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		return bean;
	}

}
复制代码
<br>常用场景有：<br>
<br>对于标记接口的实现类，进行自定义处理。例如3.1节中所说的ApplicationContextAwareProcessor，为其注入相应依赖；再举个例子，自定义对实现解密接口的类，将对其属性进行解密处理；
<br>为当前对象提供代理实现。例如 Spring AOP 功能，生成对象的代理类，然后返回。
<br>// AbstractAutoProxyCreator.java
public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {
    TargetSource targetSource = getCustomTargetSource(beanClass, beanName);
    if (targetSource != null) {
        if (StringUtils.hasLength(beanName)) {
            this.targetSourcedBeans.add(beanName);
        }
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);
        Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);
        this.proxyTypes.put(cacheKey, proxy.getClass());
        // 返回代理类
        return proxy;
    }

    return null;
}
复制代码
<br><br>InitializingBean 和 init-method 是 Spring 为 bean 初始化提供的扩展点。<br>InitializingBean接口 的定义如下：<br>public interface InitializingBean {
	void afterPropertiesSet() throws Exception;
}
复制代码
<br>在 afterPropertiesSet() 方法写初始化逻辑。<br>指定 init-method 方法，指定初始化方法：<br>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;bean id="demo" class="com.chaycao.Demo" init-method="init()"/&gt;
    
&lt;/beans&gt;
复制代码
<br>DisposableBean 和 destory-method 与上述类似，就不描述了。<br><a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/6844904065457979405#heading-1" target="_blank">https://juejin.cn/post/6844904065457979405#heading-1</a><br>
<a rel="noopener nofollow" class="external-link" href="https://www.51cto.com/article/717956.html" target="_blank">https://www.51cto.com/article/717956.html</a><br>
<a rel="noopener nofollow" class="external-link" href="https://www.jianshu.com/p/1dec08d290c1" target="_blank">https://www.jianshu.com/p/1dec08d290c1</a><br>
<a rel="noopener nofollow" class="external-link" href="https://segmentfault.com/a/1190000040365130" target="_blank">https://segmentfault.com/a/1190000040365130</a>]]></description><link>02-编程语言\01-java\03-spring\01-bean的生命周期.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/01-bean的生命周期.md</guid><pubDate>Wed, 08 May 2024 09:08:15 GMT</pubDate><enclosure url="02-编程语言\01-java\03-spring\assets\bean的生命周期.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\03-spring\assets\bean的生命周期.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02-DI]]></title><description><![CDATA[ 
 <br><br><br>类Person中有如下属性，getset方法略<br>    private Long pid;
    private String pname;
    private Student students;
    private List lists;
    private Set sets;
    private Map maps;
    private Properties properties;
<br>&lt;bean id="person" class="com.ys.di.Person"&gt;
    &lt;property name="pid" value="1"&gt;&lt;/property&gt;
    &lt;property name="pname" value="vae"&gt;&lt;/property&gt;
    &lt;property name="students"&gt;
        &lt;ref bean="student"/&gt;
    &lt;/property&gt;
     
    &lt;property name="lists"&gt;
        &lt;list&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;ref bean="student"/&gt;
            &lt;value&gt;vae&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
     
    &lt;property name="sets"&gt;
        &lt;set&gt;
            &lt;value&gt;1&lt;/value&gt;
            &lt;ref bean="student"/&gt;
            &lt;value&gt;vae&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
     
    &lt;property name="maps"&gt;
        &lt;map&gt;
            &lt;entry key="m1" value="1"&gt;&lt;/entry&gt;
            &lt;entry key="m2" &gt;
                &lt;ref bean="student"/&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;   
     
    &lt;property name="properties"&gt;
        &lt;props&gt;
            &lt;prop key="p1"&gt;p1&lt;/prop&gt;
            &lt;prop key="p2"&gt;p2&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;  
     
&lt;/bean&gt;
<br><br>    //带参构造函数
    public Person(Long pid,Student students){
        this.pid = pid;
        this.students = students;
    }
<br>
    &lt;!--
        index  代表参数的位置  从0开始计算
        type   指的是参数的类型,在有多个构造函数时，可以用type来区分，要是能确定是那个构造函数，可以不用写type
        value  给基本类型赋值
        ref    给引用类型赋值
      --&gt;
    &lt;bean id="person_con" class="com.ys.di.Person"&gt;
        &lt;constructor-arg index="0" type="java.lang.Long" value="1"&gt;
        &lt;/constructor-arg&gt;       
        &lt;constructor-arg index="1" type="com.ys.di.Student" ref="student_con"&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id="student_con" class="com.ys.di.Student"&gt;&lt;/bean&gt;
<br><br>略<br><br><a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/7024382744742494216" target="_blank">https://juejin.cn/post/7024382744742494216</a><br>
依赖注入的方式：<br>
基于field<br>
基于set方法<br>
基于构造器<br><br><a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1FD4y1N7dQ/?spm_id_from=333.999.0.0" target="_blank">https://www.bilibili.com/video/BV1FD4y1N7dQ/?spm_id_from=333.999.0.0</a><br>不建议直接在字段上进行依赖注入。Spring开发团队建议：在Java Bean中永远使用构造方法进行依赖注入。
<br>那么spring既然推荐构造器的方式，推荐使用构造器的方式主要是因为启动速度的的提升吧@AutoWired本质上是通过反射类进行属性注入，执行的时刻是对象创建完成之后，如果用构造器的方式的话，那么对象创建的同时就完成了属性的注入<br>所以说spring其实也不推荐@Resource  因为用了这些注解的话，循环依赖的问题就会被掩盖，而spring认为代码组织结构里不应该有循环依赖，应当是层级分明的，只是@Resource是jdk提供的注解，所以没有办法改而已<br>所以我们可以使用@Resource替代@Autowired，当然也可以使用@RequiredArgsConstructor构造器方式注入，这种形式就是Spring推荐使用的构造器方式注入，此种方式是lombok包下的注解，如果使用此种方式，需要项目中引入lombok<br>spring推荐的用法是<br>@RequiredArgsConstructor 
public class UserDaoImpl { 
	private final User user; 
}
]]></description><link>02-编程语言\01-java\03-spring\02-di.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/02-DI.md</guid><pubDate>Wed, 10 Apr 2024 07:02:32 GMT</pubDate></item><item><title><![CDATA[03-IOC]]></title><description><![CDATA[ 
 <br>IOC 让程序员不在关注怎么去创建对象，而是关注与对象创建之后的操作，把对象的创建、初始化、销毁等工作交给spring容器来做<br><br><br>
    &lt;!--

    创建对象的第一种方式：利用无参构造器

    id:唯一标识符

    class:类的全类名

      --&gt;

&lt;bean id="helloIoc" class="com.ys.ioc.HelloIoc" &gt;&lt;/bean&gt;  

<br><br>
public class HelloStaticFactory {

    public HelloStaticFactory(){

        System.out.println("HelloStaticFactory constructor");

    }

    //静态工厂方法

    public static HelloIoc getInstances(){

        return new HelloIoc();

    }

}

<br>
&lt;bean id="helloStaticFactory" factory-method="getInstances" class="com.ys.ioc.HelloStaticFactory"&gt;&lt;/bean&gt;

<br>注意：spring容器只负责调用静态工厂方法，而这个静态工厂方法内部实现由程序员完成<br><br>
public class HelloInstanceFactory {

    public HelloInstanceFactory(){

        System.out.println("实例工厂方法构造函数");

    }

    //利用实例工厂方法创建对象

    public HelloIoc getInstance(){

        HelloIoc instanceIoc = new HelloIoc();

        return instanceIoc;

    }

}

<br>
    &lt;bean id="instanceFactory" class="com.ys.ioc.HelloInstanceFactory"&gt;&lt;/bean&gt;

    &lt;bean id="instance" factory-bean="instanceFactory" factory-method="getInstance"&gt;&lt;/bean&gt;

<br><br>默认初始化容器时创建<br>bean 的lazy-init属性为true,使用时创建，context.getBean()时<br><br>Spring框架支持以下五种bean的作用域：<br>singleton : bean在每个Spring ioc 容器中只有一个实例。<br>prototype：一个bean的定义可以有多个实例。<br>request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。<br>缺省的Spring bean 的作用域是Singleton。<br><br>
&lt;bean id="springLifeCycle" init-method="init" destroy-method="destroy" class="com.ys.ioc.SpringLifeCycle"&gt;&lt;/bean&gt;

<br>指定初始化，销毁方法<br>　分析：spring 容器的声明周期<br>　　 　 &nbsp; 1、spring容器创建对象<br>&nbsp; &nbsp; &nbsp; &nbsp; 　　2、执行init方法<br>&nbsp; &nbsp; &nbsp; &nbsp; 　　3、调用自己的方法<br>&nbsp; &nbsp; &nbsp; &nbsp; 　　4、当spring容器关闭的时候执行destroy方法<br>　　注意：当scope为"prototype"时，调用 close（） 方法时是不会调用 destroy 方法的<br><br><a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1N8411J7zK?p=42&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" target="_blank">https://www.bilibili.com/video/BV1N8411J7zK?p=42&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf</a><br>控制反转：理论思想，原来的对象是由使用者来进行控制，有了spring之后，可以把整个对象交给spring来帮我们进行管理<br>
Dl：依赖注入，把对应的属性的值注入到具体的对象中，@Autowired, populateBean完成属性值的注入<br>
容器：存储对象，使用map结构来存储，在spring中一般存在三级缓存，singletonObjects存放完整的bean对象， 整个bean的生命周期，从创建到使用到销毁的过程全部都是由容器来管理（bean的生命周期）<br>
分：<br>
1、一般聊ioc容器的时候要涉及到容器的创建过程（beanFactory, DefaultListableBean Factory)，向bean工厂中设置一些参数 (BeanPostProcessor,Aware接口的子类）等等属性<br>
2、加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition, ( x m I或者注解的解析过程）<br>
3、beanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigurSu pport,ConfigurationClassPostProcessor<br>
4、BeanPostProcessor’的注册功能，方便后续对bean对象完成具体的扩展功能<br>
5、通过反射的方式讲BeanDefinition：对象实例化成具体的bean对象，<br>
6、 bean对象的初始化过程（项充属性，调用aware子类的方法，调用Bean Post Processor前置处理方法，调用init-method方法，调用 BeanPostProcessor的后置处理方法）<br>
7.生成完整的bean对象<br>
8.销毁过程<br>面试官，这是我对IOC的整体理解，包含了一些详细的处理过程，您看一下有什么问题，可以指点我一下（允许你把整个流程说完）<br>
老师，我没看过源码怎么办？<br>
具体的细节我记不太清了，但是spring中的bean都是通过反射的方式生成的，同时其中包含了很多的扩展点，比如最常用的对 Bean Factory的扩展，对bean的扩展（对占位符的处理），我们在公司对这方面的使用是比较多的，除此之外IOC中最核心的也就是填<br>
充具体bean的属性，和生命周期（背一下）。 <br>引申问题点：<br><br><a class="internal-link" data-href="01-bean的生命周期#生命周期一览图" href="02-编程语言\01-java\03-spring\01-bean的生命周期.html#生命周期一览图" target="_self" rel="noopener nofollow">01-bean的生命周期 &gt; 生命周期一览图</a><br>
<br>实例化bean,反射的方式生成对象，分配内存空间
<br>填充bean的属性：populateBean,循环依赖的问题（三级缓存)
<br>调用aware接口相关的方法：invokeAwareMethod（完成BeanName,BeanFactory,BeanClassLoader对象的属性设置）
<br>调用BeanPostProcessor中的前置处理方法：使用比较多的有（ApplicationContextPostProcessor，设置 ApplicationContext,Environment,ResourceLoader, EmbeddValueResolver等对象）
<br>调用initmethod方法：invokeInitmethod()，判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，没有就不调用
<br>调用Bean PostProcessor的后置处理方法：spring的aop就是在此处实现的，AbstractAutoProxyCreator注册Destuction相关的回调接口：钩子函数
<br>获取到完整的对象，可以通过getBean的方式来进行对象的获取
<br>销毁流程， 判断是否实现了DispoableBean接口，2，调用destroyMethod方法
<br><br>容器：存储对象，使用map结构来存储<br><br><img src="02-编程语言\01-java\03-spring\assets\循环依赖-ab.png"><br>关键点：三级缓存，提前暴露对象，aop<br>
总：<br>
什么是循环依赖问题，A依赖B,B依赖A 先说明bean的创建过程：实例化，初始化（填充属性）<br>
分 ：<br>
<br>先创建A对象，实例化A对象，此时A对象中的b属性为空，填充属性b
<br>从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题（不通），找不到直接创建B对象
<br>实例化B对象，此时B寸象中的a属性为空，填充属性a
<br>从容器中查找A对象，找不到，直接创建
<br>此时，如果仔细琢磨的话，会发现A对象是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化， 如果在程序调用过程中，拥有了某个对象的引用，能否在后期给他完成赋值操作，可以优先把非完整状态的对象优先赋值，等待后续操作 来完成赋值，相当于提前暴露了某个不完整对象的引用，所以解决问题的核心在于实例化和初始化分开操作，这也是解决循环依赖问题的 关键。<br>当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在两种状态的对象，完成实例化但未完成初始化和完整状态<br>
因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存有了，那么二级缓存中就不会存在同名的对象，因为他们的查找顺序是1,2, 3这样的方式来查找的。一级缓存中放的是完整对象，二级缓 存中放的是非完整对象<br>为什么需要三级缓存？三级缓存的value类型是ObjectFactory，是一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个。<br>如果一个对象需要被代理，或者说需要生成代理对象，那么要不要优先生成一个普通对象？要<br>
普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在 实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似 于一种回调机制的实现，因此传入Iambda表达式的时候，可以通过Iambda表达式来执行对象的慈盖过程，getEarlyBeanReference() 因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需 要被代理，则直接返回普通对象]]></description><link>02-编程语言\01-java\03-spring\03-ioc.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/03-IOC.md</guid><pubDate>Wed, 08 May 2024 09:08:12 GMT</pubDate><enclosure url="02-编程语言\01-java\03-spring\assets\循环依赖-ab.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\03-spring\assets\循环依赖-ab.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[04-AOP]]></title><description><![CDATA[ 
 <br>所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。<br>现在有一张表 User,然后我们要在程序中实现对 User 表的增加和删除操作。<br>　　要求：增加和删除操作都必须要记录日志。<br><br><br>public interface UserService {
    //添加 user
    public void addUser(User user);
    //删除 user
    public void deleteUser(int uid);
}
<br><br>public class UserServiceImpl implements UserService{
    @Override
    public void addUser(User user) {
        System.out.println("增加 User");
    }
    @Override
    public void deleteUser(int uid) {
        System.out.println("删除 User");
    }
}
<br><br>public class MyLog {
    //开启事务
    public void before(){
        System.out.println("开启");
    }
    //提交事务
    public void after(){
        System.out.println("结束");
    }
}
<br><br>import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
 
import com.ys.aop.one.MyTransaction;
 
public class ObjectInterceptor implements InvocationHandler{
    //目标类
    private Object target;
    //切面类（这里指日志类）
    private MyLog myLog;
     
    //通过构造器赋值
    public ObjectInterceptor(Object target,MyLog myLog){
        this.target = target;
        this.transaction = transaction;
    }
     
    @Override
    public Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        //开启
        this.myLog.before();
        //调用目标类方法
        method.invoke(this.target, args);
        //结束
        this.myLog.after();
        return null;
    }
     
}
<br><br>　　1.target：目标类，需要被代理的类。例如：UserService<br>　　2.Joinpoint(连接点):所谓连接点是指那些可能被拦截到的方法。例如：所有的方法<br>　　3.PointCut 切入点：已经被增强的连接点。例如：addUser()<br>　　4.advice 通知/增强，增强代码。例如：after、before<br>　　5. Weaving(织入):是指把增强advice应用到目标对象target来创建新的代理对象proxy的过程.<br>　　6.proxy 代理类：通知+切入点<br>　　7. Aspect(切面): 是切入点pointcut和通知advice的结合<br><br>　Spring按照通知Advice在目标类方法的连接点位置，可以分为5类<br>前置通知 org.springframework.aop.MethodBeforeAdvice<br>
在目标方法执行前实施增强，比如上面例子的 before()方法<br>
后置通知 org.springframework.aop.AfterReturningAdvice<br>
在目标方法执行后实施增强，比如上面例子的 after()方法<br>
环绕通知 org.aopalliance.intercept.MethodInterceptor<br>
在目标方法执行前后实施增强<br>
异常抛出通知 org.springframework.aop.ThrowsAdvice<br>
在方法抛出异常后实施增强<br>
引介通知 org.springframework.aop.IntroductionInterceptor<br>
在目标类中添加一些新的方法和属性<br><br>    &lt;!--1、 创建目标类 --&gt;
    &lt;bean id="userService" class="com.ys.aop.UserServiceImpl"&gt;&lt;/bean&gt;  
    &lt;!--2、创建切面类（通知）  --&gt;
    &lt;bean id="transaction" class="com.ys.aop.one.MyTransaction"&gt;&lt;/bean&gt;
     
    &lt;!--3、aop编程 
        3.1 导入命名空间
        3.2 使用 &lt;aop:config&gt;进行配置
                proxy-target-class="true" 声明时使用cglib代理
                如果不声明，Spring 会自动选择cglib代理还是JDK动态代理
            &lt;aop:pointcut&gt; 切入点 ，从目标对象获得具体方法
            &lt;aop:advisor&gt; 特殊的切面，只有一个通知 和 一个切入点
                advice-ref 通知引用
                pointcut-ref 切入点引用
        3.3 切入点表达式
            execution(* com.ys.aop.*.*(..))
            选择方法         返回值任意   包             类名任意   方法名任意   参数任意
     
    --&gt;
    &lt;aop:config&gt;
        &lt;!-- 切入点表达式 --&gt;
        &lt;aop:pointcut expression="execution(* com.ys.aop.*.*(..))" id="myPointCut"/&gt;
        &lt;aop:aspect ref="transaction"&gt;
            &lt;!-- 配置前置通知，注意 method 的值要和 对应切面的类方法名称相同 --&gt;
            &lt;aop:before method="before" pointcut-ref="myPointCut"&gt;&lt;/aop:before&gt;
            &lt;aop:after-returning method="after" pointcut-ref="myPointCut"/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
<br><br>execution（modifiers-pattern? ref-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?）
　　　　　　　　　　   类修饰符           返回值           方法所在的包                  方法名                     方法抛出的异常
<br><br>　1、当 spring 容器启动的时候，加载了 spring 的配置文件<br>　　2、为配置文件中的所有 bean 创建对象<br>　　3、spring 容器会解析 aop:config 的配置<br>   　　　　1、解析切入点表达式，用切入点表达式和纳入 spring 容器中的 bean 做匹配<br>   　　　　如果匹配成功，则会为该 bean 创建代理对象，代理对象的方法=目标方法+通知

   　　　　如果匹配不成功，不会创建代理对象
<br>　　4、在客户端利用 context.getBean() 获取对象时，如果该对象有代理对象，则返回代理对象；如果没有，则返回目标对象<br>　　　　说明：如果目标类没有实现接口，则 spring 容器会采用 cglib 的方式产生代理对象，如果实现了接口，则会采用 jdk 的方式<br><br>	&lt;context:component-scan base-package="com"&gt;&lt;/context:component-scan&gt;
	&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
<br>@Component
@Aspect
public class LogAspect {
	
//	
//	合并切入点表达式 使用pointCut来声明切点 @Pointcut（切入点表达式）
//	必须声明在一个没有方法体的方法上面
//	使用  @Before(此方法名())
 	@Pointcut("execution (public int com.oaec.po.Calc.*(int,int))")
	private void logPointCut(){}
//	通知如何访问当前连接点的信息？
// 	JoinPoint 连接点。可以通过JoinPoint来访问当前连接细节，例如方法名。方法参数
	@Before("logPointCut()")
	public void beforeLog(JoinPoint joinPoint){
		String methodName=joinPoint.getSignature().getName();
		Object[] args = joinPoint.getArgs();
//		d当前被代理的类
		String className=joinPoint.getTarget().getClass().getName();
		System.out.println("前置日志:"+className
				+","+methodName+","+Arrays.toString(args));
		
	}
	//后置通知，连接点完成之后执行，连接点返回结果或者是抛出异常，都会执行后置通知
	
	@After("logPointCut()" )
	public void afterLog(JoinPoint joinPoint){
		String methodName=joinPoint.getSignature().getName();
		String className=joinPoint.getTarget().getClass().getName();
		System.out.println("后置通知:"+methodName+","+className);
	}
//	返回通知
//	如果想要在连接点返回结果的时候记录日志，需要使用返回通知
//	如果想要获取返回的结果，在返回通知中，将returning属性添加到@AfterReturning注解中
//	必须在方法签名中定义同名参数，aop在运行就会将结果传递给result这个参数
	@AfterReturning(value="logPointCut()",returning="result")
	public void logAfterReturnint(JoinPoint joinPoint,Object result){
		String methodName=joinPoint.getSignature().getName();
		String className=joinPoint.getTarget().getClass().getName();
		System.out.println("返回通知:"+methodName+
				","+className+",result="+result);
	}
//	异常通知
//	如果想要获取当前是哪个异常，将属性throwing 加入注解中，同时，方法参数中加入同名参数
//	同名参数类型必须为 分类或者是其超类
	@AfterThrowing(value="logPointCut()",throwing="e")
	public void logAfterThrowing(JoinPoint joinPoint,Exception e){
		String methodName=joinPoint.getSignature().getName();
		String className=joinPoint.getTarget().getClass().getName();
		System.out.println("异常通知:"+methodName+
				","+className+",e="+e);
		
	}
	//如果只捕获某个特定的异常，将参数定位这个特定的异常
}
<br>//验证切面
@Component
@Aspect
public class VerificationAspect {
			
//	环绕通知，功能最强大，
//	可以完成 前面四个通知
	//环绕通知必须有返回值，返回值就是目标方法的返回值
//	如果想在环绕通知中获取连接点的信息 ProceedingJoinPoint 作为参数
//	ProceedingJoinPoint .proceed() 可以执行目标方法
	@Around("execution(* com.oaec.*..*(..))")
	public Object vAroundMethod(ProceedingJoinPoint joinPoint) throws Throwable{
		Object result=null;
		try {
			//前置通知
			beforeV();
			//执行目标方法
			result=joinPoint.proceed();
			//返回通知
			afterReturningV();
		} catch (Throwable e) {
			//异常通知
			afterThrowingV();
			e.printStackTrace();
			throw e;
			
			
		}
		//后置通知
		afterV();
		return result;
	}
	
	public void beforeV(){
		System.out.println("环绕通知中，，，，，前置通知");
	}
	public void afterReturningV(){
		System.out.println("环绕通知中，，，返回通知");
	}
	public void afterThrowingV(){
		System.out.println("环绕通知中....异常通知");
	}
	public  void  afterV(){
		
		System.out.println("环绕通知中....后置通知");
	}
}
<br><br>import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

  @Before("execution(* com.example.service.*.*(..))")
  public void logBefore(JoinPoint joinPoint) {
  // 这段代码定义了一个切面，其中定义了一个 `@Before` 注解的方法，在 `com.example.service` 包中所有方法执行前都会被调用。
    System.out.println("Entering method: " + joinPoint.getSignature().getName());
  }
}
<br>
<br>@Before：在方法执行前运行
<br>@After：在方法执行后运行
<br>@Around：在方法执行前和执行后都运行
<br>@AfterReturning：在方法正常执行后运行
<br>@AfterThrowing：在方法抛出异常后运行
<br>@Pointcut：定义切入点表达式，可以多次引用<br>
通过使用这些注解，你可以非常方便地在切面中实现各种功能，例如日志记录、安全性校验、性能监控等。
<br>这段代码定义了一个切面，它的作用是在执行 com.example.service 包中的所有方法时统计并输出方法的执行时间。通过使用 @Around 注解，切面方法会在目标方法执行前和执行后都被调用，并可以通过调用 joinPoint.proceed() 方法来执行目标方法。<br>import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class PerformanceAspect {

  @Around("execution(* com.example.service.*.*(..))")
  public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    long start = System.currentTimeMillis();
    Object result = joinPoint.proceed();
    long elapsedTime = System.currentTimeMillis() - start;
    System.out.println("Method execution time: " + elapsedTime + " ms");
    return result;
  }
}

<br><br>Spring AOP 的实现原理是动态代理。<br>在 AOP 中，通常将切面称为“额外的功能”，而将要在其上添加切面的类或方法称为“目标对象”。在 Spring AOP 中，目标对象通过代理对象来实现，即在目标对象外面包装了一层代理对象，在代理对象中实现了切面功能。<br>当你在代码中调用目标对象的方法时，实际上是调用的代理对象的方法，代理对象会在实际调用目标对象的方法前后添加切面功能，从而实现了 AOP 的效果。<br>Spring AOP 支持两种代理模型：JDK 动态代理和 CGLIB 代理。在 JDK 动态代理中，代理对象需要实现与目标对象相同的接口，在 CGLIB 代理中，代理对象是通过扩展目标对象类来实现的，通常使用 CGLIB 代理的场景是当目标对象没有接口时。<br>AOP的实现依赖的是spring拓展点中的BeanPostProcessor的后置处理方法<br>
<br>代理对象的创建过程（advice，切面，切点）
<br>通过jdk或者cglib的方式来生成代理对象
<br>在执行方法调用的时候，会调用到生成的字节码文件中，直接回找到。dynamicAdvisorInterceptor类中的intercept方法，从此 方法开始执行
<br>根据之前定义好的通知来生成拦截器链
<br>从拦截器链中依次获取每一个通知开始进行执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个 CglibMethod Invocation的对象，找的时候是从一1的位置一次开始查找并且执行的。
<br><br><a rel="noopener nofollow" class="external-link" href="https://heapdump.cn/article/3333875" target="_blank">https://heapdump.cn/article/3333875</a><br>cglib是通过动态生成代理类的子类实现代理功能**，所生成的子类重写了代理类的所有方法（不包括final方法，至于private方法后文会讲到），cglib生成的子类中再通过方法拦截的方式实现对代理类方法的代码织入。**<br>说到这，重点来了，cglib实质上是通过继承父类并重写父类的方法达到生成代理类的，那么自然的，final类和final方法一定无法通过cglib代理，在生成的class文件中也不会找到对应的final方法。]]></description><link>02-编程语言\01-java\03-spring\04-aop.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/04-AOP.md</guid><pubDate>Wed, 10 Apr 2024 07:02:36 GMT</pubDate></item><item><title><![CDATA[05-事务]]></title><description><![CDATA[ 
 <br><br>Q:spring 事务的实现原理<br>A: Spring 事务的实现原理是基于 AOP 的。<br>在 Spring 中，事务管理是通过切面实现的，即将事务管理的功能作为切面添加到目标对象上。<br>Spring 通过使用事务拦截器实现事务管理，该拦截器的作用是在调用目标方法前后管理事务的开启、提交、回滚等操作。<br>事务的具体实现依赖于底层使用的事务管理器，Spring 支持多种事务管理器，例如 JPA、JDBC、Hibernate 等，它们对应的事务管理器分别实现了对应的事务管理。<br>通过结合事务拦截器和事务管理器，Spring 可以实现声明式事务管理，即通过在配置文件或注解中声明事务属性，而不用在代码中显式编写事务管理逻辑。<br><br><a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1N8411J7zK?p=50&amp;spm_id_from=pageDriver&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" target="_blank">https://www.bilibili.com/video/BV1N8411J7zK?p=50&amp;spm_id_from=pageDriver&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf</a><br>
spring的事务管理是如何实现的？<br>
<img src="02-编程语言\01-java\03-spring\assets\spring-事务.png"><br>总：<br>
S pr i n g的事务是由aop来实现的<br>首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下要 通过通知来完成核心功能，但是事务不是通过通知来实现的，而是通过一个TransactionInter ceptor来实现的，然后调用invoke来实现具 体的逻辑 <br>分：<br>
<br>准备工作，解析各个方法上事务相关的属性，根据具体的属性来判断是否开始新事务 
<br>当需要开启的时候，获取数据库连接，关闭自动提交功能，开起事务 
<br>执行具体的sql逻辑操作工
<br>在操作过程中，如果执行失败了，那么会通过completeTransactionAfterThrowing来完成事务的回滚操作，回滚的具体逻 辑是通过doRollBack方法来实现的，实现的时候也是要先获取连接对象，通过连接对象来回滚 
<br>如果执行过程中，没有任何意外情况的发生，那么通过commitTransactionAfterReturning来完成事务的提交操作，提交的 具体逻辑是通过doCommit方法来实现的，实现的时候也是要获取连接，通过连接对象来提交 
<br>当事务执行完毕之后需要清除相关的事务信息cleanupTransactionInfo 如果想要聊的更加细致的话，需要知道TransactionInfo，TransactionStatus
<br><br><br>Q: spring中事务的传播机制有哪些 分别解释一下<br>A: Spring 中事务的传播机制有以下几种：<br>
<br>REQUIRED: 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的传播机制，即在被调用的方法中需要加入事务。
<br>SUPPORTS: 支持当前事务，如果当前没有事务，就以非事务方式执行。
<br>MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。
<br>REQUIRES_NEW: 新建事务，如果当前存在事务，就把当前事务挂起。
<br>NOT_SUPPORTED: 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
<br>NEVER: 以非事务方式执行，如果当前存在事务，则抛出异常。
<br>NESTED: 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与REQUIRED类似的操作。
<br>事务传播机制用于控制多个事务方法之间的执行关系和影响。通过设置不同的传播机制，可以灵活控制事务的执行，从而满足不同的业务需求。<br><br><a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1N8411J7zK?p=51&amp;spm_id_from=pageDriver&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" target="_blank">https://www.bilibili.com/video/BV1N8411J7zK?p=51&amp;spm_id_from=pageDriver&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf</a><br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/j1231230/article/details/105534599" target="_blank">https://blog.csdn.net/j1231230/article/details/105534599</a><br><img src="02-编程语言\01-java\03-spring\assets\spring事务失效.png">]]></description><link>02-编程语言\01-java\03-spring\05-事务.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/05-事务.md</guid><pubDate>Wed, 08 May 2024 09:08:27 GMT</pubDate><enclosure url="02-编程语言\01-java\03-spring\assets\spring-事务.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\03-spring\assets\spring-事务.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[06-springMVC]]></title><description><![CDATA[ 
 <br><img src="02-编程语言\01-java\03-spring\assets\pasted-image-20230301153532.png"><br> DispatcherServlet -&gt;handleMapping -&gt;控制器-&gt;视图解析器]]></description><link>02-编程语言\01-java\03-spring\06-springmvc.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/06-springMVC.md</guid><pubDate>Wed, 08 May 2024 09:08:18 GMT</pubDate><enclosure url="02-编程语言\01-java\03-spring\assets\pasted-image-20230301153532.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\03-spring\assets\pasted-image-20230301153532.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[098-常用注解]]></title><description><![CDATA[ 
 <br><br>或许大家都知道@Configuration注解与@Component注解的区别，@Component注解用来定义一个Bean，而@Configuration与@Bean注解结合，可以在一个类中定义多个Bean]]></description><link>02-编程语言\01-java\03-spring\098-常用注解.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/098-常用注解.md</guid><pubDate>Wed, 10 Apr 2024 07:02:41 GMT</pubDate></item><item><title><![CDATA[99-其他]]></title><description><![CDATA[ 
 <br><br>首先，在同一个 XML 配置文件里面，不能存在 id 相同的两个bean，否则spring容器启动的时候会报错<br>因为 id 这个属性表示一个 Bean 的唯一标志符号，所以Spring 在启动的时候会去验证 id 的唯一性，一旦发现重复就会报错， 这个错误发生 Spring 对 XML 文件进行解析转化为 BeanDefinition 的阶段。<br>
但是在两个不同的 Spring 配置文件里面，可以存在 id 相同的两个bean。IOC容器在加载 Bean 的时候，默认会多个相同 id 的 bean 进行覆盖。<br>
在 Spring3.x 版本以后，这个问题发生了变化 我们知道 Spring3.x 里面提供@Configuration 注解去声明一个配置类，然后使用@Bean 注解实现 Bean 的声明，这种方式完全取代了XMl。在这种情况下，如果我们在同一个配置类里面声明多个相同名字的bean，在Spring IOC 容器中只会注册第一个声明的 Bean 的实例。后续重复名字的 Bean 就不会再注册了。 像这样一段代码，在 Spring IOC 容器里面，只会保存 UserService01 这个实例，后续相同名字的实例不会再加载。<br>
<img src="02-编程语言\01-java\03-spring\assets\pasted-image-20230305192254.png"><br>如果使用@Autowired 注解根据类型实现依赖注入，因为IOC容器只有UserService01的实例，所以启动的时候会提示找不到UserService02这个实例<br>如果使用@Resource 注解根据名词实现依赖注入，在IOC 容器里面得到的实例对象是 UserService01， 于是 Spring 把 UserService01 这个实例赋值给 UserService02，就会提示类型不匹配错误。<br>
<img src="02-编程语言\01-java\03-spring\assets\pasted-image-20230305192328.png">]]></description><link>02-编程语言\01-java\03-spring\99-其他.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/03-spring/99-其他.md</guid><pubDate>Wed, 08 May 2024 09:08:23 GMT</pubDate><enclosure url="02-编程语言\01-java\03-spring\assets\pasted-image-20230305192254.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\03-spring\assets\pasted-image-20230305192254.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-启动过程]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/7035910505810100255" target="_blank">https://juejin.cn/post/7035910505810100255</a>]]></description><link>02-编程语言\01-java\04-springboot\01-启动过程.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/04-springboot/01-启动过程.md</guid><pubDate>Wed, 10 Apr 2024 07:02:47 GMT</pubDate></item><item><title><![CDATA[02-循环依赖]]></title><description><![CDATA[ 
 <br>springboot 2.6.x 以上 解决循环依赖：<br>
<a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1uj411K75k/?spm_id_from=333.788&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" target="_blank">https://www.bilibili.com/video/BV1uj411K75k/?spm_id_from=333.788&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf</a><br>spring：
	main:
		allow-circular-references=true
]]></description><link>02-编程语言\01-java\04-springboot\02-循环依赖.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/04-springboot/02-循环依赖.md</guid><pubDate>Wed, 10 Apr 2024 07:02:48 GMT</pubDate></item><item><title><![CDATA[00-总览]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/jvm/JVM%E6%80%BB%E7%BB%93.md" target="_blank">https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/jvm/JVM%E6%80%BB%E7%BB%93.md</a><br>这篇总结主要是基于我之前JVM系列文章而形成的的。主要是把重要的知识点用自己的话说了一遍，可能会有一些错误，还望见谅和指点。谢谢<br>更多详细内容可以查看我的专栏文章：深入理解JVM虚拟机<br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/column/details/21960.html" target="_blank">https://blog.csdn.net/column/details/21960.html</a><br><br><br>首先JVM是一个虚拟机，当你安装了jre，它就包含了jvm环境。JVM有自己的内存结构，字节码执行引擎，因此class字节码才能在jvm上运行，除了Java以外，Scala，groovy等语言也可以编译成字节码而后在jvm中运行。JVM是用c开发的。<br><br>内存模型老生常谈了，主要就是线程共享的堆区，方法区，本地方法栈。还有线程私有的虚拟机栈和程序计数器。<br>堆区存放所有对象，每个对象有一个地址，Java类jvm初始化时加载到方法区，而后会在堆区中生成一个Class对象，来负责这个类所有实例的实例化。<br>栈区存放的是栈帧结构，栈帧是一段内存空间，包括参数列表，返回地址，局部变量表等，局部变量表由一堆slot组成，slot的大小固定，根据变量的数据类型决定需要用到几个slot。<br>方法区存放类的元数据，将原来的字面量转换成引用，当然，方法区也提供常量池，常量池存放-128到127的数字类型的包装类。<br>
字符串常量池则会存放使用intern的字符串变量。<br><br>这里指的是oom和内存泄漏这类错误。<br>oom一般分为三种，堆区内存溢出，栈区内存溢出以及方法区内存溢出。<br>堆内存溢出主要原因是创建了太多对象，比如一个集合类死循环添加一个数，此时设置jvm参数使堆内存最大值为10m，一会就会报oom异常。<br>栈内存溢出主要与栈空间和线程有关，因为栈是线程私有的，如果创建太多线程，内存值超过栈空间上限，也会报oom。<br>方法区内存溢出主要是由于动态加载类的数量太多，或者是不断创建一个动态代理，用不了多久方法区内存也会溢出，会报oom，这里在1.7之前会报permgem oom，1.8则会报meta space oom，这是因为1.8中删除了堆中的永久代，转而使用元数据区。<br>内存泄漏一般是因为对象被引用无法回收，比如一个集合中存着很多对象，可能你在外部代码把对象的引用置空了，但是由于对象还被集合给引用着，所以无法被回收，导致内存泄漏。测试也很简单，就在集合里添加对象，添加完以后把引用置空，循环操作，一会就会出现oom异常，原因是内存泄漏太多了，导致没有空间分配新的对象。<br><br>jvm的一些常用命令行工具可以参考这个视频：<a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1QJ411P78Q/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1QJ411P78Q/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" target="_blank">【java】jvm指令与工具jstat/jstack/jmap/jconsole/jps/visualVM_哔哩哔哩_bilibili</a><br>自动导出dump:<br>
-XX:+HeapDumpOnOutOfMemoryError<br>
可以通过 -XX:HeapDumpPath=/tmp/heapdump.hprof 来显示指定路径<br>命令行工具有jstack jstat jmap 等，jstack可以跟踪线程的调用堆栈，以便追踪错误原因。<br>jstat可以检查jvm的内存使用情况，gc情况以及线程状态等。<br>jmap用于把堆栈快照转储到文件系统，然后可以用其他工具去排查。<br>visualvm是一款很不错的gui调试工具，可以远程登录主机以便访问其jvm的状态并进行监控。<br><br>class文件结构比较复杂，首先jvm定义了一个class文件的规则，并且让jvm按照这个规则去验证与读取。<br>开头是一串魔数，然后接下来会有各种不同长度的数据，通过class的规则去读取这些数据，jvm就可以识别其内容，最后将其加载到方法区。<br><br>jvm的类加载顺序是bootstrap类加载器，extclassloader加载器，最后是appclassloader用户加载器，分别加载的是jdk/bin ，jdk/ext以及用户定义的类目录下的类（一般通过ide指定），一般核心类都由bootstrap和ext加载器来加载，appclassloader用于加载自己写的类。<br>双亲委派模型，加载一个类时，首先获取当前类加载器，先找到最高层的类加载器bootstrap让他尝试加载，他如果加载不了再让ext加载器去加载，如果他也加载不了再让appclassloader去加载。这样的话，确保一个类型只会被加载一次，并且以高层类加载器为准，防止某些类与核心类重复，产生错误。<br>“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情：<br>通过一个类的全限定名来获取定义此类的二进制字节流。<br>
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>
在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。<br><br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。其中验证、准备、解析3个部分统称为连接。<br>1）加载<br>
<img alt="类加载过程" src="02-编程语言\01-java\06-jvm\assets\类加载过程.png"><br>“类加载”过程的一个阶段，在加载阶段，虚拟机需要完成以下3件事情：<br>
<br>通过一个类的全限定名来获取定义此类的二进制字节流。
<br>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
<br>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
<br>2）验证<br>连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。从整体上看，验证阶段大致上会完成下面4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。<br>3）准备<br>该阶段是正式为类变量（static修饰的变量）分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这里所说的初始值“通常情况”下是数据类型的零值，下表列出了Java中所有基本数据类型的零值。<br><img src="https://img-blog.csdn.net/2018032523454331" referrerpolicy="no-referrer"><br>4）解析<br>该阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。<br>5）初始化<br>到了初始化阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序制定的主观计划去初始化类变量和其他资源。<br>我们也可以从另外一种更直接的形式来表达：初始化阶段是执行类构造器clinit()方法的过程。clinit() 不是程序员在&nbsp;Java&nbsp;代码中直接编写的方法，而是由 Javac&nbsp;编译器自动生成的。<br>clinit()&nbsp;方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<br>我之前还写过一篇关于初始化的面试题：&nbsp;<a data-tooltip-position="top" aria-label="https://blog.csdn.net/v123411739/article/details/79600228" rel="noopener nofollow" class="external-link" title="一道有意思的“初始化”面试题" href="https://blog.csdn.net/v123411739/article/details/79600228" target="_blank">一道有意思的“初始化”面试题</a>，有兴趣的同学可以看一看。<br><br>类加载classloader中有两个方法loadclass和findclass，loadclass遵从双亲委派模型，先调用父类加载的loadclass，如果父类和自己都无法加载该类，则会去调用findclass方法，而findclass默认实现为空，如果要自定义类加载方式，则可以重写findclass方法。<br>常见使用defineclass的情况是从网络或者文件读取字节码，然后通过defineclass将其定义成一个类，并且返回一个Class对象，说明此时类已经加载到方法区了。当然1.8以前实现方法区的是永久代，1.8以后则是元空间了。<br><br>&nbsp;目前比较常见的场景主要有：<br>1）线程上下文类加载器，典型的：JDBC&nbsp;使用线程上下文类加载器加载 Driver 实现类<br>2）Tomcat&nbsp;的多 Web 应用程序<br>3）OSGI&nbsp;实现模块化热部署<br><br>原因其实很简单，就是使用双亲委派模型无法满足需求了，因此只能破坏它，这边以面试常问的&nbsp;Tomcat&nbsp;为例。<br>我们知道 Tomcat&nbsp;容器可以同时部署多个&nbsp;Web&nbsp;应用程序，多个&nbsp;Web&nbsp;应用程序很容易存在依赖同一个&nbsp;jar&nbsp;包，但是版本不一样的情况。例如应用1和应用2都依赖了&nbsp;spring&nbsp;，应用1使用的&nbsp;3.2.*&nbsp;版本，而应用2使用的是 4.3.*&nbsp;版本。<br>如果遵循双亲委派模型，这个时候使用哪个版本了？<br>其实使用哪个版本都不行，很容易出现兼容性问题。因此，Tomcat&nbsp;只能选择破坏双亲委派模型。<br><br>破坏双亲委派模型的思路都比较类似，这边以面试中常问到的&nbsp;Tomcat&nbsp;为例。<br>其实原理非常简单，我们可以看到上面的类加载方法源码（loadClass）的方法修饰符是&nbsp;protected，因此我们只需以下几步就能破坏双亲委派模型。<br>1）继承&nbsp;ClassLoader，Tomcat&nbsp;中的 WebappClassLoader 继承&nbsp;ClassLoader&nbsp;的子类 URLClassLoader。<br><img src="https://img-blog.csdnimg.cn/20210814213652416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3YxMjM0MTE3Mzk=,size_16,color_FFFFFF,t_70" referrerpolicy="no-referrer"><br>2）重写&nbsp;loadClass&nbsp;方法，实现自己的逻辑，不要每次都先委托给父类加载，例如可以先在本地加载，这样就破坏了双亲委派模型了。<br><br>jvm通过字节码执行引擎来执行class代码，他是一个栈式执行引擎。这部分内容比较高深，在这里就不献丑了。<br><br>编译期优化主要有几种<br>1 泛型的擦除，使得泛型在编译时变成了实际类型，也叫伪泛型。<br>2 自动拆箱装箱，foreach循环自动变成迭代器实现的for循环。<br>3 条件编译，比如if(true)直接可得。<br>运行期优化主要有几种<br>1 JIT即时编译<br>Java既是编译语言也是解释语言，因为需要编译代码生成字节码，而后通过解释器解释执行。<br>但是，有些代码由于经常被使用而成为热点代码，每次都编译太过费时费力，干脆直接把他编译成本地代码，这种方式叫做JIT即时编译处理，所以这部分代码可以直接在本地运行而不需要通过jvm的执行引擎。<br>2 公共表达式擦除，就是一个式子在后面如果没有被修改，在后面调用时就会被直接替换成数值。<br>3 数组边界擦除，方法内联，比较偏，意义不大。<br>4 逃逸分析，用于分析一个对象的作用范围，如果只局限在方法中被访问，则说明不会逃逸出方法，这样的话他就是线程安全的，不需要进行并发加锁。<br>1<br><br><a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV13J411g7A1/?spm_id_from=333.999.0.0&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV13J411g7A1/?spm_id_from=333.999.0.0&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" target="_blank">【java】垃圾收集器|g1收集器_哔哩哔哩_bilibili</a><br>1 GC算法：停止复制，存活对象少时适用，缺点是需要两倍空间。标记清除，存活对象多时适用，但是容易产生随便。标记整理，存活对象少时适用，需要移动对象较多。<br>2 GC分区，一般GC发生在堆区，堆区可分为年轻代，老年代，以前有永久代，现在没有了。<br>年轻代分为eden和survior，新对象分配在eden，当年轻代满时触发minor gc，存活对象移至survivor区，然后两个区互换，等待下一场gc，当对象存活的阈值达到设定值时进入老年代，大对象也会直接进入老年代。<br>eden:from survivor:to survivor = 8:1:1<br>
minor gc（即 young gc）很频繁，而且也没什么好调优的,一般都是full GC会引发性能问题，stop the world <br>老年代空间较大，当老年代空间不足以存放年轻代过来的对象时，开始进行full gc。同时整理年轻代和老年代。<br>
一般年轻代使用停止复制，老年代使用标记清除。<br>3 垃圾收集器<br>serial串行<br>parallel并行<br>它们都有年轻代与老年代的不同实现。<br>然后是scanvage收集器，注重吞吐量，可以自己设置，不过不注重延迟。<br>cms垃圾收集器，注重延迟的缩短和控制，并且收集线程和系统线程可以并发。<br>cms收集步骤主要是，初次标记gc root，然后停顿进行并发标记，而后处理改变后的标记，最后停顿进行并发清除。<br>g1收集器和cms的收集方式类似，但是g1将堆内存划分成了大小相同的小块区域，并且将垃圾集中到一个区域，存活对象集中到另一个区域，然后进行收集，防止产生碎片，同时使分配方式更灵活，它还支持根据对象变化预测停顿时间，从而更好地帮用户解决延迟等问题。<br><br>在Java并发中讲述了synchronized重量级锁以及锁优化的方法，包括轻量级锁，偏向锁，自旋锁等。详细内容可以参考我的专栏：Java并发技术指南]]></description><link>02-编程语言\01-java\06-jvm\00-总览.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/00-总览.md</guid><pubDate>Wed, 08 May 2024 09:08:43 GMT</pubDate><enclosure url="02-编程语言\01-java\06-jvm\assets\类加载过程.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\06-jvm\assets\类加载过程.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[000-medium]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://medium.com/@AlexanderObregon/java-virtual-machine-optimization-techniques-0c7dfb0a61cd" target="_blank">https://medium.com/@AlexanderObregon/java-virtual-machine-optimization-techniques-0c7dfb0a61cd</a><br><br>Java虚拟机优化技术<br>[<br><img alt="Alexander Obregon" src="https://miro.medium.com/v2/resize:fill:88:88/1*i2BLX3qBID5JabZAYI3EJQ.jpeg" referrerpolicy="no-referrer"><br>](<a rel="noopener nofollow" class="external-link" href="https://medium.com/@AlexanderObregon?source=post_page-----0c7dfb0a61cd--------------------------------" target="_blank">https://medium.com/@AlexanderObregon?source=post_page-----0c7dfb0a61cd--------------------------------</a>)<br><img src="https://miro.medium.com/v2/resize:fit:328/0*l97vC1QkxR8Sivxt.png" referrerpolicy="no-referrer"><br><a data-tooltip-position="top" aria-label="https://www.oracle.com/java/java-affinity/logos/" rel="noopener nofollow" class="external-link" href="https://www.oracle.com/java/java-affinity/logos/" target="_blank">Image Source</a><br><br>The Java Virtual Machine (JVM) is a cornerstone of Java’s platform-independent capabilities. It allows Java applications to run on any device or operating system that has a JVM installed, making Java one of the most versatile programming languages. However, to ensure optimal performance, it’s crucial to understand and implement JVM optimization techniques.<br>
Java 虚拟机 (JVM) 是 Java 平台无关功能的基石。它允许 Java 应用程序在任何安装了 JVM 的设备或操作系统上运行，使 Java 成为最通用的编程语言之一。然而，为了确保最佳性能，理解和实施 JVM 优化技术至关重要。<br><br>了解堆大小调整<br>In Java Virtual Machine (JVM) optimization, one of the most critical aspects to consider is the management of heap size. The JVM heap is a memory area where Java objects are stored. Managing this heap size effectively is crucial for the performance and stability of Java applications.<br>
在 Java 虚拟机 (JVM) 优化中，要考虑的最关键的方面之一是堆大小的管理。 JVM堆是存储Java对象的内存区域。有效管理堆大小对于 Java 应用程序的性能和稳定性至关重要。<br><br>设置正确的堆大小<br>The heap size in the JVM is determined by two parameters: -Xms, which sets the initial heap size, and -Xmx, which sets the maximum heap size. These parameters are essential because they directly influence the performance of your Java application.<br>
JVM 中的堆大小由两个参数确定： ，它设置初始堆大小； ，它设置最大堆大小。这些参数非常重要，因为它们直接影响 Java 应用程序的性能。<br>
<br>Initial Heap Size (-Xms): This is the size that the JVM allocates upon startup. Setting this value too low can cause the JVM to perform more garbage collection (GC) operations as it needs to free up memory space more frequently. Conversely, a higher initial size can reduce the need for GC but requires more memory upfront.<br>
初始堆大小 (-Xms)：这是 JVM 在启动时分配的大小。将此值设置得太低可能会导致 JVM 执行更多垃圾收集 (GC) 操作，因为它需要更频繁地释放内存空间。相反，较高的初始大小可以减少 GC 的需求，但需要预先使用更多内存。
<br>Maximum Heap Size (-Xmx): This parameter caps the maximum memory that the JVM heap can expand to. It’s vital to set this value carefully because if the heap grows to its maximum limit, it can lead to OutOfMemoryErrors. This value should be set based on the application’s requirement and the total memory available on the system.<br>
最大堆大小 (-Xmx)：此参数限制 JVM 堆可以扩展到的最大内存。仔细设置此值至关重要，因为如果堆增长到最大限制，可能会导致 OutOfMemoryErrors。应根据应用程序的要求和系统上可用的总内存来设置该值。
<br><br>监控堆使用情况<br>Effective JVM performance tuning involves regular monitoring of heap usage. Tools such as JConsole, VisualVM, and command-line utilities like jstat can provide insights into how the heap is being used in real-time.<br>
有效的 JVM 性能调整涉及定期监视堆使用情况。 JConsole、VisualVM 等工具和命令行实用程序可以提供有关堆如何实时使用的见解。<br>Monitoring heap usage helps in understanding:<br>
监视堆使用情况有助于理解：<br>
<br>The amount of memory used by the application.<br>
应用程序使用的内存量。
<br>The frequency and duration of garbage collection processes.<br>
垃圾收集过程的频率和持续时间。
<br>Memory leaks, indicated by a continuously increasing memory usage pattern.<br>
内存泄漏，由持续增加的内存使用模式表明。
<br><br>内存监控的代码示例<br>&lt;span id="a99a" data-selectable-paragraph=""&gt;&lt;br&gt;&lt;span&gt;Runtime&lt;/span&gt; &lt;span&gt;runtime&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; Runtime.getRuntime();&lt;br&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;totalMemory&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; runtime.totalMemory(); &lt;br&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;freeMemory&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; runtime.freeMemory(); &lt;br&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;usedMemory&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; totalMemory - freeMemory; &lt;br&gt;&lt;br&gt;System.out.println(&lt;span&gt;"Total Memory: "&lt;/span&gt; + totalMemory);&lt;br&gt;System.out.println(&lt;span&gt;"Free Memory: "&lt;/span&gt; + freeMemory);&lt;br&gt;System.out.println(&lt;span&gt;"Used Memory: "&lt;/span&gt; + usedMemory);&lt;/span&gt;
<br><br>垃圾收集和堆性能<br>The choice of garbage collector and its configuration plays a significant role in heap performance. JVM offers several garbage collectors, each designed for different types of applications and workloads. Some of the well-known garbage collectors include:<br>
垃圾收集器的选择及其配置对堆性能起着重要作用。 JVM 提供了多种垃圾收集器，每种垃圾收集器都针对不同类型的应用程序和工作负载而设计。一些著名的垃圾收集器包括：<br>
<br>Serial Garbage Collector: Ideal for applications with small data sets and single-threaded environments. It’s simple but can pause all application threads during garbage collection.<br>
串行垃圾收集器：非常适合具有小数据集和单线程环境的应用程序。它很简单，但可以在垃圾收集期间暂停所有应用程序线程。
<br>Parallel Garbage Collector: Also known as Throughput Collector, it’s designed for multi-threaded applications with a focus on maximizing application throughput. It uses multiple threads for garbage collection but still pauses application threads during major GC events.<br>
并行垃圾收集器：也称为吞吐量收集器，它专为多线程应用程序而设计，重点是最大化应用程序吞吐量。它使用多个线程进行垃圾收集，但在主要 GC 事件期间仍会暂停应用程序线程。
<br>Concurrent Mark Sweep (CMS) Collector: Aims to minimize pauses by performing most of its work concurrently with the application threads. It’s suitable for applications where response time is more critical than throughput.<br>
并发标记扫描 (CMS) 收集器：旨在通过与应用程序线程同时执行大部分工作来最大限度地减少暂停。它适用于响应时间比吞吐量更重要的应用程序。
<br>G1 Garbage Collector: Designed for applications running on multi-core machines with large memory spaces. It aims to provide high throughput with predictable pause times by dividing the heap into regions and collecting them in a predictable manner.<br>
G1垃圾收集器：专为在具有大内存空间的多核机器上运行的应用程序而设计。它旨在通过将堆划分为区域并以可预测的方式收集它们来提供高吞吐量和可预测的暂停时间。
<br>Z Garbage Collector (ZGC): A scalable low-latency garbage collector. ZGC can handle large heaps with minimal pause times, making it suitable for applications where consistent low latency is required.<br>
Z 垃圾收集器 (ZGC)：可扩展的低延迟垃圾收集器。 ZGC 可以以最短的暂停时间处理大型堆，使其适合需要一致的低延迟的应用程序。
<br><br>平衡堆大小和垃圾收集<br>Finding the right balance between heap size and garbage collection strategy is key. A larger heap size may reduce the frequency of GC, but when it occurs, it could be more prolonged, impacting the application’s response time. A smaller heap might result in more frequent but quicker garbage collections. The ideal configuration depends on the specific requirements and behavior of the application.<br>
在堆大小和垃圾收集策略之间找到适当的平衡是关键。较大的堆大小可能会降低 GC 的频率，但当发生这种情况时，时间可能会更长，从而影响应用程序的响应时间。较小的堆可能会导致更频繁但更快的垃圾收集。理想的配置取决于应用程序的具体要求和行为。<br>By understanding and adjusting these heap size parameters, monitoring their effects, and selecting appropriate garbage collection strategies, developers and system administrators can significantly enhance the performance and reliability of Java applications running on the JVM.<br>
通过了解和调整这些堆大小参数、监视其影响并选择适当的垃圾收集策略，开发人员和系统管理员可以显着提高在 JVM 上运行的 Java 应用程序的性能和可靠性。<br><br>探索 JIT 编译<br>Just-In-Time (JIT) compilation is a pivotal feature of the Java Virtual Machine (JVM) that significantly enhances the performance of Java applications. Unlike traditional compilers that convert code before it runs, JIT compilers translate the bytecode into machine code at runtime, which allows for more efficient execution of Java applications.<br>
即时 (JIT) 编译是 Java 虚拟机 (JVM) 的一项关键功能，可显着增强 Java 应用程序的性能。与在运行之前转换代码的传统编译器不同，JIT 编译器在运行时将字节码转换为机器代码，从而可以更有效地执行 Java 应用程序。<br><br>了解 JIT 编译<br>JIT compilation is an integral part of the JVM that kicks in when a Java program is executed. Instead of interpreting bytecode line-by-line, the JIT compiler compiles the bytecode into native machine code. This native code is then directly executed by the CPU, leading to faster execution compared to interpreting bytecode.<br>
JIT 编译是 JVM 的一个组成部分，在执行 Java 程序时启动。 JIT 编译器不是逐行解释字节码，而是将字节码编译为本机机器代码。然后，CPU 直接执行该本机代码，与解释字节码相比，执行速度更快。<br>The primary advantage of JIT compilation is its ability to optimize code in real-time. Since JIT compilation occurs during the execution of the application, it can identify and optimize frequently executed paths, known as “hot spots.” This targeted optimization approach ensures that the most critical parts of the code are highly optimized for performance.<br>
JIT 编译的主要优点是能够实时优化代码。由于 JIT 编译发生在应用程序执行期间，因此它可以识别和优化频繁执行的路径（称为“热点”）。这种有针对性的优化方法可确保代码最关键的部分针对性能进行高度优化。<br><br>JIT编译的过程<br>The JIT compiler works in the background, identifying performance-critical parts of the code. It considers factors such as the frequency of method calls and loops to determine which parts of the code are hot spots. Once identified, these hot spots are compiled into native code.<br>
JIT 编译器在后台工作，识别代码中性能关键的部分。它考虑方法调用和循环的频率等因素来确定代码的哪些部分是热点。一旦识别出来，这些热点就会被编译为本机代码。<br>JIT compilers in the JVM also employ various optimization techniques such as:<br>
JVM 中的 JIT 编译器还采用各种优化技术，例如：<br>
<br>Method Inlining: This involves replacing a method call with the actual code of the method. It reduces the overhead of method calls, especially for small methods that are called frequently.<br>
方法内联：这涉及用方法的实际代码替换方法调用。它减少了方法调用的开销，特别是对于频繁调用的小方法。
<br>Loop Optimization: Enhancing the performance of loops, which are common in many applications. Techniques like loop unrolling (expanding a loop into multiple iterations) are used.<br>
循环优化：增强循环的性能，这在许多应用程序中都很常见。使用循环展开（将循环扩展为多个迭代）等技术。
<br>Dead Code Elimination: Removing code segments that do not affect the program output, thus reducing the size of the compiled code.<br>
死代码消除：去除不影响程序输出的代码段，从而减少编译后代码的大小。
<br><br>自适应优化<br>One of the unique aspects of JIT compilation in the JVM is its adaptive optimization capability. The JIT compiler not only compiles the bytecode to native code but also continuously analyzes the running program’s performance. If it identifies a more efficient way to execute a part of the code, it recompiles that part with the new optimizations. This ongoing optimization process ensures that Java applications continue to run efficiently, even as their workload or execution patterns change.<br>
JVM 中 JIT 编译的独特之处之一是其自适应优化能力。 JIT编译器不仅将字节码编译为本机代码，还不断分析运行程序的性能。如果它找到了执行部分代码的更有效方法，它就会使用新的优化重新编译该部分。这种持续的优化过程可确保 Java 应用程序继续高效运行，即使其工作负载或执行模式发生变化。<br><br>分层编译<br>Modern JVMs often use a tiered compilation approach. In this system, the JVM initially uses a simpler, faster compiler to get the benefits of JIT compilation quickly. As the application continues to run, a more advanced compiler recompiles the hot spots with more sophisticated optimizations. This tiered approach balances the need for quick startup times with the demand for optimal performance in the long run.<br>
现代 JVM 通常使用分层编译方法。在这个系统中，JVM最初使用更简单、更快的编译器来快速获得JIT编译的好处。随着应用程序继续运行，更高级的编译器会通过更复杂的优化重新编译热点。这种分层方法平衡了快速启动时间的需求和长期最佳性能的需求。<br>JIT compilation is a remarkable feature of the JVM, providing a significant performance boost to Java applications. By compiling bytecode into native code at runtime, and continuously optimizing this process, JIT ensures that Java applications are executed as efficiently as possible. Understanding and leveraging the capabilities of JIT compilation is crucial for developers and system administrators looking to optimize Java applications for speed and efficiency.<br>
JIT 编译是 JVM 的一项显着功能，可为 Java 应用程序提供显着的性能提升。通过在运行时将字节码编译为本机代码，并不断优化此过程，JIT 可确保 Java 应用程序尽可能高效地执行。了解和利用 JIT 编译的功能对于寻求优化 Java 应用程序速度和效率的开发人员和系统管理员至关重要。<br>While heap size adjustments and JIT compilation are fundamental to JVM optimization, there are several other strategies that can be employed to fine-tune the performance of Java applications. These include thread optimization, the use of efficient algorithms and data structures, and leveraging specific JVM options and flags.<br>
虽然堆大小调整和 JIT 编译是 JVM 优化的基础，但还有其他几种策略可用于微调 Java 应用程序的性能。其中包括线程优化、高效算法和数据结构的使用以及利用特定的 JVM 选项和标志。<br><br>线程优化<br>Java is renowned for its robust multi-threading capabilities. Efficient management of threads is crucial for optimizing the performance of Java applications, especially in server environments and applications dealing with concurrent processing.<br>
Java 以其强大的多线程功能而闻名。线程的有效管理对于优化 Java 应用程序的性能至关重要，特别是在服务器环境和处理并发处理的应用程序中。<br>
<br>Thread Pool Management: Proper management of thread pools is essential. Creating too many threads can lead to high memory usage and increased context switching, which can degrade performance. On the other hand, too few threads can lead to underutilization of CPU resources. Tools like Executors in the Java Concurrency API help manage thread pools effectively.<br>
线程池管理：正确管理线程池至关重要。创建太多线程可能会导致内存使用率过高并增加上下文切换，从而降低性能。另一方面，线程太少会导致CPU资源利用不足。 Java Concurrency API 中的 Executors 等工具有助于有效管理线程池。
<br>Synchronization Overhead: Synchronization in multi-threaded applications can lead to thread contention and decreased throughput. Minimizing synchronization overhead by using concurrent collections and algorithms can enhance performance.<br>
同步开销：多线程应用程序中的同步可能会导致线程争用并降低吞吐量。通过使用并发集合和算法最大限度地减少同步开销可以提高性能。
<br>Lock-Free Algorithms: In some cases, using lock-free algorithms and data structures, like those found in the java.util.concurrent package, can significantly improve performance by reducing blocking and waiting times in multi-threaded environments.<br>
无锁算法：在某些情况下，使用无锁算法和数据结构（如软件包中的算法和数据结构）可以通过减少多线程环境中的阻塞和等待时间来显着提高性能。
<br><br>使用高效的算法和数据结构<br>The choice of algorithms and data structures has a profound impact on the performance of Java applications.<br>
算法和数据结构的选择对Java应用程序的性能有着深远的影响。<br>
<br>Algorithmic Efficiency: Implementing the most efficient algorithm for a given task is vital. Algorithms with lower time complexity can significantly improve performance, especially for tasks that are executed frequently or deal with large data sets.<br>
算法效率：针对给定任务实现最有效的算法至关重要。时间复杂度较低的算法可以显着提高性能，特别是对于频繁执行或处理大型数据集的任务。
<br>Data Structure Optimization: Choosing the right data structure can also greatly affect performance. For instance, ArrayLists may be more efficient than LinkedLists for random access of elements, while HashMaps are generally faster for key-based lookups than TreeMaps.<br>
数据结构优化：选择正确的数据结构也会极大地影响性能。例如，对于元素的随机访问，ArrayList 可能比 LinkedList 更有效，而对于基于键的查找，HashMap 通常比 TreeMap 更快。
<br>Memory Footprint: Consider the memory footprint of data structures. Structures that use memory efficiently can reduce the frequency of garbage collection and improve overall application performance.<br>
内存占用：考虑数据结构的内存占用。有效使用内存的结构可以降低垃圾收集的频率并提高整体应用程序性能。
<br><br>JVM 选项和标志<br>The JVM provides a plethora of options and flags that can be used to tune its performance. These options allow for fine-grained control over various aspects of JVM operation and can be used to optimize performance for specific application requirements.<br>
JVM 提供了大量可用于调整其性能的选项和标志。这些选项允许对 JVM 操作的各个方面进行细粒度控制，并可用于优化特定应用程序要求的性能。<br>
<br>JVM Tuning Flags: Understanding and using JVM tuning flags, like those that control garbage collection behavior and JIT compiler optimizations, can significantly impact performance. For example, -XX:+UseG1GC enables the G1 Garbage Collector, which can be beneficial for applications with large heaps.<br>
JVM 调整标志：了解和使用 JVM 调整标志（例如控制垃圾收集行为和 JIT 编译器优化的标志）可以显着影响性能。例如，启用 G1 垃圾收集器，这对于具有大堆的应用程序来说是有益的。
<br>Application-Specific Tuning: Some JVM flags are specifically beneficial for certain types of applications. For instance, -XX:+UseStringDeduplication can help reduce the memory footprint for applications that use many duplicate strings.<br>
特定于应用程序的调整：某些 JVM 标志对于某些类型的应用程序特别有利。例如，可以帮助减少使用许多重复字符串的应用程序的内存占用。
<br>Monitoring and Profiling Tools: Utilizing JVM monitoring and profiling tools can help identify performance bottlenecks and appropriate JVM flags for optimization.<br>
监控和分析工具：利用 JVM 监控和分析工具可以帮助识别性能瓶颈和适当的 JVM 标志以进行优化。
<br>JVM optimization is a multifaceted process involving various strategies beyond heap size adjustments and JIT compilation. Effective thread management, the use of efficient algorithms and data structures, and the strategic use of JVM options and flags are all critical components of a comprehensive JVM performance optimization strategy. By employing these techniques, developers and system administrators can significantly enhance the performance and efficiency of Java applications.<br>
JVM 优化是一个多方面的过程，涉及堆大小调整和 JIT 编译之外的各种策略。有效的线程管理、高效算法和数据结构的使用以及 JVM 选项和标志的策略性使用都是全面的 JVM 性能优化策略的关键组成部分。通过采用这些技术，开发人员和系统管理员可以显着提高 Java 应用程序的性能和效率。<br><br>Optimizing the Java Virtual Machine (JVM) is an essential aspect of ensuring the efficient performance of Java applications. Throughout this article, we have explored various strategies, including heap size adjustments, JIT compilation, and other pivotal optimization techniques. Each of these areas offers unique opportunities to enhance the performance and stability of Java applications.<br>
优化 Java 虚拟机 (JVM) 是确保 Java 应用程序高效性能的一个重要方面。在本文中，我们探索了各种策略，包括堆大小调整、JIT 编译和其他关键优化技术。其中每个领域都提供了增强 Java 应用程序性能和稳定性的独特机会。<br>Effective JVM tuning requires a balanced approach, considering factors like memory allocation, garbage collection strategies, thread management, and the utilization of efficient algorithms and data structures. Additionally, the strategic use of JVM options and flags plays a significant role in fine-tuning the JVM environment to meet the specific needs of your application.<br>
有效的 JVM 调优需要采用平衡的方法，考虑内存分配、垃圾收集策略、线程管理以及高效算法和数据结构的利用等因素。此外，JVM 选项和标志的策略性使用在微调 JVM 环境以满足应用程序的特定需求方面发挥着重要作用。<br>By understanding and implementing these optimization techniques, developers and system administrators can significantly improve the efficiency and responsiveness of Java applications. Continuous monitoring, profiling, and adjustment are key to achieving and maintaining an optimally performing JVM.<br>
通过理解和实施这些优化技术，开发人员和系统管理员可以显着提高 Java 应用程序的效率和响应能力。持续监控、分析和调整是实现和维护最佳性能 JVM 的关键。<br>JVM optimization is not a one-size-fits-all solution but a continuous process of analysis, tuning, and re-tuning to adapt to the evolving needs of Java applications. With the insights and strategies discussed, you are well-equipped to embark on this journey of JVM performance enhancement.<br>
JVM 优化不是一种一刀切的解决方案，而是一个持续分析、调整和重新调整的过程，以适应 Java 应用程序不断变化的需求。通过讨论的见解和策略，您已经做好了踏上 JVM 性能增强之旅的准备。<br>
<br><a data-tooltip-position="top" aria-label="https://docs.oracle.com/en/java/" rel="noopener nofollow" class="external-link" href="https://docs.oracle.com/en/java/" target="_blank"><em></em></a>Oracle’s Java Documentation<br>
Oracle 的 Java 文档
<br><a data-tooltip-position="top" aria-label="https://visualvm.github.io/" rel="noopener nofollow" class="external-link" href="https://visualvm.github.io/" target="_blank"><em></em></a>VisualVM视觉虚拟机
<br><a data-tooltip-position="top" aria-label="https://docs.oracle.com/javase/tutorial/essential/concurrency/" rel="noopener nofollow" class="external-link" href="https://docs.oracle.com/javase/tutorial/essential/concurrency/" target="_blank"><em></em></a>Java Concurrency API<br>
Java并发API
]]></description><link>02-编程语言\01-java\06-jvm\000-medium.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/000-medium.md</guid><pubDate>Wed, 24 Jul 2024 02:00:51 GMT</pubDate><enclosure url="https://miro.medium.com/v2/resize:fill:88:88/1*i2BLX3qBID5JabZAYI3EJQ.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://miro.medium.com/v2/resize:fill:88:88/1*i2BLX3qBID5JabZAYI3EJQ.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Java Virtual Machine (JVM) Performance Tuning Tutorial - Sematext]]></title><description><![CDATA[ 
 <br>来源网址: <a rel="noopener nofollow" class="external-link" href="https://sematext.com/blog/jvm-performance-tuning/" target="_blank">https://sematext.com/blog/jvm-performance-tuning/</a><br>裁剪时间: 2024-08-06 14:06:46<br><br>When it comes to Java applications, to make sure they run at peak performance, it’s critical to close the resource gap between the code and the virtual machine it’s running on – if there is one. The way to do that is by peaking into and fine-tuning the Java Virtual Machine (JVM).<br>
当涉及到 Java 应用程序时，为了确保它们以最高性能运行，关键是要缩小代码和运行它的虚拟机之间的资源差距——如果有的话。实现这一点的方法是深入研究并微调 Java 虚拟机(JVM)。<br>However, that’s easier said than done. Many factors can influence <a data-tooltip-position="top" aria-label="https://sematext.com/guides/java-monitoring/" rel="noopener nofollow" class="external-link" href="https://sematext.com/guides/java-monitoring/" target="_blank">JVM performance</a>, and during tuning, you must consider all of them. Though, there are ways around that to make it not be such a pain.<br>In this post, we are going to help you plan and understand&nbsp;how to do JVM tuning by using the JVM parameters and following some performance tuning principles and procedures. Let’s get to it!<br><img alt="JVM performance tuning step by step" src="02-编程语言\01-java\06-jvm\assets\1722924406-738ffdb470d9c0e5edb8e2c7e20a60be.webp"><br><br>  Before diving into JVM tuning, there are a few things you should consider first:<br>
<br>
&nbsp; Cost – considering your environments, you may gain more by adding hardware instead of spending time to tune the JVM.

<br>

<br>成本 * *-考虑到您的环境，您可以通过添加硬件而不是花时间调优 JVM 来获得更多




<br>
&nbsp; Desired outcome&nbsp;– in the long run, it’s more efficient to tune for stability, rather than performance, but they do overlap.<br>
期望的结果——从长远来看，调优稳定性要比调优性能更有效，但它们确实存在重叠

<br>
&nbsp; Ongoing issues – before starting tuning, you should do a thorough check of your system to see if there isn’t an underlying issue somewhere as tuning can delay or hide it temporarily. You can’t do JVM tuning, nor debugging if you’re not monitoring the JVM. Check out what are the critical JVM metrics &nbsp;to monitor and which are the best <a data-tooltip-position="top" aria-label="https://sematext.com/guides/java-monitoring/" rel="noopener nofollow" class="external-link" href="https://sematext.com/guides/java-monitoring/" target="_blank">Java monitoring tools</a>&nbsp;available today.<br>
正在发生的问题——在开始调优之前，您应该彻底检查一下您的系统，看看是否有一个潜在的问题，因为调优可能会延迟或暂时隐藏它。如果不监视 JVM，就不能进行 JVM 调优或调试。看看哪些是需要监视的关键 JVM 指标，哪些是目前可用的最好的

<br>
&nbsp; Memory leaks&nbsp;– they always lead to garbage collection (GC) issues regardless of tuning.<br>
内存泄漏——无论调优与否，它们总是会导致垃圾收集(GC)问题。

<br>Java virtual machine tuning is&nbsp;the process of adjusting the default parameters to match our application needs. This includes simple adjustments like the size of the <a data-tooltip-position="top" aria-label="https://sematext.com/glossary/jvm-heap/" rel="noopener nofollow" class="external-link" href="https://sematext.com/glossary/jvm-heap/" target="_blank">heap</a> , through choosing the right garbage collector to using optimized versions of getters.<br>
Java 虚拟机调优是调整默认参数以满足应用程序需求的过程。这包括一些简单的调整，比如通过选择正确的垃圾收集器来使用优化版本的 getter，来调整堆的大小( <a data-tooltip-position="top" aria-label="https://sematext.com/glossary/jvm-heap/)。" rel="noopener nofollow" class="external-link" href="https://sematext.com/glossary/jvm-heap/)%E3%80%82" target="_blank">https://sematext.com/glossary/jvm-heap/)。</a><br><br>  Although critical, tuning JVM is not enough to ensure optimal performance. For instance, if an app has a badly designed architecture or poorly written code, you can’t expect performance to skyrocket by merely tuning the JVM.<br>Not to mention, once you have the first two optimized, you’d need to get back to the JVM and start it all over again. A well-done tuning looks at the whole system and all the layers that can impact performance, including database and OS.<br>
更不用说，一旦对前两个进行了优化，就需要返回到 JVM 并从头开始。良好的调优将着眼于整个系统和所有可能影响性能的层，包括数据库和操作系统。<br>That said, when you're at the stage of performing JVM tuning, assume that the architecture and code of your project are either optimal or have been tuned. However, before diving into it, you must set performance optimization goals and identify the current performance issues. The goals will serve as a benchmark to compare the app with once it’s optimized and to determine if it needs further intervention.<br>
也就是说，当您处于执行 JVM 调优的阶段时，假设项目的体系结构和代码要么是最优的，要么已经进行了调优。但是，在深入研究之前，必须设置性能优化目标并确定当前的性能问题。这些目标将作为一个基准，以比较应用程序一旦优化，并确定是否需要进一步的干预。<br>Looking to learn more about JVM monitoring with Sematext Cloud? Check out this short video below:<br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=ijkRkMLh_qQ&amp;embeds_referring_euri=https%3A%2F%2Fsematext.com%2F&amp;embeds_referring_origin=https%3A%2F%2Fsematext.com" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=ijkRkMLh_qQ&amp;embeds_referring_euri=https%3A%2F%2Fsematext.com%2F&amp;embeds_referring_origin=https%3A%2F%2Fsematext.com" target="_blank">前往平台观看</a><br><br>Before diving into the step-by-step process, you need to get familiar with some basic concepts that we’ll use further on:<br><br>JVM parameters or JVM arguments are Java-specific values that change the behavior of the Java Virtual Machine.<br>When it comes to JVM tuning, there are few important parameters you should know as you’ll encounter them when configuring, tuning, and improving overall performance of the JVM. <br><br>Whatever you do, when it comes to JVM performance, you will, more than likely, reach a point where you have to initialize the heap memory. The parameters to specify minimum and maximum heap size are:<br>java -Xms4096m -Xmx4096m app.jar
<br>When setting the minimum and maximum heap size of the JVM memory you may want to consider setting them to the same values. That way your heap will not have to be resized saving precious CPU cycles. You may also want to pre-touch all the pages if you are using larger heap by setting the -XX:+AlwaysPreTouch&nbsp;flag to the startup options.<br>
在设置 JVM 内存的最小和最大堆大小时，可能需要考虑将它们设置为相同的值。这样，您的堆就不必调整大小，从而节省宝贵的 CPU 周期。如果要使用更大的堆，可以通过将-XX: + AlwaysPreTouch 标志设置为启动选项来预先触摸所有页面。<br>Starting from Java 8 the Metaspace has replaced the old PermGen memory space. No more java.lang.OutOfMemoryError: PermGen&nbsp;errors, right now we can start <a data-tooltip-position="top" aria-label="https://sematext.com/guides/application-performance-monitoring/" rel="noopener nofollow" class="external-link" href="https://sematext.com/guides/application-performance-monitoring/" target="_blank">monitoring our application</a> logs for java.lang.OutOfMemoryError: Metadata space. By default the class metadata allocation is limited by the amount of available native memory and we have a new option to limit the maximum size of the new memory space introduced with Java 8. But just because the space can grow up to the limits of the native memory it doesn’t mean it is always occupying as much as it can. This region of the JVM memory can be dynamically resized depending on the needs.<br>
从 Java 8开始，Metaspace 取代了原来的 PermGen 内存空间。没有java.lang.OutOfMemoryError: PermGen&nbsp;errors，现在我们可以开始<a data-tooltip-position="top" aria-label="https://sematext.com/guides/application-performance-monitoring/" rel="noopener nofollow" class="external-link" href="https://sematext.com/guides/application-performance-monitoring/" target="_blank">监视我们的应用程序</a> java.lang 的日志。元数据空间。默认情况下，类元数据分配受到可用本机内存数量的限制，我们有一个新选项来限制 Java8引入的新内存空间的最大大小。但是，仅仅因为空间可以发展到本机内存的限制，并不意味着它总是占用尽可能多的空间。JVM 内存的这个区域可以根据需要动态调整大小。<br>The following properties exposed by the JVM allow us to control the Metaspace:<br>
<br>
&nbsp; -XX:MaxMetaspaceSize&nbsp;– unlimited by default, sets the maximum amount of native memory that can be allocated for the class metadata.

<br>
&nbsp; -XX:MetaspaceSize&nbsp;– sets the size of the allocated class metadata above which the first garbage collection will be triggered. Default value is platform dependent.

<br>
&nbsp; -XX:MinMetaspaceFreeRatio&nbsp;– minimum percentage of the Metaspace memory region that needs to be available after garbage collection. If the amount of memory left is below the threshold the Metaspace region will be resized.

<br>
&nbsp; -XX:MaxMetaspaceFreeRatio&nbsp;– maximum percentage of the Metaspace memory region that needs to be available after the garbage collection. If the amount of memory left is above the threshold the Metaspace region will be resized.

<br>Keep in mind that monitoring Metaspace region of the memory may be a very good idea as high garbage collection work in this memory region may indicate memory leaks in classes or classloaders.<br>
请记住，监视内存的 Metaspace 区域可能是一个非常好的主意，因为该内存区域中的高垃圾收集工作可能表明类或类加载器中存在内存泄漏<br>Delving deeper, it’s important to take note of memory allocation parameters as well as you’ll need them during tuning. They are as follows: <br>
<br>
&nbsp; -XX:NewSize&nbsp;sets the initial size of young generation space

<br>
&nbsp; -XXMaxNewSize&nbsp;states the maximum size of young generation space

<br>
&nbsp; -Xmn specifies the size of the entire young generation space, meaning eden and the two survivor spaces

<br>You will use these parameters to calculate aspects regarding the old generation space size:<br>
<br>
&nbsp; The size of the old generation is automatically set based on the size of the young generation space

<br>
&nbsp; The initial old generation space equals the -Xmx&nbsp;value minus the -XX:NewSize&nbsp;value

<br>
&nbsp; The minimum size of the old generation space equals &nbsp;the -Xmx value minus the -XX:MaxNewSize&nbsp;value

<br><br><a data-tooltip-position="top" aria-label="https://sematext.com/blog/java-lang-outofmemoryerror/" rel="noopener nofollow" class="external-link" href="https://sematext.com/blog/java-lang-outofmemoryerror/" target="_blank">Java OutOfMemoryError</a> is probably every <a data-tooltip-position="top" aria-label="https://sematext.com/glossary/devops/" rel="noopener nofollow" class="external-link" href="https://sematext.com/glossary/devops/" target="_blank">DevOps</a>’ worst nightmare. You find yourself facing an app crash that is difficult to replicate and diagnose. Unfortunately, it’s quite frequent with large applications. Fortunately, JVM has parameters that write heap memory on a file that you can later use to troubleshoot.<br>-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof
-XX:OnOutOfMemoryError="&lt;cmd args&gt;;&lt;cmd args&gt;"
-XX:+UseGCOverheadLimit
<br>
<br>
&nbsp; HeapDumpOnOutOfMemoryError commands the JVM to dump heap to a physical file when java.lang.OutOfMemoryError is thrown

<br>
&nbsp; HeapDumpPath&nbsp;specifies the path to directory or filename

<br>
&nbsp; OnOutOfMemoryError is used to run emergency user-defined commands when an OutOfMemoryError&nbsp;first occurs

<br>
&nbsp; UseGCOverheadLimit&nbsp;is a policy that limits the proportion of the VM’s time that is spent in GC before an OutOfMemoryError is thrown

<br><br>JVM has four garbage collector implementations: <br>
<br>
&nbsp; Serial Garbage Collector -XX:+UseSerialGC

<br>
&nbsp; Parallel Garbage Collector -XX:+UseParallelGC

<br>
&nbsp; CMS Garbage Collector -XX:+UseConcMarkSweepGC

<br>
&nbsp; G1 Garbage Collector -XX:+UseG1GC

<br>The first two garbage collectors are dedicated to work in the area of young generation heap space, while the CMS and G1 garbage collectors are dedicated for the old generation space. <br>Read more about this in our article about how <a data-tooltip-position="top" aria-label="https://sematext.com/blog/java-garbage-collection/" rel="noopener nofollow" class="external-link" href="https://sematext.com/blog/java-garbage-collection/" target="_blank">Java garbage collection</a> works.  <br><br>Garbage Collection performance is closely related to JVM and app performance. When the garbage collector is not able to clear the memory it works more and more eventually leading to stop the world events or even out of memory situations. We want to avoid such situations as much as possible. To be able to do that we need to be able to observe what JVM garbage collector is doing. One of the best ways to monitor GC performance is to look at <a data-tooltip-position="top" aria-label="https://sematext.com/blog/java-garbage-collection-logs/" rel="noopener nofollow" class="external-link" href="https://sematext.com/blog/java-garbage-collection-logs/" target="_blank">GC logs</a>. You can log GC activity with the following commands:<br>-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=&lt;number of log files&gt;
-XX:GCLogFileSize=&lt;file size&gt;[unit]
-Xloggc:/path/to/gc.log
<br>
<br>&nbsp; -XX:+UseGCLogFileRotation&nbsp;specifies the log file rotation policy
<br>&nbsp; -XX:NumberOfGCLogFiles&nbsp;states the maximum number of log files to use when rotating logs
<br>&nbsp; -XX:GCLogFileSize&nbsp;refers to the maximum size of the <a data-tooltip-position="top" aria-label="https://sematext.com/glossary/log-file/" rel="noopener nofollow" class="external-link" href="https://sematext.com/glossary/log-file/" target="_blank">log file</a>
<br>&nbsp; -Xloggc&nbsp;specifies where the file is located
<br>There are also additional &nbsp;JVM parameters important for <a data-tooltip-position="top" aria-label="https://sematext.com/blog/java-garbage-collection-logs/" rel="noopener nofollow" class="external-link" href="https://sematext.com/blog/java-garbage-collection-logs/" target="_blank">GC logging</a>. For example:  <br>
<br>&nbsp; -XX:+PrintGCDetails – includes additional details in the garbage collector log
<br>&nbsp; -XX:+PrintGCDateStamps – prints date stamps to the log
<br>&nbsp; -XX:+PrintGCTimeStamps&nbsp;– prints the timestamps to the log
<br>&nbsp; -XX:+PrintTenuringDistribution&nbsp;– adds information about tenuring age information to the log
<br>&nbsp; -XX:+PrintGCApplicationStoppedTime&nbsp;– includes information about how much time the application was stopped at safepoint which are commonly caused by stop the world garbage collection
<br><br>
<br>&nbsp; -XX:+UseStringDeduplication&nbsp;eliminates duplicate string value to a single instance to reduce unnecessary memory usage.
<br>&nbsp; -XX:+UseLWPSynchronization&nbsp;enables LWP (Light Weight Process) – based instead of thread-based synchronization.
<br>&nbsp; -XX:LargePageSizeInBytes&nbsp;sets the large page size used for the Java heap. Have in mind, though, that while larger page sizes allow for more efficient use of memory hardware, this may lead to larger space sizes for Metaspace, which can force you to reduce the size of the Java heap space.
<br>&nbsp; -XX:MaxHeapFreeRatio&nbsp;enables the maximum percentage of heap free after GC to avoid shrinking.
<br>&nbsp; -XX:MinHeapFreeRatio&nbsp;enables the minimum percentage of heap free after GC to avoid expansion.
<br>&nbsp; -XX:SurvivorRatio&nbsp;sets the ratio of eden/survivor space size.
<br>&nbsp; -XX:+UseLargePages&nbsp;use large page memory.
<br>&nbsp; -XX:+UseStringCache&nbsp;enables caching of commonly allocated strings.
<br>&nbsp; -XX:+UseCompressedStrings&nbsp;use a byte[] type for String objects, which can be represented in pure ASCII format.
<br>&nbsp; -XX:+OptimizeStringConcat&nbsp;optimizes String concatenation operations where possible.
<br><br>Before you start tuning the JVM for performance, you first have to set performance goals. You will set values for these goals later on:<br>
<br>&nbsp; Latency is the amount of time required to run a garbage collection event.
<br>&nbsp; Throughput&nbsp;is the percentage of time the VM spends executing the application versus time spent performing garbage collection.
<br>&nbsp; Footprint&nbsp;is the amount of memory required by the garbage collector to run smoothly.
<br>However, you can’t focus on all three goals at once, as any performance gain from any of them results in a performance loss of the other one or two. For example:<br>
<br>&nbsp; High throughput and low latency results in higher memory usage.
<br>&nbsp; High throughput and low memory usage results in higher latency.
<br>&nbsp; Low latency and low memory usage results in lower throughput.
<br>You have to decide which two are the most relevant to your app while you consider your business needs. Either way, the goal of JVM tuning is to optimize the garbage collector so that you have high throughput with less memory consumption and low latency. However, less memory/low latency does not automatically mean that the less or lower the memory or latency is, the better the performance. That depends on which metrics you choose to keep an eye on.<br><br>When performing performance tuning, have in mind the following principles as they make garbage collection easier.<br>
<br>&nbsp; Minor GC collection&nbsp;– implies that Minor GC should collect as many dead objects as possible to reduce the frequency of Full GC.
<br>&nbsp; GC memory maximization&nbsp;– it says that the more memory the GC can access during a cycle, the more efficient the cleanup and the lower the collection frequency.
<br>&nbsp; Two out of three&nbsp;– as stated above, you need to pick two out of the three performance goals.
<br><br>1.Observation<br>
2.Determine Memory Footprint<br>
3.Tuning for Latency<br>
4.Tuning for Throughput<br>First, what you need to have in mind is that Java VM tuning can’t solve all performance issues. Therefore, it should be done only necessary. That said, tuning is a lengthy process where you’ll more than likely perform ongoing configuration optimizations and multiple iterations based on the stress and benchmark tests results. Before meeting the desired metric, you may also need to tune parameters many times, thus running the tests all over again.  <br>As a general rule, tuning should first meet the memory usage requirements, latency, and finally, throughput, as you’ll see in the following sections.<br>We are going to use the default parallel garbage collector (or throughput collector) in JDK, which you can enable with -XX:+UseParallelGC. This flag enables a parallel version of both the young- and old-generation collectors. You can check the defaults for your Java version by running java -XX:+PrintCommandLineFlags -version. You can also check the serial garbage collector by using the -XX:+UseSerialGC. The serial collector is a single-thread collector, while the parallel collector is a multiple-thread collector.<br><br>Once you know all of the above, here&nbsp;are the steps you need to take to perform JVM tuning:<br><br>To determine the memory usage, you first need to know the size of the active data. The size of the active data is the amount of Java heap that is occupied by data that was active since the application entered the steady stage.<br><br>Active data has to be measured in a stable state instead of the start-up phase. In the start-up phase, the JVM loads and launches the app’s main modules and data; thus, the JVM parameters are not yet stable.<br>On the other hand, the stable phase implies that an app has already been running for some time and underwent a stress test. More specifically, an app is in a stable phase when it reaches a workload that meets the requirements at the business peak in the production environment and stays steady after the peak is reached. Only then every JVM performance parameter is in a stable state.<br><br>Make sure to perform the tests with the default JVM parameters as it allows you to see how much memory the app requires while in the stable phase. The Full GC<br>Once the app is running in a stable state, you have to estimate the memory footprint based on the average old and permanent occupancy, you can see with Full GC logs during stable state periods. You can also use the longest Full GC for estimation.<br>GC logs are one of the best ways to gather meaningful and rich data to help with tuning. Enabling GC logs doesn’t affect performance. Therefore you can use them even in production environments to detect issues.<br>Use the following command-line to turn on Full GC logs:<br>
-XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:&lt;filename&gt;

<br>However, if there are no Full GC logs available, you can use monitoring tools to call for them or the following command to enable them:<br>jmap -histo:live pid
<br>Either way, you get information similar to:<br>
0.134: [GC (Allocation Failure) [PSYoungGen: 65536K-&gt;10720K(76288K)] 65536K-&gt;40488K(251392K), 0.0190287 secs] [Times: user=0.13 sys=0.04, real=0.02 secs]

0.193: [GC (Allocation Failure) [PSYoungGen: 71912K-&gt;10752K(141824K)] 101680K-&gt;101012K(316928K), 0.0357512 secs] [Times: user=0.27 sys=0.06, real=0.04 secs]

0.374: [GC (Allocation Failure) [PSYoungGen: 141824K-&gt;10752K(141824K)] 232084K-&gt;224396K(359424K), 0.0809666 secs] [Times: user=0.58 sys=0.12, real=0.08 secs]

0.455: [Full GC (Ergonomics) [PSYoungGen: 10752K-&gt;0K(141824K)] [ParOldGen: 213644K-&gt;215361K(459264K)] 224396K-&gt;215361K(601088K), [Metaspace: 2649K-&gt;2649K(1056768K)], 0.4409247 secs] [Times: user=3.46 sys=0.02, real=0.44 secs]

0.984: [GC (Allocation Failure) [PSYoungGen: 131072K-&gt;10752K(190464K)] 346433K-&gt;321225K(649728K), 0.1407158 secs] [Times: user=1.28 sys=0.08, real=0.14 secs]

1.168: [GC (System.gc()) [PSYoungGen: 60423K-&gt;10752K(190464K)] 370896K-&gt;368961K(649728K), 0.0676498 secs] [Times: user=0.53 sys=0.05, real=0.06 secs]

1.235: [Full GC (System.gc()) [PSYoungGen: 10752K-&gt;0K(190464K)] [ParOldGen: 358209K-&gt;368152K(459264K)] 368961K-&gt;368152K(649728K), [Metaspace: 2652K-&gt;2652K(1056768K)], 1.1751101 secs] [Times: user=10.64 sys=0.05, real=1.18 secs]

2.612: [Full GC (Ergonomics) [PSYoungGen: 179712K-&gt;0K(190464K)] [ParOldGen: 368152K-&gt;166769K(477184K)] 547864K-&gt;166769K(667648K), [Metaspace: 2659K-&gt;2659K(1056768K)], 0.2662589 secs] [Times: user=2.14 sys=0.00, real=0.27 secs]

<br>We can see several operations performed by our JVM version 8. Let’s look at one of the lines here that described the Full GC&nbsp;event performed on purpose from our test code by using the System.gc()&nbsp;method:<br>
1.235: [Full GC (System.gc()) [PSYoungGen: 10752K-&gt;0K(190464K)] [ParOldGen: 358209K-&gt;368152K(459264K)] 368961K-&gt;368152K(649728K), [Metaspace: 2652K-&gt;2652K(1056768K)], 1.1751101 secs] [Times: user=10.64 sys=0.05, real=1.18 secs]

<br>As you can see there is a lot of information in a single line describing the Full GC event. Apart from the event type we see what was happening in the young generation space [PSYoungGen: 10752K-&gt;0K(190464K)], what was happening in the old generation space, [ParOldGen: 358209K-&gt;368152K(459264K)], what was happening in the Metaspace region of memory [Metaspace: 2652K-&gt;2652K(1056768K)], the total memory difference 368961K-&gt;368152K(649728K)&nbsp;and finally the time the whole operation took: [Times: user=10.64 sys=0.05, real=1.18 secs].<br>The information about young generation garbage collector work tells us that after the young generation garbage collection event the space went down from 10752K to 0K and the total allocated young generation space is 190464K.<br>The old generation garbage collector started with the memory usage at 358209K and after its work finished with 368152K. The total memory allocated to old generation space is 459264K. This means that this GC cycle didn’t end up freeing too much old generation space.<br>After the whole garbage collection was done we ended up with 368152K memory starting from the initial 368961K and the whole memory space occupied was 649728K.<br>The Metaspace region of the memory started and ended with the same memory usage 2652K and the whole region occupies 1056768K.<br>Finally, it took JVM 1.18 seconds to perform the whole garbage collection operation. The user=10.64 section tells us the amount of CPU time spent in user-mode code outside of the operating system kernel. The sys=0.05 section is the CPU time spent inside the kernel within the process itself, which means how long the CPU spent executing system-related calls.<br>As you can see a single garbage collector log line can give us a lot of insight into what happened, how much memory was released, and how long the whole operation took.<br><br>Once the memory footprint established, the next step is latency tuning. At this stage, heap memory size and latency don’t meet application requirements. Therefore, a new debugging is needed with the actual requirements that the app has. You might have to tune the heap size again, determine GC duration and frequency, and decide if you need to switch to another garbage collector.<br><br>Previously, we’ve mentioned performance goals, but we didn’t set values for them. These goals serve as system latency requirements you need to meet after tuning. The metrics that help get there are:<br>
<br>
&nbsp; Acceptable average Minor GC frequency, which you’ll compare with the number of Minor GCs.

<br>
&nbsp; Acceptable maximum Full GC pause, which you’ll compare with the longest Full GC cycle.

<br>
&nbsp; Acceptable frequency of maximum Full GC pause, which you’ll compare with the highest frequency of the Full GC.

<br>
&nbsp; Acceptable average Minor GC pause, which you’ll compare with the Minor GC duration.

<br>You can get this data by optimizing the young generation and old generation size, respectively. You can read more about it in our guide to garbage collection tuning.<br><br>In the final step of JVM performance tuning, we run throughput tests on the results we got so far and then make slight adjustments if needed.<br>Based on tests and overall application requirements, an app should have a set throughput metric. When this goal is met or exceeded even, you can stop the tuning.<br>However, if after optimization, you still can’t reach the throughput goal, you need to get back to it and assess the gap between the throughput requirement and the current throughout. If the gap is around 20%, you can change the parameters, increase memory, and debug the application again. However, if the gap is larger than 20%, you need to review the throughput goal as the throughput goal, and the design may not meet the requirements of the whole Java application.<br>For a garbage collection, throughput tuning has two purposes: to minimize the number of objects passed to the old area and decrease Full GC execution time or Stop-the-World events. These can lead to low throughput.<br><br>JVM performance tuning is a complex process that requires a methodical approach and a clear idea of the desired performance outcomes, as you’ve noticed in this JVM tuning guide. The default JVM tunings do a great job of improving application performance and making sure it’s stable in most situations. On the other hand, depending on how your app handles the required workload, the basic initial JVM parameters may not be enough. In that case, you’ll have to benchmark your app and tune the JVM to reach an appropriate set of parameters.<br><a data-tooltip-position="top" aria-label="https://apps.sematext.com/ui/registration" rel="noopener nofollow" class="external-link" href="https://apps.sematext.com/ui/registration" target="_blank">Start Free Trial</a>]]></description><link>02-编程语言\01-java\06-jvm\0001.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/0001.md</guid><pubDate>Tue, 06 Aug 2024 07:00:33 GMT</pubDate><enclosure url="02-编程语言\01-java\06-jvm\assets\1722924406-738ffdb470d9c0e5edb8e2c7e20a60be.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\06-jvm\assets\1722924406-738ffdb470d9c0e5edb8e2c7e20a60be.webp&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-JVM启动参数]]></title><description><![CDATA[ 
 <br><br>这些参数是 Java 虚拟机启动参数，具体含义如下：<br>
<br>-Xms: Java 虚拟机启动时的最小堆大小，即 Java 程序的最小内存使用量。这里设置为 512m，表示最小堆大小为 512MB。
<br>-Xmx: Java 虚拟机最大可用的堆内存大小，即 Java 程序所能使用的最大内存。这里设置为 1024m，表示最大堆大小为 1024MB。
<br>-XX:PermSize: 指定永久代（PermGen）的初始内存大小。在 JDK 8 及之前版本的 Java 虚拟机中，Java 类、方法、常量等信息都存放在永久代中。这里设置为 256M，表示永久代的初始大小为 256MB。
<br>-XX:MaxPermSize: 指定永久代的最大内存大小。这里设置为 512m，表示永久代的最大内存大小为 512MB。
<br>-XX:MaxNewSize: 指定新生代（YoungGen）的最大内存大小。在 Java 虚拟机中，新生代用于存放新生成的对象，而老年代（OldGen）则用于存放生命周期较长的对象。这里设置为 256m，表示新生代的最大内存大小为 256MB。
<br>这些参数可以根据应用程序的需要进行调整，以达到最优的性能和内存使用效率。一般来说，增加内存可以提高应用程序的性能，但需要注意不能将堆内存设置过大，以避免导致 Java 程序运行过程中出现内存溢出等问题。]]></description><link>02-编程语言\01-java\06-jvm\01-jvm启动参数.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/01-JVM启动参数.md</guid><pubDate>Wed, 10 Apr 2024 07:03:04 GMT</pubDate></item><item><title><![CDATA[02-内存分配]]></title><description><![CDATA[ 
 ]]></description><link>02-编程语言\01-java\06-jvm\02-内存分配.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/02-内存分配.md</guid><pubDate>Wed, 10 Apr 2024 07:03:06 GMT</pubDate></item><item><title><![CDATA[03-垃圾回收]]></title><description><![CDATA[ 
 ]]></description><link>02-编程语言\01-java\06-jvm\03-垃圾回收.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/03-垃圾回收.md</guid><pubDate>Wed, 10 Apr 2024 07:03:09 GMT</pubDate></item><item><title><![CDATA[04-类加载机制]]></title><description><![CDATA[ 
 ]]></description><link>02-编程语言\01-java\06-jvm\04-类加载机制.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/04-类加载机制.md</guid><pubDate>Wed, 10 Apr 2024 07:03:11 GMT</pubDate></item><item><title><![CDATA[www.baidu.com]]></title><description><![CDATA[ 
 ]]></description><link>02-编程语言\01-java\06-jvm\www.baidu.com.html</link><guid isPermaLink="false">02-编程语言/01-JAVA/06-jvm/www.baidu.com.md</guid><pubDate>Tue, 06 Aug 2024 06:21:18 GMT</pubDate></item><item><title><![CDATA[01-附件预览(office转html)]]></title><description><![CDATA[ 
 <br>demo:<br>
<a rel="noopener nofollow" class="external-link" href="https://github.com/wangrongjia/online-preview" target="_blank">https://github.com/wangrongjia/online-preview</a><br>参考：<br>
<a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/139287354" target="_blank">https://zhuanlan.zhihu.com/p/139287354</a><br><br>但是iceblue将excel转化成html文件时 有内存溢出的问题 我使用的版本<br>
<img src="02-编程语言\01-java\99-实践\assets\pasted-image-20231128173911.png">]]></description><link>02-编程语言\01-java\99-实践\01-附件预览(office转html).html</link><guid isPermaLink="false">02-编程语言/01-JAVA/99-实践/01-附件预览(office转html).md</guid><pubDate>Wed, 10 Apr 2024 07:03:14 GMT</pubDate><enclosure url="02-编程语言\01-java\99-实践\assets\pasted-image-20231128173911.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;02-编程语言\01-java\99-实践\assets\pasted-image-20231128173911.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-国内镜像]]></title><description><![CDATA[ 
 <br>windows下，直接在 C:\Users\Administrator 目录中创建一个pip目录，再新建文件pip.ini，填入以下代码。<br># pip.ini
 
[global]
index-url = https://pypi.tuna.tsinghua.edu.cn/simple  # 设置源地址
[install]
trusted-host = pypi.tuna.tsinghua.edu.cn    # 信任此网站
<br>国内源地址：<br>
清华：<a rel="noopener nofollow" class="external-link" href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>阿里云：<a rel="noopener nofollow" class="external-link" href="https://mirrors.aliyun.com/pypi/simple/" target="_blank">https://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a rel="noopener nofollow" class="external-link" href="https://pypi.mirrors.ustc.edu.cn/simple/" target="_blank">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>华中理工大学：<a rel="noopener nofollow" class="external-link" href="http://pypi.hustunique.com/" target="_blank">http://pypi.hustunique.com/</a><br>山东理工大学：<a rel="noopener nofollow" class="external-link" href="http://pypi.sdutlinux.org/" target="_blank">http://pypi.sdutlinux.org/</a> <br>豆瓣：<a rel="noopener nofollow" class="external-link" href="http://pypi.douban.com/simple/" target="_blank">http://pypi.douban.com/simple/</a>]]></description><link>02-编程语言\02-python\01-国内镜像.html</link><guid isPermaLink="false">02-编程语言/02-python/01-国内镜像.md</guid><pubDate>Tue, 29 Aug 2023 03:20:40 GMT</pubDate></item><item><title><![CDATA[01-white-space]]></title><description><![CDATA[ 
 <br><br>&lt;style&gt;
p {
  width: 100px;
  background: red;
}	
&lt;/style&gt;
&lt;p&gt;  hellohellohello hello
world
&lt;/p&gt;
<br><br><br><br><br><a rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/white-space" target="_blank">https://developer.mozilla.org/en-US/docs/Web/CSS/white-space</a>]]></description><link>03-web\02-css\01-white-space.html</link><guid isPermaLink="false">03-web/02-css/01-white-space.md</guid><pubDate>Wed, 10 Apr 2024 07:03:25 GMT</pubDate></item><item><title><![CDATA[class]]></title><description><![CDATA[ 
 <br><br>来源 ：<a rel="noopener nofollow" class="external-link" href="https://es6.ruanyifeng.com/" target="_blank">https://es6.ruanyifeng.com/</a><br><br>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子<br>function Point(x, y) {
  this.x = x;
  this.y = y;
}
Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};
var p = new Point(1, 2);
<br>上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。<br>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。<br>基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样。<br>class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }

typeof Point // "function"
Point === Point.prototype.constructor // true
}
<br>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。<br>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。<br><br>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。<br>class Foo {
  constructor() {
    return Object.create(null);
  }
}

new Foo() instanceof Foo
// false
<br>类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。<br>point.hasOwnProperty('x') // true
point.hasOwnProperty('y') // true
point.hasOwnProperty('toString') // false
Point.hasOwnProperty('toString') //false
point.__proto__.hasOwnProperty('toString') // true
<br><br>和函数表达式一样  var f = function () {...} //var f = function ff(){...}<br>const MyClass = class {
...
}
<br>利用class表达式  可以写出立即执行的class<br>let p = new class{
    constructor(name)}{
       this.name=name;     
   }
}('123');
<br><br>类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。？？？<br>class Logger {
  printName(name = 'there') {
    this.print(`Hello ${name}`);
  }

  print(text) {
    console.log(text);
  }
}

const logger = new Logger();
const { printName } = logger;
printName(); // TypeError: Cannot read property 'print' of undefined
<br>上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。<br>一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。<br>class Logger {
  constructor() {
    this.printName = this.printName.bind(this);
  }

  // ...
}
<br>另一种解决方法是使用箭头函数。<br>class Logger {
  constructor() {
    this.printName = (name = 'there') =&gt; {
      this.print(`Hello ${name}`);
    };
  }

  // ...
}
## Class 的取值函数（getter）和存值函数（setter）

与 ES5 一样，在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

```javascript
class MyClass {
  constructor() {
    // ...
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: '+value);
  }
}

let inst = new MyClass();

inst.prop = 123;
// setter: 123

inst.prop
// 'getter'
<br>上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。<br>存值函数和取值函数是设置在属性的 Descriptor 对象上的。<br>class CustomHTMLElement {
  constructor(element) {
    this.element = element;
  }

  get html() {
    return this.element.innerHTML;
  }

  set html(value) {
    this.element.innerHTML = value;
  }
}

var descriptor = Object.getOwnPropertyDescriptor(
  CustomHTMLElement.prototype, "html"
);

"get" in descriptor  // true
"set" in descriptor  // true
<br>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与 ES5 完全一致。<br><br>如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数。<br>class Foo {
  constructor(...args) {
    this.args = args;
  }
  * [Symbol.iterator]() {
    for (let arg of this.args) {
      yield arg;
    }
  }
}

for (let x of new Foo('hello', 'world')) {
  console.log(x);
}
// hello
// world
<br>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个 Generator 函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for...of循环会自动调用这个遍历器。<br><br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br>class Foo {
  static classMethod() {
    return 'hello';
  }
}

Foo.classMethod() // 'hello'

var foo = new Foo();
foo.classMethod()
// TypeError: foo.classMethod is not a function
<br>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<br>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。<br>class Foo {
  static bar () {
    this.baz();
  }
  static baz () {
    console.log('hello');
  }
  baz () {
    console.log('world');
  }
}

Foo.bar() // hello
<br>上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。<br>父类的静态方法，可以被子类继承。<br>class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
}

Bar.classMethod() // 'hello'
<br>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。<br>静态方法也是可以从super对象上调用的。<br>class Foo {
  static classMethod() {
    return 'hello';
  }
}

class Bar extends Foo {
  static classMethod() {
    return super.classMethod() + ', too';
  }
}

Bar.classMethod() // "hello, too"
<br>没有静态属性  constructor里定义实例属性<br><br>new是从构造函数生成实例对象的命令。ES6 为new命令引入了一个new.target属性，该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。<br>function Person(name) {
  if (new.target !== undefined) {
    this.name = name;
  } else {
    throw new Error('必须使用 new 命令生成实例');
  }
}

// 另一种写法
function Person(name) {
  if (new.target === Person) {
    this.name = name;
  } else {
    throw new Error('必须使用 new 命令生成实例');
  }
}

var person = new Person('张三'); // 正确
var notAPerson = Person.call(person, '张三');  // 报错
<br>上面代码确保构造函数只能通过new命令调用。<br>Class 内部调用new.target，返回当前 Class。<br>class Rectangle {
  constructor(length, width) {
    console.log(new.target === Rectangle);
    this.length = length;
    this.width = width;
  }
}

var obj = new Rectangle(3, 4); // 输出 true
<br>需要注意的是，子类继承父类时，new.target会返回子类。<br>class Rectangle {
  constructor(length, width) {
    console.log(new.target === Rectangle);
    // ...
  }
}

class Square extends Rectangle {
  constructor(length) {
    super(length, length);
  }
}

var obj = new Square(3); // 输出 false
<br>上面代码中，new.target会返回子类。<br>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。<br>class Shape {
  constructor() {
    if (new.target === Shape) {
      throw new Error('本类不能实例化');
    }
  }
}

class Rectangle extends Shape {
  constructor(length, width) {
    super();
    // ...
  }
}

var x = new Shape();  // 报错
var y = new Rectangle(3, 4);  // 正确
<br>上面代码中，Shape类不能被实例化，只能用于继承。<br>注意，在函数外部，使用new.target会报错。]]></description><link>03-web\03-javascript\01-es6\01-class.html</link><guid isPermaLink="false">03-web/03-javascript/01-ES6/01-class.md</guid><pubDate>Wed, 10 Apr 2024 07:03:29 GMT</pubDate></item><item><title><![CDATA[use strict]]></title><description><![CDATA[ 
 <br>来源 ：<a rel="noopener nofollow" class="external-link" href="https://es6.ruanyifeng.com/" target="_blank">https://es6.ruanyifeng.com/</a><br><br><a rel="noopener nofollow" class="external-link" href="http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html" target="_blank">http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html</a><br><a rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/" target="_blank">https://developer.mozilla.org/</a><br>
严格模式下, delete运算符后跟随非法标识符(即delete 不存在的标识符)，会抛出语法错误； 非严格模式下，会静默失败并返回false<br>
严格模式中，对象直接量中定义同名属性会抛出语法错误； 非严格模式不会报错<br>
严格模式中，函数形参存在同名的，抛出错误； 非严格模式不会<br>
严格模式不允许八进制整数直接量（如：023）<br>
严格模式中，arguments对象是传入函数内实参列表的静态副本；非严格模式下，arguments对象里的元素和对应的实参是指向同一个值的引用  
<br>let a = 0
function f(a){
	a = 1;
	console.log(arguments[0]);
}
function fu(a){
	'use strict';
	a = 2;
	console.log(arguments[0]);
}
f(a);    //1
fu(a);    //0
<br>
严格模式中 eval和arguments当做关键字，它们不能被赋值和用作变量声明<br>
严格模式会限制对调用栈的检测能力，访问arguments.callee.caller会抛出异常<br>
严格模式 变量必须先声明，直接给变量赋值，不会隐式创建全局变量，不能用with,<br>
严格模式中 call apply传入null undefined保持原样不被转换为window  
<br>var name = '1';
function P(name) {
	this.name = name;
}
function f(){
	console.log('f',this.name);
}
function fu(){
	'use strict';
	console.log('fu',this.name);
}
P.prototype['f'] = f;
P.prototype['fu']=fu;
var p = new P('2');
p.f.call(null);   //1
p.fu.call(null);	//Uncaught TypeError: Cannot read property 'name' of null
]]></description><link>03-web\03-javascript\01-es6\02-严格模式.html</link><guid isPermaLink="false">03-web/03-javascript/01-ES6/02-严格模式.md</guid><pubDate>Wed, 10 Apr 2024 07:03:31 GMT</pubDate></item><item><title><![CDATA[03-数组]]></title><description><![CDATA[ 
 <br>来源 ：<a rel="noopener nofollow" class="external-link" href="https://es6.ruanyifeng.com/" target="_blank">https://es6.ruanyifeng.com/</a><br><br><br>扩展运算符（spread）是三个点（...），将一个数组转为用逗号分隔的参数序列<br>
console.log(...[1, 2, 3])

<br><br>es5中将数组转化为参数序列的写法<br>
// ES5 的写法

function f(x, y, z) {

  // ...

}

var args = [0, 1, 2];

f.apply(null, args);

<br>求数组最大值<br>
//es5

Math.max.apply(null,[4,8,19]);

//es6

Math.max(...[4,8,19]);

<br><br>(1)复制合并数组<br>都是浅拷贝<br>(2)任何实现Iterator接口的对象，都可以使用拓展运算符转化成数组<br>[... xxx ] 比如Map,Set,Generator<br>(3)字符串<br>将字符串转化成数组，能够正确识别字符串的长度<br>
console.log('x\uD83D\uDE80y'); //x🚀y

console.log([...'x\uD83D\uDE80y'].length); //3

<br><br>将类数组对象（array-like object）和 iterable 对象（实现iterator接口）转化成数组对象<br>
let arrayLike = {

    '0': 'a',

    '1': 'b',

    '2': 'c',

    length: 3

};

// ES5的写法

var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']

// ES6的写法

let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']

<br>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 &nbsp;<br>
document.querySelectorAll('div')  //NodeList集合

<br>上面说到，拓展运算符也可以将某些数据结构转化成数组，它们有什么区别呢?扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。<br>
[...{length: 3}]; //Uncaught TypeError: {(intermediate value)} is not iterable

    Array.from({ length: 3 });

// [ undefined, undefined, undefined ]

<br>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。<br>
const toArray = (() =&gt;

  Array.from ? Array.from : obj =&gt; [].slice.call(obj)

)();

<br>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。<br>
Array.from(arrayLike, x =&gt; x * x);

// 等同于

Array.from(arrayLike).map(x =&gt; x * x);

<br><br>正确计算字符串的长度<br>
function countSymbols(string) {

  return Array.from(string).length;

}

<br><br>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<br>find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。<br>
[1, 5, 10, 15].find(function(value, index, arr) {

  return value &gt; 9;

}) // 10

<br>findIndex()返回的是索引 &nbsp;这两个方法都可以接受第二个参数 &nbsp;用来绑定回调函数的this对象<br>
function f(v){

  return v &gt; this.age;

}

let person = {name: 'John', age: 20};

[10, 12, 26, 15].find(f, person);    // 26

<br><br>
let a = {name: '123'};

let b = {0: '456'};

console.log(a['name']);

console.log(b[0]); //字典结构的假象

<br>for ... of 遍历 &nbsp; 或者next()方法遍历 &nbsp;<br>next()方法done属性为true ... false<br><br>includes(value,startIndex) 第二个参数可选<br>和之前的indexOf相比 &nbsp;直接得到bool值，不需要用 &gt;-1 判断 &nbsp;NaN 也可以识别 &nbsp;<br>
[NaN].includes(Nan); //true

<br><br>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 &nbsp;<br>flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。 &nbsp;<br>如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。 &nbsp;<br>如果原数组有空位，flat()方法会跳过空位,不保留空位<br>flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。<br>
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()

[2, 3, 4].flatMap((x) =&gt; [x, x * 2])

// [2, 4, 3, 6, 4, 8]

]]></description><link>03-web\03-javascript\01-es6\03-数组.html</link><guid isPermaLink="false">03-web/03-javascript/01-ES6/03-数组.md</guid><pubDate>Wed, 10 Apr 2024 07:03:33 GMT</pubDate></item><item><title><![CDATA[structuredClone(浏览器自带)]]></title><description><![CDATA[ 
 <br><br><a rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone" target="_blank">https://developer.mozilla.org/en-US/docs/Web/API/structuredClone</a>]]></description><link>03-web\03-javascript\02-深拷贝.html</link><guid isPermaLink="false">03-web/03-javascript/02-深拷贝.md</guid><pubDate>Tue, 29 Aug 2023 08:52:01 GMT</pubDate></item><item><title><![CDATA[小技巧]]></title><description><![CDATA[ 
 <br><br>devtool一些小技巧可以让开发效率大幅度提升，在开发插件过程中我又发现一个小技巧：它就是编译代码块的功能，因为插件开发api文档过于简陋，所有示例也没有描述。所以我只能通过在devtool的命令面板来敲命令来看看某个方法有什么参数，某个类有什么属性，返回值是什么？但有一个难题如果是循环语句这种代码块我直接敲出来会报错，所以我在网上找到可以通过在source面板新建snippet来实现对代码块的运行<br><img src="03-web\04-浏览器\01-chrome\assets\snippet.jpg">]]></description><link>03-web\04-浏览器\01-chrome\01-devtool.html</link><guid isPermaLink="false">03-web/04-浏览器/01-chrome/01-devtool.md</guid><pubDate>Wed, 10 Apr 2024 07:03:39 GMT</pubDate><enclosure url="03-web\04-浏览器\01-chrome\assets\snippet.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;03-web\04-浏览器\01-chrome\assets\snippet.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[markdown保存]]></title><description><![CDATA[ 
 <br><br><br><a rel="noopener nofollow" class="external-link" href="https://mika-cn.github.io/maoxian-web-clipper/index-zh-CN.html" target="_blank">https://mika-cn.github.io/maoxian-web-clipper/index-zh-CN.html</a><br>MaoXian 是一个可以将网页的内容裁剪并保存到本地电脑的浏览器扩展。使用它，你可以避免网站挂了，网址失效，图片失效等问题。 它可以将网页保存为 HTML 格式或 Markdown 格式，图片样式等也会一同保存下来。<br>安装方式 下载crx自行安装<br>2023-8-28 10:32:14<br>
安装后发现该插件已经被禁用，只需要将crx文件解压成文件夹 然后导入即可<br>使用插件前请先测试一下是否可以下载<br>
<img src="03-web\04-浏览器\02-浏览器插件\assets\测试.png"><br>如果不能下载 可能是有其他插件影响了该插件的使用，先禁用其他插件<br><br>来源网址: {{url}}
裁剪时间: {{createdAt}}
{{content}}
]]></description><link>03-web\04-浏览器\02-浏览器插件\01-浏览器插件.html</link><guid isPermaLink="false">03-web/04-浏览器/02-浏览器插件/01-浏览器插件.md</guid><pubDate>Wed, 10 Apr 2024 07:03:51 GMT</pubDate><enclosure url="03-web\04-浏览器\02-浏览器插件\assets\测试.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;03-web\04-浏览器\02-浏览器插件\assets\测试.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[VSCode 与 WebStorm 横向对比 | Awesome Frontend]]></title><description><![CDATA[<a class="tag" href="?query=tag:笑），相比之下" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#笑），相比之下</a> 
 <br>来源网址: <a rel="noopener nofollow" class="external-link" href="https://wiki.rxliuli.com/p/a305aafaac2b4ee8b9fa2f97898f1eea.html" target="_blank">https://wiki.rxliuli.com/p/a305aafaac2b4ee8b9fa2f97898f1eea.html</a><br>
裁剪时间: 2023-08-28 13:48:04<br><br><br>
不能认清自己，怎能看清别人？
<br>最近很长一段时间，VSCode 似乎成为了前端口中的标准开发编辑器，前端圈到处都在推荐 VSCode，劝说其他人放弃 Sublime, WebStorm, Atom 之流，仿佛真的是信巨硬，得永生一般。而吾辈作为一个长时间使用 JetBrains 系 IDE 的全沾开发者，这里就来对比一下 WebStorm 与后起之秀 VSCode 之前的异同点吧<br><br><br>VSCode 的生态无疑非常好，基于 Web 技术构建的编辑器同样可以使用 Web 技术开发插件，而 Web 开发人员的数量也确实非常庞大。且由于其轻量跨平台的特性，受到很多开发者的喜爱，将之作为主力文件编辑器或者将其打造成 IDE 使用。它们的插件市场首页分别如下<br>VSCode <img alt="VSCode 插件市场" src="03-web\99-开发工具\assets\1693201684-d57c3f00aa531c513f38a22707f5bdd6.png"><br>WebStorm <img alt="WebStorm 插件市场" src="03-web\99-开发工具\assets\1693201684-db1828f7f4f2f81f5d0407877da92d29.png"><br>WebStorm 官方给出的插件总数是 1607，而 VSCode 吾辈并未找到插件的总数量，但显而易见，VSCode 的插件数量应该远远高于这个数字。而且你可以看到 WebStorm 下载量第一的插件仅仅只下载过 5,558,762 次，而 VSCode 的热门插件的下载数量是以 M 来计算的。我们来搜索一下前端流行打包工具 webpack，对比一下结果。<br>VSCode <img alt="webpack for vscode" src="03-web\99-开发工具\assets\1693201684-7b47aa60a1c602b4a4f79599a8f23da8.png"><br>WebStorm <img alt="webpack for WebStorm" src="03-web\99-开发工具\assets\1693201684-34b7e53441c1bca0c9142e8fa16eba43.png"><br>是的，VSCode 搜索到了 16 个插件，而 WebStorm 的搜索结果是。。。0？不了解 WebStorm 的小伙伴可能会有疑问，难道 WebStorm 不支持 webpack 嘛？那要它何用，还是拉出去砍了吧！ 泥萌先别急着掀桌子，个中缘由且听吾辈细细说来。之所以出现这种情况，主要是因为二者的策略不同造成的。WebStorm 的目标是让用户拥有开箱即用的生产力工具，下载安装完成后就可以立即进行项目开发了，所以它将很多功能内置了 IDE 之中，或者是由官方开发插件出来，然后直接集成到 IDE 中，给个人开发者开发插件的机会不多。 而 VSCode 由于官方的开发团队没那么强大，而且又是免费的开源产品，所以理所当然只能发动广大人民群众的力量了，所以有很多插件就只能交给第三方开发者进行开发和维护。而这点也造成了安装完 VSCode 之后并不能立即使用，还需要下载插件、进行配置等一系列操作。 以上两种模式的孰优孰劣早有人分析过，这里吾辈只说自己的使用体验。WebStorm 的开箱即用做的确实比 VSCode 更好，但问题在于如果官方不支持的话就会很难受，因为其实并没有太多人同时精通前端和 Java（是的，必须使用 Java 开发插件）。这也是吾辈目前仍然使用 VSCode 作为主力文本编辑器编辑配置文件，以及使用它写 Markdown 文章的原因，包括这篇文章亦是通过 VSCode 写出来的。 <img alt="Markdown 写作截图" src="03-web\99-开发工具\assets\1693201684-8d74cc452b7bd10cd89acd3258d02fab.png"><br>
附: 插件开放让第三方实现与官方自己实现并集成的优劣之分参考知乎的一篇文章: <a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/35303567" rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/35303567" target="_blank">Visual Studio Code 有哪些工程方面的亮点open in new window</a>。 通过插件来扩展功能的做法已经是司空见惯了，但如何保证插件和原生功能一样优秀呢？历史告诉我们：不能保证。大家可以参考 Eclipse，插件模型可以说是做得非常彻底了，功能层面也是无所不能，但存在几个烦人的问题：不稳定、难用、慢，所以不少用户转投 IntelliJ 的怀抱。可谓成也插件，败也插件。问题的本质在于信息不对称，它导致不同团队写出来的代码，无论是思路还是质量，都不一致。最终，用户得到了一个又乱又卡的产品。所以要让插件在稳定性、速度和体验的层面都做到和原生功能统一，只能是一个美好的愿望。 来看看其他 IDE 是怎么做的，Visual Studio 自己搞定所有功能，并且做到优秀，让别人无事可做，这也成就了其 “宇宙第一 IDE” 的美名；IntelliJ 与之相仿，开箱即用，插件可有可无。这么看起来，自己搞定所有的事情是个好办法，但大家是否知道，Visual Studio 背后有上千人的工程团队，显然，这不是 VS Code 这二十几号人能搞定的。他们选择了让大家来做插件，那怎么解决 Eclipse 所遇到的问题呢？ 这里分享一个小知识 ——Eclipse 核心部分的开发者就是早期的 VS Code 团队。嗯，所以他们没有两次踏入同一条河流。与 Eclipse 不同，VS Code 选择了把插件关进盒子里。 这样做首先解决的问题就是稳定性，这个问题对于 VS Code 来说尤为重要。都知道 VS Code 基于 Electron，实质上是个 node.js 环境，单线程，任何代码崩了都是灾难性后果。所以 VS Code 干脆不信任任何人，把插件们放到单独的进程里，任你折腾，主程序妥妥的。 VS Code 团队的这一决策不是没有原因的，正如前面提到的，团队里很多人其实是 Eclipse 的旧部，自然对 Eclipse 的插件模型有深入的思考。Eclipse 的设计目标之一就是把组件化推向极致，所以很多核心功能都是用插件的形式来实现的。遗憾的是，Eclipse 的插件运行在主进程中，任何插件性能不佳或者不稳定，都直接影响到 Eclipse，最终结果是大家抱怨 Eclipse 臃肿、慢、不稳定。VS Code 基于进程做到了物理级别的隔离，成功解决了该问题。实际上进程级别的隔离也带出了另一个话题，那就是界面与业务逻辑的隔离。
<br><br>作为写代码的工具，代码提示已经司空见惯了。但是，就算同样是代码提示，有的代码提示只是简单的代码片段（snippets），而有的却是基于代码语法树分析进行的，甚至于编辑器会学习使用者的习惯，将最常用的提示放在最前面。WebStorm 从始至终一直都是第三种，而 VSCode 最近官方才开发了基于 AI 自动学习的智能提示插件 <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode" rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=VisualStudioExptTeam.vscodeintellicode" target="_blank">Visual Studio IntelliCodeopen in new window</a>。<br>VSCode <img alt="VSCode 智能提示" src="03-web\99-开发工具\assets\1693201684-bd97dbf4ad83cb6ed5bb4bf9f1d2fcde.gif"><br>WebStorm <img alt="WebStorm 智能提示" src="03-web\99-开发工具\assets\1693201684-4e9f36060b2c5a140ed8fd4818667139.gif"><br><br>更新，大型前端 monorepo 项目中，vscode 的表现几乎不能看。相比于 webstorm 无法自动添加 import 导入语句，vscode 则完全不可用，必须手写且 ts server 时有卡死，导航以及重构也存在更多的问题。<br><br>我们在日常开发中经常会遇到一些低级问题，而编辑器其实是有可能帮我们自动修复的。这里便对吾辈了解的一些问题进行对比，问题详细信息请参考文章 <a data-tooltip-position="top" aria-label="https://wiki.rxliuli.com/p/:/69eedef48bf54c3ca692b43a115a118f" rel="noopener nofollow" class="external-link" href="https://wiki.rxliuli.com/p/:/69eedef48bf54c3ca692b43a115a118f" target="_blank">JavaScript 规范整理</a><br>
注: VSCode 没有原生的自动修复功能，必须使用插件才行。
<br><br>下面是一张 WebStorm 官方使用自动修复的动图 <img alt="WebStorm 自动修复" src="03-web\99-开发工具\assets\1693201684-a7829c40aa993d72e16d4a41f60433dd.gif"><br><br>说起重构的话，VSCode 可以简单的说是做的太少，而 WebStorm 则是相反做的太多，下面继续以表格的形式进行对比。<br>
WebStorm 较新版本已经修复了 2018.02 重命名会自动索引字符串的问题（变成可选项了）。
<br><br>WebStorm 重命名文件 <img alt="WebStorm 重命名文件" src="03-web\99-开发工具\assets\1693201684-b87ba7fdfae5b9ee3ddb3e4b4a66d7ef.gif"><br><br>VSCode 的 Git 支持一直不太行，就算加了插件 <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens" target="_blank">GitLensopen in new window</a> 也无法比得上 WebStorm。<br><br>放两张图对比一下<br>VSCode GitLens <img alt="GitLens" src="03-web\99-开发工具\assets\1693201684-c784233da02663b5401ef678b9b3fb90.png"><br>WebStorm <img alt="WebStorm Git" src="03-web\99-开发工具\assets\1693201684-8685e373eabebe388c074da38a39e138.png"><br>
新版的 GitLens 好用很多，不仅仅追求功能丰富，更对开发者体验非常关心。
<br><br>前面提过，VSCode 生态很好，基本上很多语言/框架都有支持，而且官方也有一些非常优秀的插件。但是，有一些地方很重要，VSCode 对于 HTML/CSS/JavaScript 这些 Web 基本元素的支持相比于 WebStorm 确实可以说的上是糟糕。<br>先来测试前端三剑客: HTML/CSS/JavaScript。<br>VSCode <img alt="VSCode" src="03-web\99-开发工具\assets\1693201684-88fe52f7a585d783c803df54dabba948.gif"><br>WebStorm <img alt="WebStorm" src="03-web\99-开发工具\assets\1693201684-40dafffaeb286b3c62c02019aa42874b.gif"><br>可以看到，对于 HTML/CSS 之间的代码提示、跳转这些基本功能，VSCode 其实并没有做好。现代前端说是不再写 HTML 了，但实际上终究还是要写（即便是 JSX 还是要符合写 HTML 的直觉的），VSCode 代码提示在这里明显不太够看。还有一点也很有趣，VSCode 在打完 document.querySelector('#hello') 之后彻底没了动静，而 WebStorm 在 style 输入完成之后，立刻就有了各种 CSS 属性提示了。<br>
附: VSCode 中通过输入 h1.hello#hello Tab 之后就得到代码是一种前端 HTML 代码编写方式，被称为 <a data-tooltip-position="top" aria-label="https://www.qianduan.net/zen-coding-a-new-way-to-write-html-code/" rel="noopener nofollow" class="external-link" href="https://www.qianduan.net/zen-coding-a-new-way-to-write-html-code/" target="_blank">Zen Codingopen in new window</a>。但实际上，这种编写方式在代码提示方面存在劣势，所以使用 WebStorm 时并未演示。 附: VSCode 引用文件路径提示需要插件 <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense" target="_blank">Path Intellisenseopen in new window</a>
<br>对于库的开发者而言最难受的地方是 VSCode 实质上依赖于 TypeScript 才能做到代码提示，如果你也像吾辈是一位 JavaScript SDK 的开发者，那么也会遇到这件令人郁闷的事情: 如果想要使用你的 JavaScript SDK 的 VSCode 用户有正常的代码提示的话，你就必须接触 TypeScript。要么使用 TypeScript 重构整个 SDK，要么写 .d.ts 专门为 VSCode 维护一份注释文档，详情可以参考文章 <a data-tooltip-position="top" aria-label="https://wiki.rxliuli.com/p/03ee7047ae3c4203b0c4c4ebfd6d7bd9" rel="noopener nofollow" class="external-link" href="https://wiki.rxliuli.com/p/03ee7047ae3c4203b0c4c4ebfd6d7bd9" target="_blank">JavaScript =&gt; TypeScript 迁移体验</a>。<br><br>不知你是否曾遇到过，正在编辑着一个文件，突然断电，或者是因为其他什么原因，导致文件内容被清空了。或者是误删了代码之后之前的代码还没提交，又不能撤回那么多次，导致代码重写的经历呢？吾辈就曾经经历过，所以对本地历史记录这个功能相当重视，然而很遗憾，VSCode 依旧需要第三方插件 <a data-tooltip-position="top" aria-label="https://marketplace.visualstudio.com/items?itemName=xyz.local-history" rel="noopener nofollow" class="external-link" href="https://marketplace.visualstudio.com/items?itemName=xyz.local-history" target="_blank">Local Historyopen in new window</a> 才能支持。<br>VSCode Local History <img alt="VSCode Local History" src="03-web\99-开发工具\assets\1693201684-6d40e135a8f34f3b6695350d09492ec1.png"><br>WebStorm <img alt="WebStorm" src="03-web\99-开发工具\assets\1693201684-a0531151f0e73bf13778f415d7147d58.png"><br>两者相比主要有以下不同<br><br>
WebStorm 的支持目录的历史记录非常强大，相当于实时保存和提交的 git
<br><br>两者都支持黑暗主题，而且都是默认设置，也同样支持使用插件定制界面。下面是两者的截图<br>VSCode <img alt="VSCode 主界面" src="03-web\99-开发工具\assets\1693201684-5a87e52af4add188ce50c51304bcd851.png"><br>WebStorm <img alt="WebStorm 主界面" src="03-web\99-开发工具\assets\1693201684-94948ed124733e652ee3052c24c47287.png"><br>事实上，上面两者都使用了主题。VSCode 是 Monokai，WebStorm 是 Material。但其实 WebStorm 的 <a data-tooltip-position="top" aria-label="https://plugins.jetbrains.com/plugin/8006" rel="noopener nofollow" class="external-link" href="https://plugins.jetbrains.com/plugin/8006" target="_blank">Material 主题open in new window</a> 还是存在一些 Bug 的，例如有些地方图标莫名的错位之类，VSCode 目前吾辈还未曾遇到过这类问题。<br><br>WebStorm 确实很吃内存，尤其是项目刚刚打开的时候，索引会疯狂地吃 CPU/内存/硬盘，如果电脑性能不行的话这个过程所需时间可能泡面都够了。但基于 Chrome 内核的 VSCode 在使用各种插件打造成前端 IDE 之后吃的内存也并不少。吾辈打开了项目 <a data-tooltip-position="top" aria-label="https://github.com/rxliuli/rx-util" rel="noopener nofollow" class="external-link" href="https://github.com/rxliuli/rx-util" target="_blank">rx-utilopen in new window</a>，可以看到 VSCode 每个插件确实都放在了单独的进程里（Chrome 系的习惯 <a href=".?query=tag:笑），相比之下" class="tag" target="_blank" rel="noopener nofollow">#笑），相比之下</a> WebStorm 只有两个进程，其中一个还是启动的 nodejs，整体对比下来其实相差不大。<br><img alt="任务管理器" src="03-web\99-开发工具\assets\1693201684-2fd40a70aafe1a9a9924a62ca3044418.png"><br>
不得不承认的是，WebStorm 吃的性能终究还是要比 VSCode 多。但是，能用钱堆硬件解决的问题，能算问题么？ <img alt="assets/1693201684-38285b7ce42dcfaf22bacfaf0310911d.png" src="03-web\99-开发工具\assets\1693201684-38285b7ce42dcfaf22bacfaf0310911d.png" style="width: 1.61374e+12px; max-width: 100%;">
<br><br>JetBrains IDE 深度集成工具链，倾向于一切都以可视化界面点击/快捷键完成操作。而 VSCode 则有所不同，它有很多功能需要使用命令行/配置文件的形式完成。吾辈最开始使用 VSCode 时它甚至还没有配置界面，也只能使用 launch.json 启动 debugger（最新版似乎已经不是了），真是被吓到了。 在调试、运行支持的工具时，一般 VSCode 仍然需要使用命令行工具，或者在需要调试时编写 launch.json 配置脚本。但 WebStorm 则更加深度集成的工具链，倾向于一切都以可视化界面点击/快捷键完成操作。拿运行和调试代码为例，统一支持可视化的形式运行或调试（自动生成 ide 配置，并支持在必要的时候调整），目前支持 npm/gulp/浏览器 js/jest/nodejs/electron/typescript/git。<br>至于有人说一个命令的事情为什么要 ide 集成？<br>
<br>安装依赖的时候停止索引，避免影响性能
<br>简单启动调试（至今吾辈仍然没有彻底搞懂 vscode 的调试，为什么不能点一下就启动调试？至于是浏览器、nodejs、electron 可能存在不同的差异，让 ide 去屏蔽这一层不就好了，反正 ide 能识别出来项目使用的技术栈（至少是 ide 支持的技术栈））
<br>显示单独的命令视图
<br>快速查找/运行命令
<br>
有可能通过插件支持，但使用 VSCode 的人似乎更倾向于使用命令行（懒得找）。
<br><br>VSCode 通过 <a data-tooltip-position="top" aria-label="https://github.com/MicrosoftDocs/live-share" rel="noopener nofollow" class="external-link" href="https://github.com/MicrosoftDocs/live-share" target="_blank">live-shareopen in new window</a> 实现了远程开发，但 WebStorm 也通过官方插件 <a data-tooltip-position="top" aria-label="https://www.jetbrains.com/code-with-me/" rel="noopener nofollow" class="external-link" href="https://www.jetbrains.com/code-with-me/" target="_blank">Code With Meopen in new window</a> 和 <a data-tooltip-position="top" aria-label="https://lp.jetbrains.com/projector/" rel="noopener nofollow" class="external-link" href="https://lp.jetbrains.com/projector/" target="_blank">Projectoropen in new window</a> 进行了支持。<br><br>
就吾辈实际使用而言，感觉这是个噱头功能，和许多云 IDE 差不多。
<br><br>VSCode 背后站着微软，俗成 M$，开发了宇宙最强 IDE Visual Studio。而 WebStorm 则是基于 JetBrains 平台专门为前端进行特殊处理优化的 IDE，背后则是业界最智能的 IDE 的开发公司 JetBrains（捷克公司）。两者在 IDE/编辑的开发上都相当有经验，然而，有一点本质的不同：IDE 对于 JetBrains 而言几乎是全部，而 VSCode 对于 M$ 则只是开发的一部分 -- 编辑器。<br>VSCode =&gt; VSCode Remote =&gt; GitHub =&gt; GitHub Actions =&gt; Azure，从 MS 的一系列变化来看，这对开发者是真的相当上心，从本地开发、远程协作、版本控制、自动化流程控制 CI/CD 到部署到云端，完全是一站式的体验。相比于国内的云服务商，MS 显然更加开放、更加为开发者着想。 而 JetBrains，虽然现在也有了编程语言 Kotlin、项目管理工具 Space（包含 CI/CD 工具 TeamCity），但本质上在其领域内，除了 IDE，其他的东西都没能形成特别大的优势（Kotlin 只能用于开发 Android 平台，而 Web 技术甚至能开发全端；TeamCity 虽然很漂亮，但似乎人们更喜欢开源的 Jenkins）。 未来 VSCode 一统天下似乎是必然之势，但目前而言，其尚且年幼，唯有 WebStorm 正值壮年。<br>
附：例如某只企鹅，开发的大多数云服务都是私有服务，使用上比开源的还难用而且还强制绑定到自家云服务上，使人不得不用全家桶（问题是体验又烂，文档死难找） 附: 居然连 “文档和 Demo 有可能过期，但代码一定是最新的” 这种话都能说出来，与 MS 花大力气创造开源的 VSCode 简直是天壤之别。 附: 没有对比就没有伤害！
<br><br>其实在 Atom/VSCode 出现之前，WebStorm 因为在这个领域没有对手而发展缓慢，它们的出现使得 WebStorm 有了压力，良性竞争，这当然是好事。即便如此，就目前而言，VSCode 作为一个 IDE 来讲仍然比不上 JetBrains 全家桶系列。 说了上面这么多，总的来说: 如果你需要一个文本编辑器，那么推荐你用 VSCode，因为它既漂亮又生态丰富，想写点什么很方便。但是，如果你需要真正开发项目，则 WebStorm 更加合适，完全开箱即用的体验，不需要安装/配置任何插件就能立刻开始项目，强大的编辑器可以让你写代码更舒服一点。（其实是没钱就用免费的 VSCode，有钱就上 WebStorm 啦！）<br>
ref link: <a data-tooltip-position="top" aria-label="https://dev.to/mokkapps/why-i-switched-from-visual-studio-code-to-jetbrains-webstorm-939" rel="noopener nofollow" class="external-link" href="https://dev.to/mokkapps/why-i-switched-from-visual-studio-code-to-jetbrains-webstorm-939" target="_blank">Why I Switched From Visual Studio Code To JetBrains WebStormopen in new window</a> 吾辈个人非常同意作者及相关评论的观点：为 WebStorm 付费能减少折腾 VSCode 的时间，VSCode 的真正优势是启动时间，使用内存和免费。
]]></description><link>03-web\99-开发工具\01-vscode和webstorm.html</link><guid isPermaLink="false">03-web/99-开发工具/01-vscode和webstorm.md</guid><pubDate>Wed, 10 Apr 2024 07:03:57 GMT</pubDate><enclosure url="03-web\99-开发工具\assets\1693201684-d57c3f00aa531c513f38a22707f5bdd6.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;03-web\99-开发工具\assets\1693201684-d57c3f00aa531c513f38a22707f5bdd6.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-索引]]></title><description><![CDATA[<a class="tag" href="?query=tag:不同的存储引擎支持的索引类型也不一样" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#不同的存储引擎支持的索引类型也不一样</a> 
 <br><br>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息 &nbsp;<br>有一张person表，其中有2W条记录，记录着2W个人的信息。有一个Phone的字段记录每个人的电话号码，现在想要查询出电话号码为xxxx的人的信息<br>没有索引，全表查询<br>如果有了索引，那么会将该Phone字段，通过一定的方法进行存储，好让查询该字段上的信息时，能够快速找到对应的数据，而不必在遍历2W条数据了。其中MySQL中的索引的存储类型有两种：BTREE、HASH<br><a href=".?query=tag:不同的存储引擎支持的索引类型也不一样" class="tag" target="_blank" rel="noopener nofollow">#不同的存储引擎支持的索引类型也不一样</a><br>InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；<br>MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；<br>Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；<br>NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；<br>Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；<br><br>　　　　　　优点：<br>　　　　　　　2、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引<br>　　　　　　　3、大大加快数据的查询速度<br>　　　　　　缺点：<br>　　　　　　　1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加<br>　　　　　　　2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值<br>　　　　　　　3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。<br>　　　　　　使用原则：<br>　　　　　　 &nbsp; &nbsp; &nbsp;通过上面说的优点和缺点，我们应该可以知道，并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用。<br>　　　　　　　1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，<br>　　　　　　　2、数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。<br>　　　　　　　3、在一同值少的列上(字段上)不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可是建立索引。<br><br>注意：索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引<br>　　　　　　　　　　　　MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换<br>　　　　　　　　　　　　MEMORY/HEAP存储引擎：支持HASH和BTREE索引<br>　　　　　　　1、索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、<br>　　　　　　　　　　1.1、单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。<br>　　　　　　　　　　　　　1.1.1、普通索引：<br>　　　　　　　　　　　　　　　　　　MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。<br>　　　　　　　　　　　　　1.1.2、唯一索引：<br>　　　　　　　　　　　　　　　　　　索引列中的值必须是唯一的，但是允许为空值，<br>　　　　　　　　　　　　　1.1.3、主键索引：<br>　　　　　　　　　　　　　　　　　　是一种特殊的唯一索引，不允许有空值。<br>　　　　　　　　　　1.2、组合索引<br>　　　　　　　　　　　　　　　在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。这个如果还不明白，等后面举例讲解时在细说　<br>　　　　　　　　　　1.3、全文索引<br>　　　　　　　　　　　　　　　全文索引，只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个大煞笔，二货 ..." 通过大煞笔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思，如果感兴趣进一步深入使用它，那么看下面测试该索引时，会给出一个博文，供大家参考。<br><br><br>格式：CREATE TABLE 表名[字段名 数据类型] &nbsp;[UNIQUE|FULLTEXT|SPATIAL|...] [INDEX|KEY] [索引名字] (字段名[length]) 　　[ASC|DESC]<br>　　　　　　　　　　　　　　　|--------------------------------------| &nbsp;|-----------------------------------| |------------| |---------| |---------------| &nbsp;　　|------------|<br>　　　　　　　　　　　　　　　　　　　　普通创建表语句　　　　　　　　设置什么样的索引(唯一、全文等)　　索引关键字　 索引名字　对哪个字段设置索引　　对索引进行排序　<br>
-- 普通索引

create table test

(id INT NOT NULL,

name VARCHAR(30) NOT NULL,

index (id)

);

-- 唯一索引

create table test

(id INT NOT NULL,

name VARCHAR(30) NOT NULL,

unique index (id)

);

-- 主键索引,index和key一样,只能primary key，不能primary index

create table test

(id INT NOT NULL,

name VARCHAR(30) NOT NULL,

primary key (id)

);

-- 组合索引，索引没有命名，默认第一个列的列名为索引名，所以好习惯是都有列名

-- 最左前缀：id,name =&gt; id,name ; id 。 id,name,age =&gt; id ; id,name ; id,name,age  。

create table test

(id INT NOT NULL,

name VARCHAR(30) NOT NULL,

index (id,name)

);

-- 全文索引可以用于全文搜索，但只有MyISAM存储引擎支持FULLTEXT索引，并且只为CHAR、VARCHAR和TEXT列服务。索引总是对整个列进行，不支持前缀索引，

create table test

(id INT NOT NULL,

name VARCHAR(30) NOT NULL,

FULLTEXT index (id,name)

);

-- 使用全文索引

SELECT * FROM t4 WHERE MATCH(info) AGAINST('gorlr');

<br><br>
-- ALTER TABLE 表名 ADD[UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] [索引名] (索引字段名)[ASC|DESC]

ALTER TABLE book ADD INDEX BkNameIdx(bookname(30));

-- CREATE [UNIQUE|FULLTEXT|SPATIAL] [INDEX|KEY] 索引名称 ON 表名(创建索引的字段名[length])[ASC|DESC]

CREATE INDEX BkBookNameIdx ON book(bookname);

-- 删除索引 一

ALTER TABLE book DROP INDEX BkBookNameIdx;

-- 删除索引 二

DROP INDEX BkNameIdx ON book;

-- 重命名的话就先删除，再创建一样的索引

]]></description><link>04-数据库\01-mysql\01-索引.html</link><guid isPermaLink="false">04-数据库/01-mysql/01-索引.md</guid><pubDate>Wed, 10 Apr 2024 07:04:01 GMT</pubDate></item><item><title><![CDATA[01-索引结构]]></title><description><![CDATA[ 
 <br>b树和b+树<br><a rel="noopener nofollow" class="external-link" href="https://maimai.cn/article/detail?fid=1408720815&amp;efid=lFI6aphOIq_PIY3ptWhuaA&amp;from=single_feed" target="_blank">https://maimai.cn/article/detail?fid=1408720815&amp;efid=lFI6aphOIq_PIY3ptWhuaA&amp;from=single_feed</a><br>最大的区别<br>
b树：<br>
<br>关键字集合分布在整颗树中；
<br>任何一个关键字出现且只出现在一个结点中；
<br>搜索有可能在非叶子结点结束；
<br>其搜索性能等价于在关键字全集内做一次二分查找；<br>
b+树<br>
非叶子节点不保存数据  只用来索引<br>
非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大（或最小）关键字
<br>&nbsp;B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找<br>
b树：<br>&nbsp;<img src="04-数据库\01-mysql\assets\b树.png"><br>
b+树：<br>
<img src="04-数据库\01-mysql\assets\b+树.png">]]></description><link>04-数据库\01-mysql\01-索引结构.html</link><guid isPermaLink="false">04-数据库/01-mysql/01-索引结构.md</guid><pubDate>Wed, 08 May 2024 09:09:30 GMT</pubDate><enclosure url="04-数据库\01-mysql\assets\b树.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;04-数据库\01-mysql\assets\b树.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02-慢sql,锁表问题]]></title><description><![CDATA[ 
 <br><br>如果sql本身没什么问题，并发量导致   考虑使用缓存<br><br>（1）设置开启：SET GLOBAL slow_query_log = 1;　　　#默认未开启，开启会影响性能，mysql重启会失效
（2）查看是否开启：SHOW VARIABLES LIKE '%slow_query_log%';
（3）设置阈值：SET GLOBAL long_query_time=3;
（4）查看阈值：SHOW 【GLOBAL】 VARIABLES LIKE 'long_query_time%';　　#重连或新开一个会话才能看到修改值
（5）通过修改配置文件my.cnf永久生效，在[mysqld]下配置：
　　[mysqld]
　　slow_query_log = 1;　　#开启
　　slow_query_log_file=/var/lib/mysql/atguigu-slow.log　　　#慢日志地址，缺省文件名host_name-slow.log
　　long_query_time=3;　　  #运行时间超过该值的SQL会被记录，默认值&gt;10
　　log_output=FILE
<br>如果我们的慢SQL很多，人工分析肯定分析不过来，这时候我们就需要借助一些分析工具，MySQL自带了一个慢查询分析工具mysqldumpslow，以下是常见使用示例<br>mysqldumpslow ­s c ­t 10 /var/run/mysqld/mysqld­slow.log # 取出使用最多的10条慢查询
mysqldumpslow ­s t ­t 3 /var/run/mysqld/mysqld­slow.log # 取出查询时间最慢的3条慢查询
mysqldumpslow ­s t ­t 10 ­g “left join” /database/mysql/slow­log #得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow ­s r ­t 10 ­g 'left join' /var/run/mysqld/mysqldslow.log # 按照扫描行数最多的
<br><br><a rel="noopener nofollow" class="external-link" href="https://www.cnblogs.com/zjxiang/p/9160564.html" target="_blank">https://www.cnblogs.com/zjxiang/p/9160564.html</a><br>type:<br>
system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all<br>sql优化： <a rel="noopener nofollow" class="external-link" href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank">https://tech.meituan.com/2014/06/30/mysql-index.html</a><br><br>0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE<br>1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高<br>
举个例子，假设有一个查询需要联结三个表，其中一张表的记录数非常大，而另外两个表的记录数较少。在这种情况下，就应该从记录数最少的两张表开始查询，然后再联结到记录数最多的表。而且在查询每个表时，应该尽可能利用索引，只查询需要的字段，减少数据的读取和匹配次数，以提高查询效率。同时，应该根据实际情况选择区分度最高的字段进行查询，避免无谓的匹配和比较。<br>
表1: user_info，包含用户信息<br>
表3: user_order，包含用户订单信息<br>
查询用户名为Tom的用户最近一个月内的订单记录<br>
应该先查用户表 然后去关联订单表  因为一般情况  订单表总记录数回比用户表大的多<br>2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）<br>3.order by limit 形式的sql语句让排序的表优先查<br>4.了解业务方使用场景<br>5.加索引时参照建索引的几大原则<br>6.观察结果，不符合预期继续从0分析<br><br>1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。<br>3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(1)， 表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。<br>4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。<br>5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。<br><br>行级锁  还是表级锁<br> mysql 行锁模拟、锁查看及排除：<a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/chuangxin/article/details/86754156" target="_blank">https://blog.csdn.net/chuangxin/article/details/86754156</a><br>
Lock wait timeout exceeded; try restarting transaction. 这个报错一般就是锁表<br>
MySQL的 InnoDB 存储引擎支持行级锁，InnoDB 的行锁是通过给索引项加锁实现的。<br>这句话说明了什么?<br>说明了一件事：只有通过索引条件检索数据时，InnoDB 才使用行锁，否则使用表锁。<br>
Innodb行锁的优化<br>
<br>加索引，让查询走索引
<br>学会控制事务
<br>隔离级别不要随便设置，根据不同情况不同选择就可以了
<br><br><a rel="noopener nofollow" class="external-link" href="https://xie.infoq.cn/article/469900fb8757d181892384335" target="_blank">https://xie.infoq.cn/article/469900fb8757d181892384335</a><br>1.  #查看进程id，然后用kill id杀掉进程
2.  show processlist;
3.  SELECT * FROM information_schema.PROCESSLIST；
4.  #查询正在执行的进程
5.  SELECT * FROM information_schema.PROCESSLIST where length(info) &gt;0 ;
6.  #查询是否锁表
7.  show OPEN TABLES where In_use &gt; 0;
8.  #查看被锁住的
9.  SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
10.  #等待锁定
11.  SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
12.  #杀掉锁表进程
13.  kill 进程号
<br><br><a rel="noopener nofollow" class="external-link" href="https://heapdump.cn/article/3892198" target="_blank">https://heapdump.cn/article/3892198</a><br>只要简单了解过MySQL内部优化机制，就很容易写出高性能的SQL<br>1.不使用子查询：<br>SELECT * FROM t1 WHERE id (SELECT id FROM t2 WHERE name='hechunyang');
<br>在MySQL5.5版本中，内部执行计划器是先查外表再匹配内表，如果外表数据量很大，查询速度会非常慢<br>
在MySQL5.6中，有对内查询做了优化，优化后SQL如下<br>SELECT t1.* FROM t1 JOIN t2 ON t1.id = t2.id;
<br>但也仅针对select语句有效，update、delete子查询无效，所以生成环境不建议使用子查询<br>2.避免函数索引<br>SELECT * FROM t WHERE YEAR(d) &gt;= 2016;
<br>即使d字段有索引，也会全盘扫描，应该优化为：<br>SELECT * FROM t WHERE d &gt;= '2016-01-01';
<br>3.使用IN替换OR<br>SELECT * FROM t WHERE LOC_ID = 10 OR LOC_ID = 20 OR LOC_ID = 30;
<br>非聚簇索引走了3次，使用IN之后只走一次：<br>SELECT * FROM t WHERE LOC_IN IN (10,20,30);
<br>4.LIKE双百分号无法使用到索引<br>SELECT * FROM t WHERE name LIKE '%de%';
<br>应优化为右模糊<br>SELECT * FROM t WHERE name LIKE 'de%';
<br>5.增加LIMIT M,N 限制读取的条数<br>6.避免数据类型不一致<br>SELECT * FROM t WHERE id = '19';
<br>应优化为<br>SELECT * FROM t WHERE id = 19;
<br>7.分组统计时可以禁止排序<br>SELECT goods_id,count(*) FROM t GROUP BY goods_id;
<br>默认情况下MySQL会对所有GROUP BY co1，col2 …的字段进行排序，我们可以对其使用ORDER BY NULL禁止排序，避免排序消耗资源<br>SELECT goods_id,count(*) FROM t GROUP BY goods_id ORDER BY NULL;
<br>8.去除不必要的ORDER BY语句]]></description><link>04-数据库\01-mysql\02-慢sql,锁表问题.html</link><guid isPermaLink="false">04-数据库/01-mysql/02-慢sql,锁表问题.md</guid><pubDate>Wed, 10 Apr 2024 07:04:05 GMT</pubDate></item><item><title><![CDATA[03-事务]]></title><description><![CDATA[ 
 <br><br>首先，事务隔离级别，是为了解决多个并行事务竞争导致的数据安全问题的一种规范。 具体来说，多个事务竞争可能会产生三种不同的现象。假设有两个事务 T1/T2 同时在执行，T1 事务有可能会读取到T2 事务未提交的数据，但是未提交的事务 T2 可能会回滚，也就导致了T1 事务读取到最终不一定存在的数据产生脏读的现象。<br>
<img src="04-数据库\01-mysql\assets\pasted-image-20230305192751.png"><br>假设有两个事务 T1/T2 同时执行，事务 T1 在不同的时刻读取同一行数据的时候结果可能不一样，从而导致不可重复读的问题<br>
<img src="04-数据库\01-mysql\assets\pasted-image-20230305192814.png"><br>假设有两个事务 T1/T2 同时执行，事务 T1 执行范围查询或者范围修改的过程中，事务 T2 插入了一条属于事务 T1 范围内的数据并且提交了，这时候在事务 T1 查询发现多出来了一条数据，或者在 T1 事务发现这条数据没有被修改，看起来像是产生了幻觉，这种现象称为幻读<br>
<img src="04-数据库\01-mysql\assets\pasted-image-20230305192831.png"><br>而这三种现象在实际应用中，可能有些场景不能接受某些现象的存在，所以在SQL 标准中定义了四种隔离级别，分别是：<br>
读未提交，在这种隔离级别下，可能会产生脏读、不可重复读、幻读。<br>
读已提交（RC)，在这种隔离级别下，可能会产生不可重复读和幻读。<br>
可重复读（RR），在这种隔离级别下，可能会产生幻读<br>
串行化，在这种隔离级别下，多个并行事务串行化执行，不会产生安全性问题。<br>
这四种隔离级别里面，只有串行化解决了全部的问题，但也意味着这种隔离级别的性能是最低的。 在 Mysql 里面，InnoDB 引擎默认的隔离级别是 RR（可重复读），因为它需要保证事务 ACID 特性中的隔离性特征。]]></description><link>04-数据库\01-mysql\03-事务.html</link><guid isPermaLink="false">04-数据库/01-mysql/03-事务.md</guid><pubDate>Wed, 08 May 2024 09:09:36 GMT</pubDate><enclosure url="04-数据库\01-mysql\assets\pasted-image-20230305192751.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;04-数据库\01-mysql\assets\pasted-image-20230305192751.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[04-索引失效场景]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://segmentfault.com/a/1190000041469451" target="_blank">https://segmentfault.com/a/1190000041469451</a><br>
<a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/7083520386498822158" target="_blank">https://juejin.cn/post/7083520386498822158</a><br> 为了逐项验证索引的使用情况，我们先准备一张表t_user：<br>CREATE TABLE `t_user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `id_no` varchar(18) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '身份编号',
  `username` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '用户名',
  `age` int(11) DEFAULT NULL COMMENT '年龄',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `union_idx` (`id_no`,`username`,`age`),
  KEY `create_time_idx` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
<br>在上述表结构中有三个索引：<br>
<br>id：为数据库主键；
<br>union_idx：为id_no、username、age构成的联合索引；
<br>create_time_idx：是由create_time构成的普通索引；
<br><br>explain select * from t_user where id_no = '1002';
<br><img src="04-数据库\01-mysql\assets\pasted-image-20230307181039.png"><br><br>
<br>id_no&nbsp;类型为varchar(18)，字符集为utf8mb4_bin，也就是使用4个字节来表示一个完整的UTF-8。此时，key_len = 18* 4 = 72；
<br>由于该字段类型varchar为变长数据类型，需要再额外添加2个字节。此时，key_len = 72 + 2 = 74；
<br>由于该字段运行为NULL（default NULL），需要再添加1个字节。此时，key_len = 74 + 1 = 75；
<br>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。<br>explain select * from t_user where id_no &gt; '1002' and username = 'aa';
<br><br><br><br><br>比如订单主键是雪花id  但是数据库是字符串类型char(32)  <br>explain select * from t_user where id_no = 1002;
<br><br>explain select * from t_user where id = 2 or username = 'Tom2';
<br>or两边同时使用“&gt;”和“&lt;”，则索引也会失效：<br>explain select * from t_user where id  &gt; 1 or id  &lt; 80;
<br><br>explain select * from t_user where id &gt; age;
<br><br>explain select * from t_user where id_no &lt;&gt; '1002';
<br><a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/6844903921450745863" target="_blank">https://juejin.cn/post/6844903921450745863</a><br>那既然IS NULL、IS NOT NULL、!=这些条件都可能使用到索引，那到底什么时候索引，什么时候采用全表扫描呢？<br>答案很简单：成本。当然，关于如何定量的计算使用某个索引执行查询的成本比较复杂，我们在小册中花了很大的篇幅来唠叨了。不过因为篇幅有限，我们在这里只准备定性的分析一下。对于使用二级索引进行查询来说，成本组成主要有两个方面：<br>
<br>读取二级索引记录的成本
<br>将二级索引记录执行回表操作，也就是到聚簇索引中找到完整的用户记录的操作所付出的成本。
<br><br><a rel="noopener nofollow" class="external-link" href="https://www.cnblogs.com/qlqwjy/p/8598091.html" target="_blank">https://www.cnblogs.com/qlqwjy/p/8598091.html</a><br><img src="04-数据库\01-mysql\assets\pasted-image-20230308081514.png"><br>比较使用 EXISTS 和 IN 的查询。注意两个查询返回相同的结果。<br>
select  from TableIn where exists(select BID from TableEx where BNAME=TableIn.ANAME)<br>
select  from TableIn where ANAME in(select BNAME from TableEx)<br>
<img src="04-数据库\01-mysql\assets\pasted-image-20230308081545.png"><br>EXISTS与IN的使用效率的问题，通常情况下采用exists要比in效率高，但要看实际情况具体使用：<br>
IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。]]></description><link>04-数据库\01-mysql\04-索引失效场景.html</link><guid isPermaLink="false">04-数据库/01-mysql/04-索引失效场景.md</guid><pubDate>Wed, 08 May 2024 09:09:41 GMT</pubDate><enclosure url="04-数据库\01-mysql\assets\pasted-image-20230307181039.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;04-数据库\01-mysql\assets\pasted-image-20230307181039.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05-读写分离]]></title><description><![CDATA[ 
 <br>前提都是数据库要先做好主从<br><br><a rel="noopener nofollow" class="external-link" href="https://shardingsphere.apache.org/document/4.1.0/cn/manual/sharding-jdbc/" target="_blank">https://shardingsphere.apache.org/document/4.1.0/cn/manual/sharding-jdbc/</a><br>Sharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。<br>
<br>适用于任何基于JDBC的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。
<br>支持任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。
<br>支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer，PostgreSQL以及任何遵循SQL92标准的数据库。
<br><a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV12o4y1a7Zf/?spm_id_from=333.999.0.0" target="_blank">https://www.bilibili.com/video/BV12o4y1a7Zf/?spm_id_from=333.999.0.0</a><br>dataSources:
  ds_master: !!org.apache.commons.dbcp.BasicDataSource
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ds_master
    username: root
    password: 
  ds_slave0: !!org.apache.commons.dbcp.BasicDataSource
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ds_slave0
    username: root
    password: 
  ds_slave1: !!org.apache.commons.dbcp.BasicDataSource
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ds_slave1
    username: root
    password: 

masterSlaveRule:
  name: ds_ms
  masterDataSourceName: ds_master
  slaveDataSourceNames: 
    - ds_slave0
    - ds_slave1

props:
    sql.show: true
<br>配置说明：<br>dataSources: #省略数据源配置，与数据分片一致

masterSlaveRule:
  name: #读写分离数据源名称
  masterDataSourceName: #主库数据源名称
  slaveDataSourceNames: #从库数据源名称列表
    - &lt;data_source_name1&gt;
    - &lt;data_source_name2&gt;
    - &lt;data_source_name_x&gt;
  loadBalanceAlgorithmType: #从库负载均衡算法类型，可选值：ROUND_ROBIN，RANDOM。若`loadBalanceAlgorithmClassName`存在则忽略该配置
  props: #读写分离负载算法的属性配置
    &lt;property-name&gt;: #属性值
]]></description><link>04-数据库\01-mysql\05-读写分离.html</link><guid isPermaLink="false">04-数据库/01-mysql/05-读写分离.md</guid><pubDate>Wed, 10 Apr 2024 07:04:11 GMT</pubDate></item><item><title><![CDATA[01-基本概念]]></title><description><![CDATA[ 
 <br>用户<br>表空间]]></description><link>04-数据库\02-oracle\01-基本概念.html</link><guid isPermaLink="false">04-数据库/02-oracle/01-基本概念.md</guid><pubDate>Wed, 10 Apr 2024 07:04:15 GMT</pubDate></item><item><title><![CDATA[02-头表主表]]></title><description><![CDATA[ 
 <br><br>比如你去超市买东西，给你打的小票就相当于头（header），每个客户一张小票，里面有超市编号、购买时间、收款员等信息<br>
明细（line）就是小票上的每个细目，比如你买了面包、牛奶、黄油，<br>
就会有品名、数量、单价等信息<br>建立头表和行表，就是避免冗余数据的出现<br>
还用上边的例子<br>
头表 订单信息（头ID，超市编号、购买时间、收款员），主键（头ID）<br>
行表 订单明细（头ID，行ID，细目名称，数量，单价），主键（头ID，行ID），外键（头ID）<br>
张三买3个面包、30代牛奶和1块黄油的订单，数据这样存储：<br>
头表:<br>
1,1,2012-12-13,"小王"<br>
行表<br>
1,1,面包,3,3.00<br>
1,2,牛奶,30,1.20<br>
1,3,黄油,1,5.00<br>
如果存在一张表中(订单ID,细目ID，超市编号，购买时间，收款员，细目名称，数量，单间）就会变成这样（前面的数据就是冗余的）<br>
1,1,2012-12-13,"小王",3,面包,3,3.00<br>
1,2,2012-12-13,"小王",30,牛奶,,2.00<br>
1,3,2012-12-13,"小王",1,黄油,1,5.00<br>
如果串资料时，如果不涉及详细内容，比如统计订单数量，或者收款员的工作量，可以只取头表信息<br>
如果要详细信息的内容，比如统计牛奶、面包卖了多少<br>
就要头表和行表做关联查询<br>举个例子：<br>-- 订单头表
CREATE TABLE orders (
  order_id NUMBER(10) PRIMARY KEY,  -- 订单编号
  order_date DATE,                  -- 订单日期
  customer_name VARCHAR2(50),       -- 客户名称
  total_amount NUMBER(12,2)         -- 订单总金额
);

-- 订单行表
CREATE TABLE order_items (
  item_id NUMBER(10) PRIMARY KEY,   -- 商品编号
  order_id NUMBER(10),              -- 订单编号，外键关联到订单头表的订单编号
  product_name VARCHAR2(50),        -- 商品名称
  quantity NUMBER(10),              -- 商品数量
  price NUMBER(10,2),               -- 商品单价
  CONSTRAINT fk_orders FOREIGN KEY (order_id) REFERENCES orders (order_id)
);
<br>这不就是两张表么    外键关联  一对多的关系    可见  头表  主表  就是个表设计里的一种概念罢了]]></description><link>04-数据库\02-oracle\02-头表主表.html</link><guid isPermaLink="false">04-数据库/02-oracle/02-头表主表.md</guid><pubDate>Wed, 10 Apr 2024 07:04:17 GMT</pubDate></item><item><title><![CDATA[98-oracle对特殊字符的处理的坑]]></title><description><![CDATA[ 
 <br>假如有张user表，有email字段 ，其中一行记录的值是  '<a data-tooltip-position="top" aria-label="mailto:njmoser18@gmail.com" rel="noopener nofollow" class="external-link" href="mailto:njmoser18@gmail.com" target="_blank">njmoser18@gmail.com</a>\n'<br>
假如我们dao层有一个方法  是getUserByEmail    然后传入的email是  '<a data-tooltip-position="top" aria-label="mailto:njmoser18@gmail.com" rel="noopener nofollow" class="external-link" href="mailto:njmoser18@gmail.com" target="_blank">njmoser18@gmail.com</a>\n'的话  那么就查询不到值  需要特殊处理  这是比较坑的一点]]></description><link>04-数据库\02-oracle\98-oracle对特殊字符的处理的坑.html</link><guid isPermaLink="false">04-数据库/02-oracle/98-oracle对特殊字符的处理的坑.md</guid><pubDate>Wed, 10 Apr 2024 07:04:20 GMT</pubDate></item><item><title><![CDATA[99-批量执行sql脚本]]></title><description><![CDATA[ 
 <br>想写一个bat  ，批量执行脚本<br>sqlplus jubt/jubt@orcl @list.sql&gt;log.txt Exit;
EXIT
<br>list.sql 如下：<br>@uim.sql
@portal.sql
@bt.sql
@bt_rule.sql
@bt_interface.sql
@batch.sql
]]></description><link>04-数据库\02-oracle\99-批量执行sql脚本.html</link><guid isPermaLink="false">04-数据库/02-oracle/99-批量执行sql脚本.md</guid><pubDate>Wed, 10 Apr 2024 07:04:21 GMT</pubDate></item><item><title><![CDATA[00-概览]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://shardingsphere.apache.org/document/4.1.0/cn/overview/" target="_blank">https://shardingsphere.apache.org/document/4.1.0/cn/overview/</a>]]></description><link>04-数据库\03-分布式数据库\01-sharding-sphere\00-概览.html</link><guid isPermaLink="false">04-数据库/03-分布式数据库/01-sharding-sphere/00-概览.md</guid><pubDate>Wed, 10 Apr 2024 07:04:25 GMT</pubDate></item><item><title><![CDATA[01-flyway]]></title><description><![CDATA[ 
 <br>Flyway 是一款开源的数据库版本管理工具<br>
现管理并跟踪数据库变更，支持数据库版本自动升级<br>springboot + mysql为例：<br>&lt;dependency&gt;
    &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;
    &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;
&lt;/dependency&gt;
<br>spring:
  datasource:
    url: jdbc:mysql://127.0.0.1:3306/flyway?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true&amp;useSSL=false&amp;serverTimezone=GMT%2B8
    username: root
    password: tiger 
  flyway:
    enabled: true
    # 禁止清理数据库表
    clean-disabled: true
    # 如果数据库不是空表，需要设置成 true，否则启动报错
    baseline-on-migrate: true
    # 与 baseline-on-migrate: true 搭配使用
    baseline-version: 0
    locations: 
      - classpath:db/migration/mysql（根据个人情况设置）
<br>这样启动项目后  会自动识别classpath:db/migration/mysql下的迁移脚本文件，根据数据库表<br>
flyway_schema_history 中的数据(如果数据库没有这张表会自动创建该表)和配置文件识别哪些脚本需要被执行，并自动执行<br>-- auto-generated definition
create table flyway_schema_history
(
    installed_rank int                                 not null
        primary key,
    version        varchar(50)                         null,
    description    varchar(200)                        not null,
    type           varchar(20)                         not null,
    script         varchar(1000)                       not null,
    checksum       int                                 null,
    installed_by   varchar(100)                        not null,
    installed_on   timestamp default CURRENT_TIMESTAMP not null,
    execution_time int                                 not null,
    success        tinyint(1)                          not null
);

create index flyway_schema_history_s_idx
    on flyway_schema_history (success);


]]></description><link>04-数据库\04-迁移工具\01-flyway.html</link><guid isPermaLink="false">04-数据库/04-迁移工具/01-flyway.md</guid><pubDate>Wed, 10 Apr 2024 07:04:29 GMT</pubDate></item><item><title><![CDATA[01-es基本概念]]></title><description><![CDATA[ 
 <br>Elasticsearch（通常缩写为 ES）是一种流行的开源全文搜索和分析引擎。下面是一些与Elasticsearch相关的基本概念：<br>
<br>索引：索引是具有相似结构并与特定主题相关的文档的集合。索引可以被认为是关系数据库中的表。
<br>文档：文档是 Elasticsearch 中的基本信息单元。它可以被认为是表格中的一行。文档包含描述文档中包含的信息的字段。
<br>节点：节点是参与集群的单个 Elasticsearch 实例。集群是一组协同工作以索引和搜索数据的节点。
<br>分片：索引被分成更小的单元，称为分片。每个分片都是一个独立的索引，可以存储在单独的节点上。这允许索引的水平缩放。
<br>副本：副本是存储在集群中不同节点上的分片副本。副本提供冗余，可用于提高搜索性能。
<br>映射：映射定义了索引的结构，包括字段的数据类型和分析字段以进行搜索的方式。
<br>分析：分析是将文本转换为可用于搜索的标记的过程。标记通常是单个单词，但它们也可以是短语或其他文本单元。
<br>查询：查询是在索引中搜索符合特定条件的文档的请求。Elasticsearch 支持范围广泛的查询类型，包括匹配、术语、范围等。
<br>聚合：聚合用于对索引中的数据执行计算，例如计算值的平均值、总和或计数。
<br>以上是Elasticsearch相关的一些基本概念。了解这些概念对于有效使用和使用 Elasticsearch 至关重要。<br><br>ES中的mapping有点类似与RDB中表结构的概念，在MySQL中．表结构里包含了字段名称，字段的类型还有索引信息等。 mapping中也包含了一些属性，比如字段名称、类型、字段使用的分词器、见否评分、是否创建索引等属性 es中一个字段可以有多个类型。比如自动映射的时候一个普通的字符串就会被映射乘text和keyword两个类型<br><img src="05-中间件\01-es\assets\自动映射.png"><br><br><br>
<br>*＊数字类型：**Iong integer short byte double float half float scaled float unsigned long
<br>Keywords:

<br>Keyword 只能精确化查找，id用keyword,keyword字段常用于排序，汇总和term查询
<br>constant_keyword：始终包含相同们的关键字字段
<br>wildcard:可针对类似grep的通配符查询优化日志行和类似的关键字值


<br>dates（时间类型）：包括date和date_nanos.
<br>alias:为现有字段定义别名。
<br>text:当一个字段是要被全文搜索的，比如Email内容、产品描述，这些字段应该使用text类型。设置text类型以后，字段内容会被分析，在生成倒排索引以前，字符串会被分析器分成一个一个词项。text类型的字段不用于排序，很少用于聚合。 &nbsp;（解释一下为啥不会为text创建正排索引：大量堆空间，尤其是 在加载高基数text字段时。字段数据一旦加载到堆中，就在该段的生命周期内保项间 持在那里。同样，加载字段数据是一个昂贵的过程，可能导致用户遇到延迟问 情况下禁用字段数据的原因）
<br><br>
<br>object: 单个json对象
<br>nested: 对象数组
<br>join: 为同一索引中的文档定义父子关系
<br><br>在 Elasticsearch 中，“term”是一个基本的搜索查询，用于匹配字段中的精确值。术语查询用于搜索在一个或多个字段中包含特定术语的文档。与全文搜索查询不同，术语查询在搜索前不分析字段中的文本。相反，它对字段的内容执行精确匹配，因此确保搜索的术语与索引中存储的术语完全匹配非常重要。<br>例如，如果您有图书索引，您可以使用term query来搜索特定的作者、书名或 ISBN 编号。例如：<br>GET /books/_search
{
    "query": {
        "term": {
            "author": "J.K. Rowling"
        }
    }
}
<br>books此查询将返回索引中具有名为authorvalue 的字段的所有文档"J.K. Rowling"。<br>当您需要对特定值（例如确切的名称、数字或日期）执行精确匹配时，术语查询很有用。当您要执行区分大小写的搜索时，它也很有用，因为术语查询在搜索之前不执行任何分析或文本规范化。<br><img src="05-中间件\01-es\assets\倒排索引简化过程.png"><br>
<img src="05-中间件\01-es\assets\相关度.png">]]></description><link>05-中间件\01-es\01-es基本概念.html</link><guid isPermaLink="false">05-中间件/01-es/01-es基本概念.md</guid><pubDate>Wed, 08 May 2024 09:05:55 GMT</pubDate><enclosure url="05-中间件\01-es\assets\自动映射.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;05-中间件\01-es\assets\自动映射.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[00-rocketmq基本使用]]></title><description><![CDATA[ 
 <br><br>下面是一个使用 Spring Boot 和 RocketMQ 的消费消息的代码示例：<br><br>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;
    &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;${rocketmq-spring-boot.version}&lt;/version&gt;
&lt;/dependency&gt;
<br><br>在 application.properties 或 application.yml 文件中设置 RocketMQ 的相关参数，例如 rocketmq.name-server：<br>spring:
  rocketmq:
    name-server: localhost:9876

<br><br>
<br>创建一个生产者类，使用 @RocketMQTemplate 注解标记该类，并自动注入 RocketMQTemplate 对象：
<br>@Component
public class TestProducer {

    @Autowired
    private RocketMQTemplate rocketMQTemplate;

    public void sendMessage(String message) {
        rocketMQTemplate.convertAndSend("test-topic", message);
    }
}

<br><br>创建一个消费者类，使用 @RocketMQMessageListener 注解标记该类，并设置相关的参数，例如 consumerGroup、topic 和 selectorExpression：<br>@Component
@RocketMQMessageListener(consumerGroup = "test-group", topic = "test-topic", selectorExpression = "*")
public class TestConsumer implements RocketMQListener&lt;String&gt; {

    @Override
    public void onMessage(String message) {
        System.out.println("Received message: " + message);
    }
}

<br>在上面的示例中，TestProducer 类使用 RocketMQTemplate 对象来发送消息。TestConsumer 类实现了 RocketMQListener&lt;String&gt; 接口，并覆盖了 onMessage 方法。在该方法中，您可以编写处理消息的业务逻辑。 @RocketMQMessageListener 注解用于指定消费者组、主题和选择器表达式。]]></description><link>05-中间件\02-mq\01-rocketmq\00-rocketmq基本使用.html</link><guid isPermaLink="false">05-中间件/02-mq/01-rocketmq/00-rocketmq基本使用.md</guid><pubDate>Wed, 10 Apr 2024 07:04:55 GMT</pubDate></item><item><title><![CDATA[01-rocketmq-学习]]></title><description><![CDATA[ 
 <br>rocketMQ 是一种开源的分布式消息传递系统，其主要功能是在不同的应用程序之间进行异步消息传递。以下是一些学习 RocketMQ 的资源：<br>
<br>官方文档：RocketMQ 官方提供了详细的文档，包括快速入门、基本概念、架构设计、高级特性等。您可以在这里开始学习 RocketMQ：<a rel="noopener nofollow" class="external-link" href="http://rocketmq.apache.org/docs/quick-start/" target="_blank">http://rocketmq.apache.org/docs/quick-start/</a>
<br>视频教程：网上有一些 RocketMQ 的视频教程，如 B 站、优酷、YouTube 等，这些视频教程可以让您更直观地了解 RocketMQ 的使用方式。
<br>示例代码：RocketMQ 官方提供了一些示例代码，可以让您快速了解 RocketMQ 的使用方式，其中包括生产者和消费者的示例代码。您可以在这里找到示例代码：<a rel="noopener nofollow" class="external-link" href="http://rocketmq.apache.org/docs/quick-start/" target="_blank">http://rocketmq.apache.org/docs/quick-start/</a>
<br>社区支持：RocketMQ 社区非常活跃，您可以在社区论坛上提出问题并获得回答。在这里，您可以找到更多的学习资源，也可以结交更多的 RocketMQ 爱好者：<a rel="noopener nofollow" class="external-link" href="http://rocketmq.apache.org/community/" target="_blank">http://rocketmq.apache.org/community/</a>
<br><br><a rel="noopener nofollow" class="external-link" href="https://blog.51cto.com/u_12132623/3065789" target="_blank">https://blog.51cto.com/u_12132623/3065789</a><br>
<a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/qq_45076180/article/details/113828472" target="_blank">https://blog.csdn.net/qq_45076180/article/details/113828472</a><br>我们将消息流程分为如下三大部分，每一部分都有可能会丢失数据。<br>生产阶段：Producer通过网络将消息发送给Broker，这个发送可能会发生丢失，比如网络延迟不可达等。<br>
存储阶段：Broker肯定是先把消息放到内存的，然后根据刷盘策略持久化到硬盘中，刚收到Producer的消息，再内存中了，但是异常宕机了，导致消息丢失。<br>
消费阶段：消费失败了其实也是消息丢失的一种变体吧。<br><br>
<br>不要使用单向发送有三种send方法，同步发送、异步发送、单向发送。我们可以采取同步发送的方式进行发送消息，发消息的时候会同步阻塞等待broker返回的结果，如果没成功，则不会收到SendResult，这种是最可靠的。其次是异步发送，再回调方法里可以得知是否发送成功.如果业务要求严格，为保证消息的成功投递和保存，我们可以只取SEND_OK标识消息发送成功，把失败的消息记录到数据库，并启动一个定时任务，扫描发送失败的消息，重新发送5次，直到成功或者发送5次后发送邮件或短信通知人工介入处理
<br>适当调大重试次数发送消息如果失败或者超时了，则会自动重试。默认是重试三次，可以根据api进行更改，比如改为10次
<br>多主多从的高可用架构防止单一broker宕机引起数据丢失  假设Broker宕机了，但是生产环境一般都是多M多S的，所以还会有其他master节点继续提供服务，这也不会影响到我们发送消息，我们消息依然可达。因为比如恰巧发送到broker的时候，broker宕机了，producer收到broker的响应发送失败了，这时候producer会自动重试，这时候宕机的broker就被踢下线了， 所以producer会换一台broker发送消息。
<br>采用事务消息
<br><br>
<br>同步刷盘？？ MQ持久化消息分为两种：同步刷盘和异步刷盘。默认情况是异步刷盘，Broker收到消息后会先存到cache里然后立马通知Producer说消息我收到且存储成功了，你可以继续你的业务逻辑了，然后Broker起个线程异步的去持久化到磁盘中，但是Broker还没持久化到磁盘就宕机的话，消息就丢失了。同步刷盘的话是收到消息存到cache后并不会通知Producer说消息已经ok了，而是会等到持久化到磁盘中后才会通知Producer说消息完事了。这也保障了消息不会丢失，但是性能不如异步高。看业务场景取舍。
<br>集群部署  多主多从 即使Broker设置了同步刷盘策略，但是Broker刷完盘后磁盘坏了，这会导致盘上的消息全TM丢了。但是如果即使是1主1从了，但是Master刷完盘后还没来得及同步给Slave就磁盘坏了，不也是GG吗？没错！所以我们还可以配置不仅是等Master刷完盘就通知Producer，而是等Master和Slave都刷完盘后才去通知Producer说消息ok了。
<br># master 节点配置
flushDiskType = SYNC_FLUSH
brokerRole=SYNC_MASTER

# slave 节点配置
brokerRole=slave
flushDiskType = SYNC_FLUSH

## Producer发消息到Broker后，Broker的Master节点先持久化到磁盘中，然后同步数据给Slave节点，Slave节点同步完且落盘完成后才会返回给Producer说消息ok了。
<br><br>
<br>同步消费，手动进行ack确认 
<br>消息消费失败自动重试
<br><br><br>rocketmq模型关系图<br>
<img src="05-中间件\02-mq\01-rocketmq\assets\rocketmq模型关系图.png"><br><br>rocketmq架构图<br>
<img src="05-中间件\02-mq\01-rocketmq\assets\rocketmq架构图.png"><br>
<br>NameServer: 提供轻量级的服务发现和路由。 每个 NameServer 记录完整的路由信息，提供等效的读写服务，并支持快速存储扩展。
<br>Broker: 通过提供轻量级的 Topic 和 Queue 机制来处理消息存储,同时支持推（push）和拉（pull）模式以及主从结构的容错机制。
<br>Producer：生产者，产生消息的实例，拥有相同 Producer Group 的 Producer 组成一个集群。
<br>Consumer：消费者，接收消息进行消费的实例，拥有相同 Consumer Group 的<br>
Consumer 组成一个集群。<br>
简单说明一下图中箭头含义，从 Broker 开始，Broker Master1 和 Broker Slave1 是主从结构，它们之间会进行数据同步，即 Date Sync。同时每个 Broker 与<br>
NameServer 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 NameServer 中。
<br>Producer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 获取 Topic 路由信息，并向提供 Topic 服务的 Broker Master 建立长连接，且定时向 Broker 发送心跳。Producer 只能将消息发送到 Broker master，但是 Consumer 则不一样，它同时和提供 Topic 服务的 Master 和 Slave  建立长连接，既可以从 Broker Master 订阅消息，也可以从 Broker Slave 订阅消息。<br><br>保证消费的幂等性   业务逻辑幂等/redis存一个键<br><br>面对大量积压的消息：<br>如果Topic下的MessageQueue配置得是足够多的（默认只有4个），那每个Consumer实际上会分配多个MessageQueue来进行消费。这个时候，就可以简单的通过增加Consumer的服务节点数量来加快消息的消费，等积压消息消费完了，再恢复成正常情况。最极限的情况是把Consumer的节点个数设置成跟MessageQueue的个数相同。但是如果此时再继续增加Consumer的服务节点就没有用了。<br>
而如果Topic下的MessageQueue配置得不够多的话，那就不能用上面这种增加Consumer节点个数的方法了。这时怎么办呢？<br>
这时如果要快速处理积压的消息，可以创建一个新的Topic，并配置足够多的MessageQueue。并紧急上线一组新的消费者，只负责搬运积压的消息，转储到新的Topic中，这个速度是可以很快的。然后在新的Topic上，就可以通过增加消费者个数来提高消费速度了。之后再根据情况恢复成正常情况。]]></description><link>05-中间件\02-mq\01-rocketmq\01-rocketmq-学习.html</link><guid isPermaLink="false">05-中间件/02-mq/01-rocketmq/01-rocketmq-学习.md</guid><pubDate>Wed, 08 May 2024 09:06:12 GMT</pubDate><enclosure url="05-中间件\02-mq\01-rocketmq\assets\rocketmq模型关系图.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;05-中间件\02-mq\01-rocketmq\assets\rocketmq模型关系图.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[02-事务消息]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage/" target="_blank">https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage/</a><br>
<a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/qq_45076180/article/details/113699185" target="_blank">https://blog.csdn.net/qq_45076180/article/details/113699185</a>]]></description><link>05-中间件\02-mq\01-rocketmq\02-事务消息.html</link><guid isPermaLink="false">05-中间件/02-mq/01-rocketmq/02-事务消息.md</guid><pubDate>Wed, 10 Apr 2024 07:05:00 GMT</pubDate></item><item><title><![CDATA[03-延迟消息]]></title><description><![CDATA[ 
 <br><br><a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/Weixiaohuai/article/details/123658301" target="_blank">https://blog.csdn.net/Weixiaohuai/article/details/123658301</a><br>RocketMQ延时消息会暂存在名为SCHEDULE_TOPIC_XXXX的<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=Topic&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://so.csdn.net/so/search?q=Topic&amp;spm=1001.2101.3001.7020" target="_blank">Topic</a>中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。<br>
SCHEDULE_TOPIC_XXXX中consumequeue中的文件夹名称就是队列的名称，并且【队列名称 = 延迟等级 - 1】；如下图，在前面的例子中，我们执定消息的延迟时间为10s，对应的延迟等级是3，所以文件夹名称为【3 - 1 = 2】
<br><img src="05-中间件\02-mq\01-rocketmq\assets\延迟队列名称.png"><br>延迟消息在RocketMQ Broker端的流转如下图所示：<br><img src="05-中间件\02-mq\01-rocketmq\assets\延迟消息在broker中流转图.png"><br>主要包含以下6个步骤：<br>
<br>(1)、修改消息Topic名称和队列信息
<br>RocketMQ Broker端在存储生产者写入的消息时，首先都会将其写入到CommitLog中。之后根据消息中的Topic信息和队列信息，将其转发到目标Topic的指定队列(ConsumeQueue)中。<br>由于消息一旦存储到ConsumeQueue中，消费者就能消费到，而延迟消息不能被立即消费，所以这里将Topic的名称修改为SCHEDULE_TOPIC_XXXX，并根据延迟级别确定要投递到哪个队列下。同时，还会将消息原来要发送到的目标Topic和队列信息存储到消息的属性中。<br>
<br>(2)、转发消息到延迟主题SCHEDULE_TOPIC_XXXX的CosumeQueue中
<br>CommitLog中的消息转发到CosumeQueue中是异步进行的。在转发过程中，会对延迟消息进行特殊处理，主要是计算这条延迟消息需要在什么时候进行投递。<br>
投递时间 = 消息存储时间(storeTimestamp) + 延迟级别对应的时间
<br>需要注意的是，会将计算出的投递时间当做消息Tag的哈希值存储到CosumeQueue中，CosumeQueue单个存储单元组成结构如下图所示：<br>
<img src="https://img-blog.csdnimg.cn/4c8470657b5b411e9c4a9661ae8981df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-P5aSp6YO96KaB6L-b5q2l5LiA54K554K5,size_9,color_FFFFFF,t_70,g_se,x_16" referrerpolicy="no-referrer"><br>其中：<br>
<br>Commit Log Offset：记录在CommitLog中的位置；
<br>Size：记录消息的大小；
<br>Message Tag HashCode：记录消息Tag的哈希值，用于消息过滤。特别的，对于延迟消息，这个字段记录的是消息的投递时间戳。这也是为什么java中hashCode方法返回一个int型，只占用4个字节，而这里Message Tag HashCode字段却设计成8个字节的原因；
<br>
<br>(3)、延迟服务消费SCHEDULE_TOPIC_XXXX消息
<br>Broker内部有一个ScheduleMessageService类，其充当延迟服务，主要是消费SCHEDULE_TOPIC_XXXX中的消息，并投递到目标Topic中。<br>ScheduleMessageService在启动时，其会创建一个定时器Timer，并根据延迟级别的个数，启动对应数量的TimerTask，每个TimerTask负责一个延迟级别的消费与投递。<br>
需要注意的是，每个TimeTask在检查消息是否到期时，首先检查对应队列中尚未投递第一条消息，如果这条消息没到期，那么之后的消息都不会检查。如果到期了，则进行投递，并检查之后的消息是否到期。
<br>
<br>(4)、将信息重新存储到CommitLog中
<br>在将消息到期后，需要投递到目标Topic。由于在第一步已经记录了原来的Topic和队列信息，因此这里重新设置，再存储到CommitLog即可。此外，由于之前Message Tag HashCode字段存储的是消息的投递时间，这里需要重新计算tag的哈希值后再存储。<br>
<br>(5)、将消息投递到目标Topic中
<br>这一步与第二步类似，不过由于消息的Topic名称已经改为了目标Topic。因此消息会直接投递到目标Topic的ConsumeQueue中，之后消费者即消费到这条消息。<br>
<br>(6)、消费者消费目标topic中的数据
]]></description><link>05-中间件\02-mq\01-rocketmq\03-延迟消息.html</link><guid isPermaLink="false">05-中间件/02-mq/01-rocketmq/03-延迟消息.md</guid><pubDate>Wed, 08 May 2024 09:06:09 GMT</pubDate><enclosure url="05-中间件\02-mq\01-rocketmq\assets\延迟队列名称.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;05-中间件\02-mq\01-rocketmq\assets\延迟队列名称.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[03-分布式锁]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/6936956908007850014" target="_blank">https://juejin.cn/post/6936956908007850014</a><br><br>Redis的SET指令扩展参数！（SET key value[EX seconds][PX milliseconds][NX|XX]），它也是原子性的！<br>SET key value[EX seconds][PX milliseconds][NX|XX]<br>
<br>NX :表示key不存在的时候，才能set成功，也即保证只有第一个客户端请求才能获得锁，而其他客户端请求只能等其释放锁，才能获取。
<br>EX seconds :设定key的过期时间，时间单位是秒。
<br>PX milliseconds: 设定key的过期时间，单位为毫秒
<br>XX: 仅当key存在时设置值
<br><br>但是呢，这个方案还是可能存在问题：<br>
<br>问题一：锁过期释放了，业务还没执行完。假设线程a获取锁成功，一直在执行临界区的代码。但是100s过去后，它还没执行完。但是，这时候锁已经过期了，此时线程b又请求过来。显然线程b就可以获得锁成功，也开始执行临界区的代码。那么问题就来了，临界区的业务代码都不是严格串行执行的啦。
<br>问题二：锁被别的线程误删。假设线程a执行完后，去释放锁。但是它不知道当前的锁可能是线程b持有的（线程a去释放锁时，有可能过期时间已经到了，此时线程b进来占有了锁）。那线程a就把线程b的锁释放掉了，但是线程b临界区业务代码可能都还没执行完呢。
<br>  这两个问题的核心都是  保证业务没执行完的时候一定是要持有锁的  只有执行完了  才手动释放锁 ，看门狗机制<br><img src="05-中间件\03-redis\assets\redisson底层原理图.png"><br><br>如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。<br>为了解决这个问题，Redis作者 antirez提出一种高级的分布式锁算法：Redlock。Redlock核心思想是这样的：<br>
搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。
<br>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。<br>  <img src="05-中间件\03-redis\assets\redlock,集群部署示意图.png"><br>
RedLock的实现步骤:如下<br>

<br>1.获取当前时间，以毫秒为单位。
<br>2.按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。
<br>3.客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+4m0s+50ms）
<br>如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。
<br>如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。

<br>简化下步骤就是：<br>
<br>按顺序向5个master节点请求加锁
<br>根据设置的超时时间来判断，是不是要跳过该master节点。
<br>如果大于等于三个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
<br>如果获取锁失败，解锁！
]]></description><link>05-中间件\03-redis\03-分布式锁.html</link><guid isPermaLink="false">05-中间件/03-redis/03-分布式锁.md</guid><pubDate>Wed, 08 May 2024 09:06:26 GMT</pubDate><enclosure url="05-中间件\03-redis\assets\redisson底层原理图.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;05-中间件\03-redis\assets\redisson底层原理图.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[04-缓存击穿(失效)，穿透，雪崩]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.51cto.com/article/703396.html" target="_blank">https://www.51cto.com/article/703396.html</a><br><br>缓存击穿（失效）指的是数据库有数据，缓存本应该也有数据，但是缓存过期了，Redis 这层流量防护屏障被击穿了，请求直奔数据库。<br>关键字：单一热点数据、高并发、数据失效。<br><img src="05-中间件\03-redis\assets\缓存击穿.png"><br><br><br>对于热点数据，我们不设置过期时间，这样就可以把请求都放在缓存中处理，充分把 Redis 高吞吐量性能利用起来。<br>或者过期时间再加一个随机值。<br>设计缓存的过期时间时，使用公式：过期时间=baes 时间+随机时间。<br>即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力。<br><br>预先把热门数据提前存入 Redis 中，并设热门数据的过期时间超大值。<br><br>当发现缓存失效的时候，不是立即从数据库加载数据。<br>而是先获取分布式锁，获取锁成功才执行数据库查询和写数据到缓存的操作，获取锁失败，则说明当前有线程在执行数据库查询操作，当前线程睡眠一段时间在重试。<br>这样只让一个请求去数据库读取数据。<br><br>意味着有特殊请求在查询一个不存在的数据，即数据不存在 Redis 也不存在于数据库。<br>导致每次请求都会穿透到数据库，缓存成了摆设，对数据库产生很大压力从而影响正常服务。<br>
<img src="05-中间件\03-redis\assets\缓存穿透.png"><br><br><br>当请求的数据不存在 Redis 也不存在数据库的时候，设置一个缺省值(比如：None)。当后续再次进行查询则直接返回空值或者缺省值。<br><br>在数据写入数据库的同时将这个 ID 同步到到布隆过滤器中，当请求的 id 不存在布隆过滤器中则说明该请求查询的数据一定没有在数据库中保存，就不要去数据库查询了。<br>BloomFilter 的算法是，首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0。<br>加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。<br>检测 key 是否存在，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在。<br><a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/6844903959061069831" target="_blank">https://juejin.cn/post/6844903959061069831</a><br><img src="05-中间件\03-redis\assets\布隆过滤器.png"><br><br>缓存雪崩指的是大量的请求无法在 Redis 缓存系统中处理，请求全部打到数据库，导致数据库压力激增，甚至宕机。<br>出现该原因主要有两种：<br>
<br>大量热点数据同时过期，导致大量请求需要查询数据库并写到缓存；
<br>Redis 故障宕机，缓存系统异常。
<br><br><br>要避免给大量的数据设置一样的过期时间，过期时间 = baes 时间+ 随机时间(较小的随机数，比如随机增加 1~5 分钟)。<br>这样一来，就不会导致同一时刻热点数据全部失效，同时过期时间差别也不会太大，既保证了相近时间失效，又能满足业务需求。<br><br>当访问的不是核心数据的时候，在查询的方法上加上接口限流保护。比如设置 10000 req/s。<br>如果访问的是核心数据接口，缓存不存在允许从数据库中查询并设置到缓存中。<br>这样的话，只有部分请求会发送到数据库，减少了压力。<br>限流，就是指，我们在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。]]></description><link>05-中间件\03-redis\04-缓存击穿(失效)，穿透，雪崩.html</link><guid isPermaLink="false">05-中间件/03-redis/04-缓存击穿(失效)，穿透，雪崩.md</guid><pubDate>Wed, 08 May 2024 09:06:19 GMT</pubDate><enclosure url="05-中间件\03-redis\assets\缓存击穿.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;05-中间件\03-redis\assets\缓存击穿.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[05-redis持久化]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/77646963" target="_blank">https://zhuanlan.zhihu.com/p/77646963</a><br><br><br>RDB持久化触发机制分为：手动触发和自动触发&nbsp;<br>
手动触发<br>
bgsave命令：就是background save，执行bgsave命令时Redis主进程会fork一个子进程来完成RDB的过程<br>
自动触发<br>
场景一：配置redis.conf，触发规则，自动执行<br># 当在规定的时间内，Redis发生了写操作的个数满足条件，会触发发生BGSAVE命令。
# save &lt;seconds&gt; &lt;changes&gt;
# 当用户设置了多个save的选项配置，只要其中任一条满足，Redis都会触发一次BGSAVE操作
save 900 1 
save 300 10 
save 60 10000
# 以上配置的含义：900秒之内至少一次写操作、300秒之内至少发生10次写操作、
# 60秒之内发生至少10000次写操作，只要满足任一条件，均会触发bgsave
<br>场景二：执行shutdown命令关闭服务器时，如果没有开启AOF持久化功能，那么会自动执行一次bgsave<br>场景三：主从同步（slave和master建立同步机制）<br>
<img src="05-中间件\03-redis\assets\redis主从同步机制.png"><br><br>Redis 使用操作系统的多进程 cow(Copy On Write) 机制来实现RDB快照持久化<br>
<br>执行bgsave命令的时候，Redis主进程会检查是否有子进程在执行RDB/AOF持久化任务，如果有的话，直接返回
<br>Redis主进程会fork一个子进程来执行执行RDB操作，fork操作会对主进程造成阻塞（影响Redis的读写），fork操作完成后会发消息给主进程，从而不再阻塞主进程。（阻塞仅指主进程fork子进程的过程，后续子进程执行操作时不会阻塞）
<br>RDB子进程会根据Redis主进程的内存生成临时的快照文件，持久化完成后会使用临时快照文件替换掉原来的RDB文件。（该过程中主进程的读写不受影响，但Redis的写操作不会同步到主进程的主内存中，而是会写到一个临时的内存区域作为一个副本）
<br>子进程完成RDB持久化后会发消息给主进程，通知RDB持久化完成（将上阶段内存副本中的增量写数据同步到主内存）
<br><br>优点<br>
<br>RDB文件小，非常适合定时备份，用于灾难恢复
<br>Redis加载RDB文件的速度比AOF快很多，因为RDB文件中直接存储的时内存数据，而AOF文件中存储的是一条条命令，需要重演命令。
<br>缺点<br>
<br>RDB无法做到实时持久化，若在两次bgsave间宕机，则会丢失区间（分钟级）的增量数据，不适用于实时性要求较高的场景
<br>RDB的cow机制中，fork子进程属于重量级操作，并且会阻塞redis主进程
<br>存在老版本的Redis不兼容新版本RDB格式文件的问题
<br><br>AOF日志是持续增量的备份，是基于写命令存储的可读的文本文件。AOF日志会在持续运行中持续增大，由于Redis重启过程需要优先加载AOF日志进行指令重放以恢复数据，恢复时间会无比漫长。所以需要定期进行AOF重写，对AOF日志进行瘦身。目前AOF是Redis持久化的主流方式。<br><br>AOF默认是关闭的，通过redis.conf配置文件进行开启<br>## 此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能  
## 只有在“yes”下，aof重写/文件同步等特性才会生效  
appendonly yes  

## 指定aof文件名称  
appendfilename appendonly.aof  

## 指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec  
appendfsync everysec  
## 在aof-rewrite期间，appendfsync是否暂缓文件同步，"no"表示“不暂缓”，“yes”表示“暂缓”，默认为“no”  
no-appendfsync-on-rewrite no  

## aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建议“512mb”  
auto-aof-rewrite-min-size 64mb  

## 相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比  
## 每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)
## aof文件增长到A*(1 + p)之后，触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。  
auto-aof-rewrite-percentage 100
<br>AOF是文件操作，对于变更操作比较密集的server，那么将造成磁盘IO的负荷加重。此外linux对文件操作采取了“延迟写入”手段，即并非每次write操作都会触发实际磁盘操作，而是进入了buffer中，当buffer数据达到阀值时触发实际写入(也有其他时机)，这是linux对文件系统的优化。<br>Linux 的glibc提供了fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷到磁盘。只要 Redis 进程实时调用 fsync 函数就可以保证 aof 日志不丢失。但是 fsync 是一个磁盘 IO 操作，它很慢！如果 Redis 执行一条指令就要 fsync 一次，那么 Redis 高性能的地位就不保了。<br>因此在上述配置文件中，可观察到Redis中提供了3中AOF记录同步选项：<br>
<br>always：每一条AOF记录都立即同步到文件，性能很低，但较为安全。
<br>everysec：每秒同步一次，性能和安全都比较中庸的方式，也是redis推荐的方式。如果遇到物理服务器故障，可能导致最多1秒的AOF记录丢失。
<br>no：Redis永不直接调用文件同步，而是让操作系统来决定何时同步磁盘。性能较好，但很不安全。
<br><br>AOF日志会在持续运行中持续增大，需要定期进行AOF重写，对AOF日志进行瘦身。<br>AOF Rewrite&nbsp;虽然是“压缩”AOF文件的过程，但并非采用“基于原AOF文件”来重写或压缩，而是采取了类似RDB快照的方式：基于Copy On Write，全量遍历内存中数据，然后逐个序列到AOF文件中。因此AOF rewrite能够正确反应当前内存数据的状态。<br>AOF重写（bgrewriteaof）和RDB快照写入（bgsave）过程类似，二者都消耗磁盘IO。Redis采取了“schedule”策略：无论是“人工干预”还是系统触发，快照和重写需要逐个被执行。<br>重写过程中，对于新的变更操作将仍然被写入到原AOF文件中，同时这些新的变更操作也会被Redis收集起来。当内存中的数据被全部写入到新的AOF文件之后，收集的新的变更操作也将被一并追加到新的AOF文件中。然后将新AOF文件重命名为appendonly.aof，使用新AOF文件替换老文件，此后所有的操作都将被写入新的AOF文件。<br><br>和RDB类似，AOF触发机制也分为：手动触发和自动触发<br>手动触发&nbsp;直接调用bgrewriteaof命令<br>redis-cli -h ip -p port bgrewriteaof
<br>自动触发<br>根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机<br>auto-aof-rewrite-min-size:表示运行AOF重写时文件最小体积，默认为64MB（我们线上是512MB）。

auto-aof-rewrite-percentage:代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的值
<br>自动触发时机：<br>(aof_current_size &gt; auto-aof-rewrite-min-size ) &amp;&amp; (aof_current_size - aof_base_size) / aof_base_size &gt;= auto-aof-rewrite-percentage<br>其中aof_current_size和aof_base_size可以在info Persistence统计信息中查看。<br><br>优点&nbsp;AOF只是追加写日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少<br>缺点<br>
<br>AOF方式生成的日志文件太大，需要不断AOF重写，进行瘦身。
<br>即使经过AOF重写瘦身，由于文件是文本文件，文件体积较大（相比于RDB的二进制文件）。
<br>AOF重演命令式的恢复数据，速度显然比RDB要慢。
<br><br>
<br>仅使用RDB快照方式恢复数据，由于快照时间粒度较大，时回丢失大量数据。
<br>仅使用AOF重放方式恢复数据，日志性能相对 rdb 来说要慢。在 Redis 实例很大的情况下，启动需要花费很长的时间。
<br>Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。将 rdb 文件的内容和增量的 AOF 日志文件存在一起。这里的 AOF 日志不再是全量的日志，而是自持久化开始到持久化结束的这段时间发生的增量 AOF 日志，通常这部分 AOF 日志很小。相当于：<br>
<br>大量数据使用粗粒度（时间上）的rdb快照方式，性能高，恢复时间快。
<br>增量数据使用细粒度（时间上）的AOF日志方式，尽量保证数据的不丢失。
<br>在 Redis 重启的时候，可以先加载 rdb 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，重启效率因此大幅得到提升。<br>混合持久化是最佳方式吗？<br>不一定。<br>首先，混合持久化是Redis 4.0才引入的特性，现在很多 公司可能都还在使用3.x版本。使用不了这一特性。<br>另外，可以使用下面这种方式。Master使用AOF，Slave使用RDB快照，master需要首先确保数据完整性，它作为数据备份的第一选择；slave提供只读服务或仅作为备机，它的主要目的就是快速响应客户端read请求或灾切换。<br>至于具体使用哪种持久化方式，就看大家根据场景选择。没有最好，只有最合适。]]></description><link>05-中间件\03-redis\05-redis持久化.html</link><guid isPermaLink="false">05-中间件/03-redis/05-redis持久化.md</guid><pubDate>Wed, 08 May 2024 09:06:21 GMT</pubDate><enclosure url="05-中间件\03-redis\assets\redis主从同步机制.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;05-中间件\03-redis\assets\redis主从同步机制.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-微服务划分依据]]></title><description><![CDATA[ 
 <br>微服务的划分可以根据业务逻辑和团队组织等因素进行划分。以下是常用的划分方式：<br>
<br>按照业务模块划分：将不同业务模块的代码分别封装到不同的微服务中，例如订单服务、支付服务、用户服务等。
<br>按照团队组织划分：根据团队组织结构的不同，将不同团队负责的业务划分到不同的微服务中，例如由前端团队负责的购物车服务、由后端团队负责的订单服务等。
<br>按照功能划分：将不同的功能划分到不同的微服务中，例如用户认证服务、文件上传服务、消息推送服务等。
<br>按照领域驱动设计（DDD）的思想进行划分：根据业务领域进行划分，将不同的领域模型封装到不同的微服务中，例如将订单模型封装到订单服务中，将用户模型封装到用户服务中等。
<br>需要根据实际业务和团队组织结构等因素进行微服务的划分，不同的划分方式都有其优缺点，需要根据具体情况进行选择。]]></description><link>06-分布式架构\01-微服务\01-微服务划分依据.html</link><guid isPermaLink="false">06-分布式架构/01-微服务/01-微服务划分依据.md</guid><pubDate>Wed, 10 Apr 2024 07:05:13 GMT</pubDate></item><item><title><![CDATA[03-负载均衡]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.bilibili.com/video/BV1mW4y1q7h9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf" target="_blank">https://www.bilibili.com/video/BV1mW4y1q7h9/?spm_id_from=333.337.search-card.all.click&amp;vd_source=4ea256e9431ae8b0e6d59aeaa6c35daf</a><br><a rel="noopener nofollow" class="external-link" href="https://www.jianshu.com/p/79b9cf0d0519" target="_blank">https://www.jianshu.com/p/79b9cf0d0519</a><br>
<a rel="noopener nofollow" class="external-link" href="https://developer.aliyun.com/article/770855" target="_blank">https://developer.aliyun.com/article/770855</a><br>
<a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/qq_37351027/article/details/123136599" target="_blank">https://blog.csdn.net/qq_37351027/article/details/123136599</a><br><a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=Ribbon&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://so.csdn.net/so/search?q=Ribbon&amp;spm=1001.2101.3001.7020" target="_blank">Ribbon</a>客户端负载均衡：<br>Ribbon是从eureka<a data-tooltip-position="top" aria-label="https://so.csdn.net/so/search?q=注册中心&amp;spm=1001.2101.3001.7020" rel="noopener nofollow" class="external-link" href="https://so.csdn.net/so/search?q=%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83&amp;spm=1001.2101.3001.7020" target="_blank">注册中心</a>服务器端上获取服务注册信息列表，缓存到本地，让后在本地实现轮训负载均衡策略。  即在客户端实现负载均衡。<br>网关和注册中心的区别  就是网关是暴露的，统一对外的  注册中心是服务内部的<br>
（1）所有应用或者服务要想对外提供服务（包括网关），必须首先到注册中心进行注册。<br>（2）所有访问通过服务网关进行访问，然后由服务网关路由到对应服务中心进行交互访问<br><br>
<br>随机 (Random)
<br>轮询 (RoundRobin)
<br>一致性哈希 (ConsistentHash)
<br>哈希 (Hash)
<br>加权（Weighted）
<br>Load Balance负载均衡是用于解决一台机器(一个进程)无法解决所有请求而产生的一种算法。像nginx可以使用负载均衡分配流量，ribbon为客户端提供负载均衡，dubbo服务调用里的负载均衡等等，很多地方都使用到了负载均衡。<br><br>一种是集中式Load Balance, 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方；<br>另一种是进程内Load Balance，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。Ribbon就属于后者，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。<br><br><br>Ribbon是比较灵活的，它对所有的组件都定义成了接口，如果对默认值不满意，可以实现这些接口配置一下，就可以将默认实现替换掉。]]></description><link>06-分布式架构\01-微服务\03-负载均衡.html</link><guid isPermaLink="false">06-分布式架构/01-微服务/03-负载均衡.md</guid><pubDate>Wed, 10 Apr 2024 07:05:16 GMT</pubDate></item><item><title><![CDATA[04-DDD]]></title><description><![CDATA[ 
 <br>传统业务方式拆，流程梳理分析到业务活动单元后去归并整合可复用的能力，形成独立的微服务。思路二按数据驱动和领域驱动的思路，先考虑数据层聚合去拆分微服务。]]></description><link>06-分布式架构\01-微服务\04-ddd.html</link><guid isPermaLink="false">06-分布式架构/01-微服务/04-DDD.md</guid><pubDate>Wed, 10 Apr 2024 07:05:18 GMT</pubDate></item><item><title><![CDATA[99-雪花id]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://segmentfault.com/a/1190000041445831" target="_blank">https://segmentfault.com/a/1190000041445831</a><br>就是时间戳 + 机器id + 序列号]]></description><link>06-分布式架构\99-雪花id.html</link><guid isPermaLink="false">06-分布式架构/99-雪花id.md</guid><pubDate>Wed, 10 Apr 2024 07:05:21 GMT</pubDate></item><item><title><![CDATA[anki模板]]></title><description><![CDATA[ 
 <br>]]></description><link>07-工具\01-anki\01-anki基本使用.html</link><guid isPermaLink="false">07-工具/01-anki/01-anki基本使用.md</guid><pubDate>Mon, 03 Jun 2024 06:34:29 GMT</pubDate></item><item><title><![CDATA[越过驾驭 Anki 前的那几道坎儿]]></title><description><![CDATA[ 
 <br>来源网址: <a rel="noopener nofollow" class="external-link" href="https://utgd.net/article/9595" target="_blank">https://utgd.net/article/9595</a><br>裁剪时间: 2024-06-03 14:54:48<br><br>和所有圈内公认出圈难的“效率神器”一样，Anki 是一款初学者不易上手的工具。几道坎儿亘在初学者面前，导致了真正应该体会到这种学习方式的人反而错过了它。<br>这篇文章的目的，就是以初学者的视角，去跨越这几道坎儿，完成思维方式的转变。让大家通过“记单词”这么一个最通俗的实例，来理解“应该怎么去拿捏 Anki 这个工具”。<br>文章结构简介：<br>
<br>
&nbsp; 理解一、二：面向纯 Anki 新人的入门知识，非纯新不用看

<br>
&nbsp; 理解三及以后：面向一直想用起来 Anki 但无法上手的读者

<br><br>了解牌组<br>打开 Anki，你是懵的。你在找你最熟悉的那个词“单词表”或者“列表（List）”，但是放眼望去，没有这个东西。你关了 Anki，告诉自己“是我不配”。打开网剧、游戏，把刚才的一切抛在脑后。<br><img alt="Anki 的主界面，找不到“单词表”" src="07-工具\01-anki\assets\1717397688-ce7ac0d886c9bf0f4a59100cfcfb5af9.png"><br>Anki 的主界面，找不到“单词表”<br>Anki 没有用“单词表”这个词，是有原因的。<br>Anki 是多种记忆方法的结合体，这些方法中的一种是“抽认卡/闪卡（Flash card）”。这种记忆方法我们国家的每个人都用过。逢年过节你走亲戚，亲戚家有小孩，你大概率会发现 亲戚家有一叠卡片，正面画着“?”，背面写着“苹（píng）果（guǒ）”。这种“抽认卡”记忆法，就是 Anki 使用的方法之一。<br>因为它是一幅幅（Deck）的抽认卡，所以 Anki 才在主界面里使用“牌组（Deck）”这个单词。创建新的单词表，就是创建牌组。<br><img alt="Anki 主界面里的“牌组”" src="07-工具\01-anki\assets\1717397688-2f4ae5c259a08f7374914afa0c4e7106.png"><br>Anki 主界面里的“牌组”<br><br>初识卡片<br>把“牌组”看作“单词表”后，你对 Anki 产生了一些亲切感。接下来的问题是：怎么加单词。<br><img alt="菜单里的“添加”按钮" src="07-工具\01-anki\assets\1717397688-282ff59d954bebfd18ea4215aac9ac05.png"><br>菜单里的“添加”按钮<br>这时候，你看到了菜单里的“添加”。你感觉应该使它，点了一下，出现了这样的界面：<br><img alt="点按“添加”后出现的界面" src="07-工具\01-anki\assets\1717397688-85f340b40c298e4c8345e373be32ebf5.png"><br>点按“添加”后出现的界面<br>“正面”、“背面”，你大概猜出了它们是什么：“正面我就写英文，背面我就写中文呗。或者反过来也行？”<br>根据这样的理解，你把正反面的中英文输了进去，然后点了界面左下角的“添加”：<br><img alt="在正面输入英文，在背面输入中文" src="07-工具\01-anki\assets\1717397688-a43b7bdff1db09c3a26d427ca47ca7f9.png"><br>在正面输入英文，在背面输入中文<br>添加完这个新单词，你还要手动关上界面。这时候你发现，这个“系统默认”的牌组（也就是单词表）后面多了一个 1。点一下看看，出现了一个按钮“开始学习”：<br><img alt="添加单词后的主界面和“开始学习”" src="07-工具\01-anki\assets\1717397688-6e21b3df6d0dd1ec1a5a39c1a83878c6.png"><br>添加单词后的主界面和“开始学习”<br>你点了这个按钮，刚才添加的新单词蹦了出来，而且是你写的卡的“正面”：<br><img alt="单词抽认卡的“正面”" src="07-工具\01-anki\assets\1717397688-f525113dd1bea067017fba327b3000e2.png"><br>单词抽认卡的“正面”<br>你当然知道这个刚加的单词是什么意思。这时候，你可以单击一下界面空白处，或者按空格键 ⎵Space 来查看卡片的“反面”。这时候你会看到之前写好的中文含义：<br><img alt="按下空格，查看“背面”的答案" src="07-工具\01-anki\assets\1717397688-1426711041569c9a252fdcb09ce5bab1.png"><br>按下空格，查看“背面”的答案<br>答案出来了。同时你还发现，屏幕下面有 4 个新的按钮：“重来”、“困难”、“良好”、“简单”。它们代表着你对这个单词当下的感觉。对 Anki 来说，这 4 个按钮则代表着不同的复习间隔。选择“简单”，代表你掌握了这个单词，也代表了对这个单词的一个学习流程结束。<br>以上两则就是对 Anki 最基础的理解。掌握了它们，你就足以做最简单的抽认卡，来开始使用 Anki 背单词。<br>但是，毫无疑问，你现在脑子里出现了一个声音——“就这？”<br><br>初步了解“笔记模板（Note Type）”<br>到了这里，你将会遇到第一个坎儿——“笔记模板”，本文也正式进入正题。<br>目前为止你会觉得 Anki 很弱，原因有很多。第一个可能是它看起来只有一种卡片——显示英文，回答中文。好像如果我们想做到相反的事“显示中文，回答英文”，我们就要再加一张卡。这实在是不方便。<br>Anki 能不能加一张卡，互为正反面呢？<br>它可以，它当然可以，它都可以，所以它才是圈内公认。但初学者就是很难直觉地明白怎么做。我们需要的“正反来回测”的功能，需要借助 Anki 里“笔记模板”来完成。而它就是驾驭 Anki 前会遇到的第一道坎儿。从位置到设定方式，这个功能都不符合初学者对此类软件的理解。所以我们接下来就来看看，怎么样通过笔记模板来实现“正反来回测”的功能。<br>我们还是用老方法，在主界面点按“添加”按钮。但是这次，我们不直接写入内容。而是在卡片的左上角的模板处，点一下“问答题”按钮：<br><img alt="添加卡片时左上角的“问答题”按钮" src="07-工具\01-anki\assets\1717397688-5db8cc46714f3286e5f701f4b2044c61.png"><br>添加卡片时左上角的“问答题”按钮<br>在弹出来的“选择笔记模板”界面中，选择“问答题（同时生成翻转的卡片）”这一选项：<br><img alt="选项：问答题（同时生成翻转的卡片）" src="07-工具\01-anki\assets\1717397688-04ca8aef0e58ce3081d43b0ddf09bcee.png"><br>选项：问答题（同时生成翻转的卡片）<br>这时候你会回到添加卡片的界面。在这里添加卡片，你就会同时得到两张卡：一张正面英文、背面中文；一张则是相反，正面中文、背面英文。<br><br>进一步了解“笔记模板”，初步了解“卡片模板（Card Templates）”<br>正反来回测解决了。但是背单词不止是一个外语单词对应一个中文意思。英文单词有不同的词性，为了更好地理解这些词性，我们还要加上例句帮助理解。我们应该怎么样把这些东西放进 Anki 的卡片里？我们应该怎么样让新加入的“例句”总是在公布答案后再显示？<br>这两个问题牵涉到两个功能：<br>
<br>
&nbsp;把例句添加到卡片：需要我们进一步了解“笔记模板（Note Type）”，了解其中的一个关键功能——字段（Field）

<br>
&nbsp;把例句在翻卡后显示：需要我们了解“卡片模板（Card Templates）”

<br>每一个后面带括号和英文的，都是 Anki 交互上的坎儿。<br>刚才我们是在添加新单词的环节，选择了“问答题（同时生成翻转的卡片）”这一项。但你想改这个笔记模板的话，你要用到另一个界面“管理笔记模板（Manage Note Type）”，打开它的方式之一是通过菜单栏的“工具（Tools）”选项：<br><img alt="管理笔记模板" src="07-工具\01-anki\assets\1717397688-07656dac644a88a8d706ca0e30d58392.png"><br>管理笔记模板<br>在这个界面，我们点按“添加”按钮。会弹出一个名为“添加笔记模板”的新菜单，这时候，我们选择“添加：问答题（同时生成翻转的卡片）”。这是因为接下来的改动，我们是基于这个模板的。当我们基于这个模板修改，那修改结果就是双面的：<br><img alt="添加：问答题（同时生成翻转的卡片）" src="07-工具\01-anki\assets\1717397688-85768b66162bee61e8de1f9fb3f7d85a.png"><br>添加：问答题（同时生成翻转的卡片）<br>我们想要的结果是：正反面中英文互换，但在公布答案之后，要显示例句和词性。<br>我把新建的模板重命名为“中英文带例句”。之后，我们要了解 Anki 里的一个关键概念——字段（Field）。我们选中“中英文带例句”这个模板，然后选择菜单里的“字段”：<br><img alt="在菜单中选择“字段”" src="07-工具\01-anki\assets\1717397688-20c230f972d6756d40418283cdc077cd.png"><br>在菜单中选择“字段”<br>这时候你会看到字段的设置界面：<br><img alt="字段的设置界面" src="07-工具\01-anki\assets\1717397688-7e107db69277134097fa8e7cde5d1c8c.png"><br>字段的设置界面<br>它告诉你：<br>
<br>
&nbsp; 现在有 2 个字段：正面和背面

<br>
&nbsp; 你可以添加、删除、重命名字段，也可以重排字段位置

<br>
&nbsp; 字体、字号等杂项设置

<br>在这里我们要加入一个新的字段：“例句”。操作很简单，点击右上角的添加，输入“例句”即可。与此同时，我们可以把“正面”改成“英文”、“背面”改为“中文”：<br><img alt="修改字段后的界面" src="07-工具\01-anki\assets\1717397688-6e301ebac9e244a352e54d8b85a144b2.png"><br>修改字段后的界面<br>添加后保存，再回到主界面，点击“添加”按钮，这时候，你会发现多了“例句”一栏：<br><img alt="在新的模板中添加单词和例句" src="07-工具\01-anki\assets\1717397688-49dfb7a4a4d01a55674a0f98d99d9b4a.png"><br>在新的模板中添加单词和例句<br>我们已经在卡片里加上了属于例句和词性的字段。接下来，你兴高采烈地开始学习，想看看卡片的展示效果。结果发现，傻了，不对啊？怎么还是只有中文和英文，词性和例句呢？<br><img alt="重新开始学习，发现卡片里并没有“词性、例句”的相关内容" src="07-工具\01-anki\assets\1717397688-418b0b8c7330c963246839f511a776e9.png"><br>重新开始学习，发现卡片里并没有“词性、例句”的相关内容<br><br>进一步了解卡片模板<br>做完上一步，你不禁感慨：Anki 的坎儿太多了，折腾这么久还没成，是不是我不配？<br>但是！现在你离终点只有一步之遥！你到达了初学者进入理解 Anki 状态的最后一道坎儿——“卡片模板（Card Templates）”。它决定了你的卡片显示什么，怎么显示，例句不能显示的问题靠它就能解决。<br>在哪打开它呢？其中一个方法是，在你添加新单词的时候：<br><img alt="添加新单词时左上角的“卡片”" src="07-工具\01-anki\assets\1717397688-684e02eb1729609b970c5af1148fdbce.png"><br>添加新单词时左上角的“卡片”<br>在编辑界面的左上角有一个“卡片（Card）”这就是编辑卡片模板的入口之一，点开它，初学者的你会再次打退堂鼓：<br><img alt="卡片模板界面" src="07-工具\01-anki\assets\1717397688-88de0f949cb26ae6b3f5b4fb788bd385.png"><br>卡片模板界面<br>这个界面有 3 个主要区域：<br>
<br>
&nbsp;卡片模板

<br>
&nbsp;内容模板

<br>
&nbsp;预览

<br>虽然视觉上是这么个顺序，但是我们讲解的时候，要先从“内容模板”开始。我们来看截图的左面，“内容模板”里，只有一个 {{英文}}。<br>这里的“英文”是我们刚才在“笔记模板”里修改的那个字段名称，为了方便我们记忆用的。如果你是对着电脑操作，你现在就可以点“内容模板”里“背面内容模板”，你会发现里面也有一个 {{中文}}，对应的也是我们曾经重命名的字段。<br>而这里的花括号 {{}}，是一种表示变量的方法。在这里，{{英文}}对应的，是这张卡里被你放进“英文”这个字段的内容（请回想起刚才对字段的介绍）。它可以是英文，也可以不是英文，但不管你放进来了什么，它都会如实反映在右边的“预览”之中。<br>我们这张卡片，我们在“英文”这个字段里填写的，就是“Essential”这个单词，所以预览之中，它显示的就是“Essential”。如果我们在编辑卡片时，在“英文”里写了另一个单词“UNTAG”，那么这里就会显示为“UNTAG”。<br>接下来，我们看卡片背面的情况，我们就会知道，为什么我们加的词性和例句刚刚没有出现：<br><img alt="卡片1：背面内容模板和预览" src="07-工具\01-anki\assets\1717397688-51273cf9215af882a5452dacf4ea3eaa.png"><br>卡片1：背面内容模板和预览<br>我们看到，在背面内容的模板和预览里，并没有“例句”这个字段。而我们先前正是在这个字段添加的词性和例句。所以解决方法很简单——直接在“背面内容模板”里，添加一个 {{例句}}，就能解决问题。<br><img alt="卡片1：加入“例句”字段后的模板及预览" src="07-工具\01-anki\assets\1717397688-1e2d4ea3949cad2b85d4b9562d2b58de.png"><br>卡片1：加入“例句”字段后的模板及预览<br>到此为止，你已经完全可以应对用 Anki 学英语背单词的主要情况了。你可以添加你想加入的字段，你知道怎么把它放在合适的位置，在适当的时机出现。<br>但是，天呐，它是居中的！你又又又想关了 Anki 刷剧打游戏了。请再坚持最后一下下，接下来你会知道，不管是“北欧极简”还是“死亡芭比粉”，Anki 不挑用户。你可以把它打扮成任何样子。<br><br>基础 CSS——左对齐<br>前面说 Anki 可以把卡片变成“死亡芭比粉”主题是真的，但（好在）因为篇幅原因，我们这里不会这么做。我们这里仅仅对 Anki 的卡片排版进行小小的微调，目的是能够同时在电脑和手机上看得舒服。<br>“主题”这个概念在 Anki 里叫“样式（Style）”。在调整 Anki 卡片的样式之前，我们一定要意识到以下层级关系（样式∈卡片模板∈笔记模板）：<br>
<br>
&nbsp;样式∈卡片模板：样式的修改，在卡片模板这一功能之中；

<br>
&nbsp;卡片模板∈笔记模板：而卡片模板的修改，则永远是针对某一笔记模板的修改

<br>所以我们修改的样式，仅对应于某一笔记模板。如果你修改了某个笔记模板的 CSS，它不会通用于其它的笔记模板，仅仅会对这一个笔记模板生效。<br>接下来，我们就来看看如何调节笔记的样式。样式调节还是卡片模板的界面进行，我们选择其中的样式：<br><img alt="“样式”中的 CSS 和效果预览" src="07-工具\01-anki\assets\1717397688-3ea7383be73bd826eda39271d0a663ce.png"><br>“样式”中的 CSS 和效果预览<br>我把图里的 CSS 用 DeepL 翻译+手动修改后贴上来，大家很容易理解各自都是干什么的：<br>
.卡 {

    字体: arial;

    字体大小：20px;

    文字对齐：居中;

    颜色：黑色;

    背景色：白色;

}

<br>我们看到问题出现在 文字对齐 这一项，它的对齐方式是“居中”。而我们习惯的排版方式是“居左”。那么“居左”应该怎么实现呢？把代码里的 center 改为 left 就可以了：<br><img alt="把居中改为居左后的的排版预览" src="07-工具\01-anki\assets\1717397688-2c8e504bbad5d1be2688c7a9bd380bd0.png"><br>把居中改为居左后的的排版预览<br>但是，你发现，字段“例句”里的内容，和字段“中文”里的内容没有换行。名词的意思后面直接加的是 “A. adjective”，看着还是别扭。<br>这时候，我们需要在两个字段之间，加一条分隔线。而这需要一个简单的 HTML 分割线标签 &lt;hr&gt;：<br><img alt="在“背面内容模板”里，加上分割线的 HTML 标签" src="07-工具\01-anki\assets\1717397688-7941436258054c1a3b0219860e550ebc.png"><br>在“背面内容模板”里，加上分割线的 HTML 标签<br>这样一来，看起来就舒服了。<br>在这一步，你需要意识到一件事——调整 Anki 卡片的“主题”有 2 种方式：<br>
<br>
&nbsp;整体样式：这是整张笔记的主题，包括背景颜色、字体、字的大小等等。

<br>
&nbsp;局部样式：你可以在卡片的正面或者背面局部地调整卡片样式，比如含义的字要比例句的大，含义居中、例句居左等。

<br>**注：局部样式里的样式优先度高于整体样式。**也就是说，如果我们在整体样式里字号设为“12”，而在局部样式里刻意把“中文”字段的字号设为“14”时，卡片最终显示的“中文”字段字号将会是“14”。<br>Anki 用到的 CSS，你大可以使用这样的搜索方法在搜索引擎来搜索：CSS 左对齐、CSS 背景色、CSS 边距、HTML 换行、HTML 分割线……然后在 Anki 的卡片样式编辑器里玩一玩就知道效果啦。<br><br>Anki 的交互就像是被打碎时间线和叙事逻辑的文学/影视作品，能用明白的人，就像爱看烧脑电影的人，乐在其中。但用不明白的人，就像是在看天书。<br>Anki 难以上手，主要是因为“笔记模板”和“卡片模板”这两个功能。理解了这两个功能，大概知道怎么用它们，就足够使用 Anki 帮你学习。这篇文章的目的是把理解这两个功能的难度降到最低，同时能比较整体地服务“背单词”这个场景，没有刻意追求全面和细致。<br>这篇文章简单小结下来，大概如下：<br>
<br>
&nbsp; 理解牌组和卡片

<br>
&nbsp; 整理、添加和修改笔记模板

<br>
&nbsp; 了解卡片模板，会用变量控制卡片里显示什么

<br>
&nbsp; 会在卡片模板里使用简单的 CSS

<br>Anki 能有今天这个地位，文章里介绍的功能甚至算不上管中窥豹。至于 Anki 其它有魅力的功能，UNTAG 会在以后逐渐介绍给大家。]]></description><link>07-工具\01-anki\02-anki新手教程（剪藏）.html</link><guid isPermaLink="false">07-工具/01-anki/02-anki新手教程（剪藏）.md</guid><pubDate>Mon, 03 Jun 2024 06:57:17 GMT</pubDate><enclosure url="07-工具\01-anki\assets\1717397688-ce7ac0d886c9bf0f4a59100cfcfb5af9.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;07-工具\01-anki\assets\1717397688-ce7ac0d886c9bf0f4a59100cfcfb5af9.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-gitIgnore]]></title><description><![CDATA[ 
 <br><br><br><br>当一个文件已经被加入到git的管理(也就是已经提交到git仓库了)  这时候我们再在 .gitignore 文件中 添加此文件 是不奏效的 需要 <br>git rm -rf --cached .
git add .
<br>然后重新提交 之后就可以了]]></description><link>07-工具\02-git\01-gitignore.html</link><guid isPermaLink="false">07-工具/02-git/01-gitIgnore.md</guid><pubDate>Wed, 10 Apr 2024 07:05:27 GMT</pubDate></item><item><title><![CDATA[01-基本知识]]></title><description><![CDATA[ 
 <br>SSH（Secure Shell 的缩写）是一种网络协议，用于加密两台计算机之间的通信，并且支持各种身份验证机制。<br>实务中，它主要用于保证远程登录和远程通信的安全，任何网络服务都可以用这个协议来加密。<br><br>历史上，网络主机之间的通信是不加密的，属于明文通信。这使得通信很不安全，一个典型的例子就是服务器登录。登录远程服务器的时候，需要将用户输入的密码传给服务器，如果这个过程是明文通信，就意味着传递过程中，线路经过的中间计算机都能看到密码，这是很可怕的。<br>SSH 就是为了解决这个问题而诞生的，它能够加密计算机之间的通信，保证不被窃听或篡改。它还能对操作者进行认证（authentication）和授权（authorization）。明文的网络协议可以套用在它里面，从而实现加密。<br><br>1995年，芬兰赫尔辛基工业大学的研究员 Tatu Ylönen 设计了 SSH 协议的第一个版本（现称为 SSH 1），同时写出了第一个实现（称为 SSH1）。<br>当时，他所在的大学网络一直发生密码嗅探攻击，他不得不为服务器设计一个更安全的登录方式。写完以后，他就把这个工具公开了，允许其他人免费使用。<br>SSH 可以替换 rlogin、TELNET、FTP 和 rsh 这些不安全的协议，所以大受欢迎，用户快速增长，1995年底已经发展到五十个国家的20,000个用户。SSH 1 协议也变成 IETF 的标准文档。<br>1995年12月，由于客服需求越来越大，Tatu Ylönen 就成立了一家公司 SCS，专门销售和开发 SSH。这个软件的后续版本，逐渐从免费软件变成了专有的商业软件。<br>SSH 1 协议存在一些安全漏洞，所以1996年又提出了 SSH 2 协议（或者称为 SSH 2.0）。这个协议与1.0版不兼容，在1997年进行了标准化，1998年推出了软件实现 SSH2。但是，官方的 SSH2 软件是一个专有软件，不能免费使用，而且 SSH1 的有些功能也没有提供。<br>1999年，OpenBSD 的开发人员决定写一个 SSH 2 协议的开源实现，这就是 OpenSSH 项目。该项目最初是基于 SSH 1.2.12 版本，那是当时 SSH1 最后一个开源版本。但是，OpenSSH 很快就完全摆脱了原始的官方代码，在许多开发者的参与下，按照自己的路线发展。OpenSSH 随 OpenBSD 2.6 版本一起提供，以后又移植到其他操作系统，成为最流行的 SSH 实现。目前，Linux 的所有发行版几乎都自带 OpenSSH。<br>现在，SSH-2 有多种实现，既有免费的，也有收费的。本书的内容主要是针对 OpenSSH。<br><br>SSH 的软件架构是服务器-客户端模式（Server - Client）。在这个架构中，SSH 软件分成两个部分：向服务器发出请求的部分，称为客户端（client），OpenSSH 的实现为 ssh；接收客户端发出的请求的部分，称为服务器（server），OpenSSH 的实现为 sshd。<br>本教程约定，大写的 SSH 表示协议，小写的 ssh 表示客户端软件。<br>另外，OpenSSH 还提供一些辅助工具软件（比如 ssh-keygen 、ssh-agent）和专门的客户端工具（比如 scp 和 sftp），这个教程也会予以介绍。]]></description><link>07-工具\03-ssh\01-阮一峰ssh\01-基本知识.html</link><guid isPermaLink="false">07-工具/03-SSH/01-阮一峰SSH/01-基本知识.md</guid><pubDate>Wed, 10 Apr 2024 07:05:32 GMT</pubDate></item><item><title><![CDATA[02-SSH客户端]]></title><description><![CDATA[ 
 <br><br>OpenSSH 的客户端是二进制程序 ssh。它在 Linux/Unix 系统的位置是/usr/local/bin/ssh。<br>Linux 系统一般都自带 ssh，如果没有就需要安装。<br># Ubuntu 和 Debian
$ sudo apt install openssh-client

# CentOS 和 Fedora
$ sudo dnf install openssh-clients
<br>安装以后，可以使用-V参数输出版本号，查看一下是否安装成功。<br>$ ssh -V
<br><br>ssh 最常见的用途就是登录服务器，这要求服务器安装并正在运行 SSH 服务器软件。<br>ssh 登录服务器的命令如下。<br>$ ssh hostname
<br>上面命令中，hostname是主机名，它可以是域名，也可能是 IP 地址或局域网内部的主机名。不指定用户名的情况下，将使用客户端的当前用户名，作为远程服务器的登录用户名。如果要指定用户名，可以采用下面的语法。<br>$ ssh user@hostname
<br>上面的命令中，用户名和主机名写在一起了，之间使用@分隔。<br>用户名也可以使用ssh的-l参数指定，这样的话，用户名和主机名就不用写在一起了。<br>$ ssh -l username host
<br>ssh 默认连接服务器的22端口，-p参数可以指定其他端口。<br>$ ssh -p 8821 foo.com
<br>上面命令连接服务器foo.com的8821端口。<br><br>ssh 连接远程服务器后，首先有一个验证过程，验证远程服务器是否为陌生地址。<br>如果是第一次连接某一台服务器，命令行会显示一段文字，表示不认识这台机器，提醒用户确认是否需要连接。<br>The authenticity of host 'foo.com (192.168.121.111)' can't be established.
ECDSA key fingerprint is SHA256:Vybt22mVXuNuB5unE++yowF7lgA/9/2bLSiO3qmYWBY.
Are you sure you want to continue connecting (yes/no)?
<br>上面这段文字告诉用户，foo.com这台服务器的指纹是陌生的，让用户选择是否要继续连接（输入 yes 或 no）。<br>所谓“服务器指纹”，指的是 SSH 服务器公钥的哈希值。每台 SSH 服务器都有唯一一对密钥，用于跟客户端通信，其中公钥的哈希值就可以用来识别服务器。<br>下面的命令可以查看某个公钥的指纹。<br>$ ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
256 da:24:43:0b:2e:c1:3f:a1:84:13:92:01:52:b4:84:ff   (ECDSA)
<br>上面的例子中，ssh-keygen -l -f命令会输出公钥/etc/ssh/ssh_host_ecdsa_key.pub的指纹。<br>ssh 会将本机连接过的所有服务器公钥的指纹，都储存在本机的~/.ssh/known_hosts文件中。每次连接服务器时，通过该文件判断是否为陌生主机（陌生公钥）。<br>在上面这段文字后面，输入yes，就可以将当前服务器的指纹也储存在本机~/.ssh/known_hosts文件中，并显示下面的提示。以后再连接的时候，就不会再出现警告了。<br>Warning: Permanently added 'foo.com (192.168.121.111)' (RSA) to the list of known hosts
<br>然后，客户端就会跟服务器建立连接。接着，ssh 就会要求用户输入所要登录账户的密码。用户输入并验证密码正确以后，就能登录远程服务器的 Shell 了。<br><br>服务器指纹可以防止有人恶意冒充远程主机。如果服务器的密钥发生变更（比如重装了 SSH 服务器），客户端再次连接时，就会发生公钥指纹不吻合的情况。这时，客户端就会中断连接，并显示一段警告信息。<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
77:a5:69:81:9b:eb:40:76:7b:13:04:a9:6c:f4:9c:5d.
Please contact your system administrator.
Add correct host key in /home/me/.ssh/known_hosts to get rid of this message.
Offending key in /home/me/.ssh/known_hosts:36
<br>上面这段文字的意思是，该主机的公钥指纹跟~/.ssh/known_hosts文件储存的不一样，必须处理以后才能连接。这时，你需要确认是什么原因，使得公钥指纹发生变更，到底是恶意劫持，还是管理员变更了 SSH 服务器公钥。<br>如果新的公钥确认可以信任，需要继续执行连接，你可以执行下面的命令，将原来的公钥指纹从~/.ssh/known_hosts文件删除。<br>$ ssh-keygen -R hostname
<br>上面命令中，hostname是发生公钥变更的主机名。<br>除了使用上面的命令，你也可以手工修改known_hosts文件，将公钥指纹删除。<br>删除了原来的公钥指纹以后，重新执行 ssh 命令连接远程服务器，将新的指纹加入known_hosts文件，就可以顺利连接了。<br><br>SSH 登录成功后，用户就进入了远程主机的命令行环境，所看到的提示符，就是远程主机的提示符。这时，你就可以输入想要在远程主机执行的命令。<br>另一种执行远程命令的方法，是将命令直接写在ssh命令的后面。<br>$ ssh username@hostname command
<br>上面的命令会使得 SSH 在登录成功后，立刻在远程主机上执行命令command。<br>下面是一个例子。<br>$ ssh foo@server.example.com cat /etc/hosts
<br>上面的命令会在登录成功后，立即远程执行命令cat /etc/hosts。<br>采用这种语法执行命令时，ssh 客户端不会提供互动式的 Shell 环境，而是直接将远程命令的执行结果输出在命令行。但是，有些命令需要互动式的 Shell 环境，这时就要使用-t参数。<br># 报错
$ ssh remote.server.com emacs
emacs: standard input is not a tty

# 不报错
$ ssh -t server.example.com emacs
<br>上面代码中，emacs命令需要一个互动式 Shell，所以报错。只有加上-t参数，ssh 才会分配一个互动式 Shell。<br><br>SSH 连接的握手阶段，客户端必须跟服务端约定加密参数集（cipher suite）。<br>加密参数集包含了若干不同的加密参数，它们之间使用下划线连接在一起，下面是一个例子。<br>TLS_RSA_WITH_AES_128_CBC_SHA
<br>它的含义如下。<br>
<br>TLS：加密通信协议
<br>RSA：密钥交换算法
<br>AES：加密算法
<br>128：加密算法的强度
<br>CBC：加密算法的模式
<br>SHA：数字签名的 Hash 函数
<br>下面是一个例子，客户端向服务器发出的握手信息。<br>Handshake protocol: ClientHello
    Version: TLS 1.2
    Random
        Client time: May 22, 2030 02:43:46 GMT
        Random bytes: b76b0e61829557eb4c611adfd2d36eb232dc1332fe29802e321ee871
    Session ID: (empty)
    Cipher Suites
        Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256”
        Suite: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256
        Suite: TLS_RSA_WITH_AES_128_GCM_SHA256
        Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA
        Suite: TLS_DHE_RSA_WITH_AES_128_CBC_SHA
        Suite: TLS_RSA_WITH_AES_128_CBC_SHA
        Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA
        Suite: TLS_RSA_WITH_RC4_128_SHA
    Compression methods
        Method: null
    Extensions
        Extension: server_name
            Hostname: www.feistyduck.com
        Extension: renegotiation_info
        Extension: elliptic_curves
            Named curve: secp256r1
            Named curve: secp384r1
        Extension: signature_algorithms
            Algorithm: sha1/rsa
            Algorithm: sha256/rsa
            Algorithm: sha1/ecdsa
            Algorithm: sha256/ecdsa”
<br>上面的握手信息（ClientHello）之中，Cipher Suites字段就是客户端列出可选的加密参数集，服务器在其中选择一个自己支持的参数集。<br>服务器选择完毕之后，向客户端发出回应。<br>Handshake protocol: ServerHello
    Version: TLS 1.2
    Random
        Server time: Mar 10, 2059 02:35:57 GMT”
        Random bytes: 8469b09b480c1978182ce1b59290487609f41132312ca22aacaf5012
    Session ID: 4cae75c91cf5adf55f93c9fb5dd36d19903b1182029af3d527b7a42ef1c32c80
    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
    Compression method: null
    Extensions
        Extension: server_name
        Extension: renegotiation_info”
<br>上面的回应信息（ServerHello）中，Cipher Suite字段就是服务器最终选定的加密参数。<br><br>ssh 命令有很多配置项，修改它的默认行为。<br>-c<br>-c参数指定加密算法。<br>$ ssh -c blowfish,3des server.example.com
# 或者
$ ssh -c blowfish -c 3des server.example.com
<br>上面命令指定使用加密算法blowfish或3des。<br>-C<br>-C参数表示压缩数据传输。<br>$ ssh -C server.example.com
<br>-D<br>-D参数指定本机的 Socks 监听端口，该端口收到的请求，都将转发到远程的 SSH 主机，又称动态端口转发，详见《端口转发》一章。<br>$ ssh -D 1080 server
<br>上面命令将本机 1080 端口收到的请求，都转发到服务器server。<br>-f<br>-f参数表示 SSH 连接在后台运行。<br>-F<br>-F参数指定配置文件。<br>$ ssh -F /usr/local/ssh/other_config
<br>上面命令指定使用配置文件other_config。<br>-i<br>-i参数用于指定私钥，意为“identity_file”，默认值为~/.ssh/id_dsa（DSA 算法）和~/.ssh/id_rsa（RSA 算法）。注意，对应的公钥必须存放到服务器，详见《密钥登录》一章。<br>$ ssh -i my-key server.example.com
<br>-l<br>-l参数指定远程登录的账户名。<br>$ ssh -l sally server.example.com
# 等同于
$ ssh sally@server.example.com
<br>-L<br>-L参数设置本地端口转发，详见《端口转发》一章。<br>$ ssh  -L 9999:targetServer:80 user@remoteserver
<br>上面命令中，所有发向本地9999端口的请求，都会经过remoteserver发往 targetServer 的 80 端口，这就相当于直接连上了 targetServer 的 80 端口。<br>-m<br>-m参数指定校验数据完整性的算法（message authentication code，简称 MAC）。<br>$ ssh -m hmac-sha1,hmac-md5 server.example.com
<br>上面命令指定数据校验算法为hmac-sha1或hmac-md5。<br>-N<br>-N参数用于端口转发，表示建立的 SSH 只用于端口转发，不能执行远程命令，这样可以提供安全性，详见《端口转发》一章。<br>-o<br>-o参数用来指定一个配置命令。<br>$ ssh -o "Keyword Value"
<br>举例来说，配置文件里面有如下内容。<br>User sally
Port 220
<br>通过-o参数，可以把上面两个配置命令从命令行传入。<br>$ ssh -o "User sally" -o "Port 220" server.example.com
<br>使用等号时，配置命令可以不用写在引号里面，但是等号前后不能有空格。<br>$ ssh -o User=sally -o Port=220 server.example.com
<br>-p<br>-p参数指定 SSH 客户端连接的服务器端口。<br>$ ssh -p 2035 server.example.com
<br>上面命令连接服务器的2035端口。<br>-q<br>-q参数表示安静模式（quiet），不向用户输出任何警告信息。<br>$ ssh –q foo.com
root’s password:
<br>上面命令使用-q参数，只输出要求用户输入密码的提示。<br>-R<br>-R参数指定远程端口转发，详见《端口转发》一章。<br>$ ssh -R 9999:targetServer:902 local
<br>上面命令需在跳板服务器执行，指定本地计算机local监听自己的 9999 端口，所有发向这个端口的请求，都会转向 targetServer 的 902 端口。<br>-t<br>-t参数在 ssh 直接运行远端命令时，提供一个互动式 Shell。<br>$ ssh -t server.example.com emacs
<br>-v<br>-v参数显示详细信息。<br>$ ssh -v server.example.com
<br>-v可以重复多次，表示信息的详细程度，比如-vv和-vvv。<br>$ ssh -vvv server.example.com
# 或者
$ ssh -v -v -v server.example.com
<br>上面命令会输出最详细的连接信息。<br>-V<br>-V参数输出 ssh 客户端的版本。<br>$ ssh –V
ssh: SSH Secure Shell 3.2.3 (non-commercial version) on i686-pc-linux-gnu
<br>上面命令输出本机 ssh 客户端版本是SSH Secure Shell 3.2.3。<br>-X<br>-X参数表示打开 X 窗口转发。<br>$ ssh -X server.example.com
<br>-1，-2<br>-1参数指定使用 SSH 1 协议。<br>-2参数指定使用 SSH 2 协议。<br>$ ssh -2 server.example.com
<br>-4，-6<br>-4指定使用 IPv4 协议，这是默认值。<br>$ ssh -4 server.example.com
<br>-6指定使用 IPv6 协议。<br>$ ssh -6 server.example.com
<br><br><br>SSH 客户端的全局配置文件是/etc/ssh/ssh_config，用户个人的配置文件在~/.ssh/config，优先级高于全局配置文件。<br>除了配置文件，~/.ssh目录还有一些用户个人的密钥文件和其他文件。下面是其中一些常见的文件。<br>
<br>~/.ssh/id_ecdsa：用户的 ECDSA 私钥。
<br>~/.ssh/id_ecdsa.pub：用户的 ECDSA 公钥。
<br>~/.ssh/id_rsa：用于 SSH 协议版本2 的 RSA 私钥。
<br>~/.ssh/id_rsa.pub：用于SSH 协议版本2 的 RSA 公钥。
<br>~/.ssh/identity：用于 SSH 协议版本1 的 RSA 私钥。
<br>~/.ssh/identity.pub：用于 SSH 协议版本1 的 RSA 公钥。
<br>~/.ssh/known_hosts：包含 SSH 服务器的公钥指纹。
<br><br>用户个人的配置文件~/.ssh/config，可以按照不同服务器，列出各自的连接参数，从而不必每一次登录都输入重复的参数。下面是一个例子。<br>Host *
     Port 2222

Host remoteserver
     HostName remote.example.com
     User neo
     Port 2112
<br>上面代码中，Host *表示对所有主机生效，后面的Port 2222表示所有主机的默认连接端口都是2222，这样就不用在登录时特别指定端口了。这里的缩进并不是必需的，只是为了视觉上，易于识别针对不同主机的设置。<br>后面的Host remoteserver表示，下面的设置只对主机remoteserver生效。remoteserver只是一个别名，具体的主机由HostName命令指定，User和Port这两项分别表示用户名和端口。这里的Port会覆盖上面Host *部分的Port设置。<br>以后，登录remote.example.com时，只要执行ssh remoteserver命令，就会自动套用 config 文件里面指定的参数。<br>
单个主机的配置格式如下。<br>$ ssh remoteserver
# 等同于
$ ssh -p 2112 neo@remote.example.com
<br>Host命令的值可以使用通配符，比如Host *表示对所有主机都有效的设置，Host *.edu表示只对一级域名为.edu的主机有效的设置。它们的设置都可以被单个主机的设置覆盖。<br><br>ssh 客户端配置文件的每一行，就是一个配置命令。配置命令与对应的值之间，可以使用空格，也可以使用等号。<br>Compression yes
# 等同于
Compression = yes
<br>#开头的行表示注释，会被忽略。空行等同于注释。<br><br>下面是 ssh 客户端的一些主要配置命令，以及它们的范例值。<br>
<br>AddressFamily inet：表示只使用 IPv4 协议。如果设为inet6，表示只使用 IPv6 协议。
<br>BindAddress 192.168.10.235：指定本机的 IP 地址（如果本机有多个 IP 地址）。
<br>CheckHostIP yes：检查 SSH 服务器的 IP 地址是否跟公钥数据库吻合。
<br>Ciphers blowfish,3des：指定加密算法。
<br>Compression yes：是否压缩传输信号。
<br>ConnectionAttempts 10：客户端进行连接时，最大的尝试次数。
<br>ConnectTimeout 60：客户端进行连接时，服务器在指定秒数内没有回复，则中断连接尝试。
<br>DynamicForward 1080：指定动态转发端口。
<br>GlobalKnownHostsFile /users/smith/.ssh/my_global_hosts_file：指定全局的公钥数据库文件的位置。
<br>Host server.example.com：指定连接的域名或 IP 地址，也可以是别名，支持通配符。Host命令后面的所有配置，都是针对该主机的，直到下一个Host命令为止。
<br>HostKeyAlgorithms ssh-dss,ssh-rsa：指定密钥算法，优先级从高到低排列。
<br>HostName myserver.example.com：在Host命令使用别名的情况下，HostName指定域名或 IP 地址。
<br>IdentityFile keyfile：指定私钥文件。
<br>LocalForward 2001 localhost:143：指定本地端口转发。
<br>LogLevel QUIET：指定日志详细程度。如果设为QUIET，将不输出大部分的警告和提示。
<br>MACs hmac-sha1,hmac-md5：指定数据校验算法。
<br>NumberOfPasswordPrompts 2：密码登录时，用户输错密码的最大尝试次数。
<br>PasswordAuthentication no：指定是否支持密码登录。不过，这里只是客户端禁止，真正的禁止需要在 SSH 服务器设置。
<br>Port 2035：指定客户端连接的 SSH 服务器端口。
<br>PreferredAuthentications publickey,hostbased,password：指定各种登录方法的优先级。
<br>Protocol 2：支持的 SSH 协议版本，多个版本之间使用逗号分隔。
<br>PubKeyAuthentication yes：是否支持密钥登录。这里只是客户端设置，还需要在 SSH 服务器进行相应设置。
<br>RemoteForward 2001 server:143：指定远程端口转发。
<br>SendEnv COLOR：SSH 客户端向服务器发送的环境变量名，多个环境变量之间使用空格分隔。环境变量的值从客户端当前环境中拷贝。
<br>ServerAliveCountMax 3：如果没有收到服务器的回应，客户端连续发送多少次keepalive信号，才断开连接。该项默认值为3。
<br>ServerAliveInterval 300：客户端建立连接后，如果在给定秒数内，没有收到服务器发来的消息，客户端向服务器发送keepalive消息。如果不希望客户端发送，这一项设为0，即客户端不会主动断开连接。
<br>StrictHostKeyChecking yes：yes表示严格检查，服务器公钥为未知或发生变化，则拒绝连接。no表示如果服务器公钥未知，则加入客户端公钥数据库，如果公钥发生变化，不改变客户端公钥数据库，输出一条警告，依然允许连接继续进行。ask（默认值）表示询问用户是否继续进行。
<br>TCPKeepAlive yes：客户端是否定期向服务器发送keepalive信息。
<br>User userName：指定远程登录的账户名。
<br>UserKnownHostsFile /users/smith/.ssh/my_local_hosts_file：指定当前用户的known_hosts文件（服务器公钥指纹列表）的位置。
<br>VerifyHostKeyDNS yes：是否通过检查 SSH 服务器的 DNS 记录，确认公钥指纹是否与known_hosts文件保存的一致。
]]></description><link>07-工具\03-ssh\01-阮一峰ssh\02-ssh客户端.html</link><guid isPermaLink="false">07-工具/03-SSH/01-阮一峰SSH/02-SSH客户端.md</guid><pubDate>Wed, 10 Apr 2024 07:05:34 GMT</pubDate></item><item><title><![CDATA[本地远程发布服务]]></title><description><![CDATA[ 
 <br><br>#!/bin/bash
# ssh-copy-id -p 52118 root@10.108.128.54
# 一键发布测试环境脚本

cd /d/gitlab/fssc-v20/v1.0-hotfix.23.0529-E7-FSSC.V20.0.20230419.01/console2.0/fssc-console/fssc-console-web

git checkout test

git pull

# 备份文件后缀
BACKUP_SUFFIX=$(date +"%Y%m%d%H%M%S")

mvn clean package -P dev --settings "/d/yuanianMaven/settings.xml" -Dmaven.test.skip=true

# 备份源文件
ssh -p 52118 root@10.108.128.54 -t "mv /yuanian/app/console/console.jar /yuanian/app/history/console.jar$BACKUP_SUFFIX"
# 复制WAR文件到目标服务器
scp -P 52118 /d/gitlab/fssc-v20/v1.0-hotfix.23.0529-E7-FSSC.V20.0.20230419.01/console2.0/fssc-console/fssc-console-web/target/console.jar root@10.108.128.54:/yuanian/app/console/console.jar

ssh -p 52118  root@10.108.128.54  &lt;&lt; EOF
# 检查服务器文件是否存在

cd /yuanian/app/console

# 重启
./console_restart.sh

EOF
]]></description><link>07-工具\03-ssh\02-常用脚本.html</link><guid isPermaLink="false">07-工具/03-SSH/02-常用脚本.md</guid><pubDate>Mon, 20 Nov 2023 05:52:51 GMT</pubDate></item><item><title><![CDATA[socket 到底是个啥]]></title><description><![CDATA[ 
 <br>来源网址: <a rel="noopener nofollow" class="external-link" href="https://mp.weixin.qq.com/s/Ebvjy132eRDOmcIL5cmxJw" target="_blank">https://mp.weixin.qq.com/s/Ebvjy132eRDOmcIL5cmxJw</a><br>
裁剪时间: 2023-08-30 10:12:34<br><br><img src="92-网络\01-socket\assets\1693361554-6550050fb9eb117fa6657c3bb4e09d72.png"><br>咸鱼运维杂谈<br>00后程序员，深耕 Linux 系统运维、开源软件运维、自动化运维等领域<br>143篇原创内容<br>公众号<br>(本篇文章文字较多，耐心看完，你会有不小的收获)<br>哈喽大家好，我是咸鱼<br>我相信大家在面试过程中或多或少都会被问到这样一个问题：你能解释一下什么是 socket 吗？<br>我记得我当初的回答很是浅显：socket 也叫套接字，用来负责不同主机程序之间的网络通信连接，socket 的表现方式由四元组（ip地址：端口）组成<br>那么今天，咸鱼将跟大家打开 socket 的神秘大门，不但要搞清楚 socket 的概念，最好还能够了解它的底层实现<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-503725735ef01af3573a5e3382ab68ae.png"><br>我们首先查看一下 socket 的翻译<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-62ab9020cabd2e5a3a870cfa817eed48.png"><br>我们看到，socket 可以翻译成插座、插头<br>那现在请想象这么一个场景：给手机充电时，你将充电插头插入电源插座里面，是不是意味着插座与充电插头连接起来了<br>在计算机世界中，socket 翻译成套接字，通过 socket 我们可以与某台服务器进行连接，而建立连接的过程，你可以脑补成将充电插头插进插座的过程<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-684b82e88a96207b0ee48d8b4efbfff5.png"><br><img alt="图片" src="92-网络\01-socket\assets\1693361554-c0c2572e19abcfdb51ed72d7d8c7f16e.png"><br>socket 使用场景<br>假设我们想要将数据从 A 电脑的某个进程传送到 B 电脑的某个进程（比如咸鱼用微信发信息给冰冰）<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-e22c5fe88affe8fd0e98dd9c860f4d22.png"><br>那么在与对方聊天的过程中，其实就是这两台电脑中的微信进程相互传输数据的过程<br>在这个过程中，两台电脑各自调用 socket 方法，然后会得到一个 fd 句柄（socket_fd），这个 fd 句柄就相当于 socket 的身份证号<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-6638b0bd281355a618ca20d936c024d9.png"><br>得到 fd 句柄之后：<br>
<br>服务端执行 bind()、listen()、accept() 方法等待客户端建立连接的请求
<br>客户端执行 connect() 方法向服务端发起连接
<br>连接建立起来之后，两端都可以执行 send()、recv() 方法来互相传递数据
<br>PS：对于不同的传输层协议，上面这个过程是不一样的，详情可以查看我之前的文章《<a data-tooltip-position="top" aria-label="http://mp.weixin.qq.com/s?__biz=MzkzNzI1MzE2Mw==&amp;mid=2247484949&amp;idx=1&amp;sn=311cb4d57ccd8fc9396b0b53d64cd8bf&amp;chksm=c2930651f5e48f4785129241943d0938431d9792d3ab6d566c67b4b1a80953e7c43cf3fef446&amp;scene=21#wechat_redirect" rel="noopener nofollow" class="external-link" href="http://mp.weixin.qq.com/s?__biz=MzkzNzI1MzE2Mw==&amp;mid=2247484949&amp;idx=1&amp;sn=311cb4d57ccd8fc9396b0b53d64cd8bf&amp;chksm=c2930651f5e48f4785129241943d0938431d9792d3ab6d566c67b4b1a80953e7c43cf3fef446&amp;scene=21#wechat_redirect" target="_blank">Python 网络编程</a>》<br>TCP 协议<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-a2a37e3f07be51d5e4553fea4ad6d749.png"><br>UDP 协议<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-636a5a0509ea56f54607ee2eb61e2efc.png"><br>socket 底层设计<br>我们知道了 socket 是用来实现网络传输功能的，它负责不同主机进程之间的网络通信连接<br>我将上面的问题改一下，把 ”socket 是什么“ 改成 ”如果让你来实现一个网络传输功能，你会怎么设计“<br>网络传输功能，简单点来讲就是两端服务器之间进行网络通信并互相收发数据，收发数据也就是读写数据<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-2098a9e73a252dad253ea907b50a6a43.png"><br>首先我们会遇到第一个问题：茫茫互联网中你怎么能找到那台梦中情机<br>聪明的你肯定会想到——ip地址！我们用 ip 地址来定位电脑<br>找到了你的梦中情机之后，你会发现，一台电脑上面这么多进程，我怎么才能找到与我通信的那个进程（比如说微信）<br>聪明的你很快就想到了用端口号（port）<br>可以这么理解，ip 地址是用来定位街区的，而端口号 port 对应这个街区中的门牌号，通过 ip +port 的组合，你可以在茫茫互联网中找到属于你的梦中情机并且与之通信<br>所以你在设计网络传输功能初期，定义了一个数据结构 sock，sock 里面包含了 ip 和 port 字段（假设用 C 语言实现）****<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-68a3ddadff54d1d05064d72cd8bbc565.png"><br>在 Linux 中（以 CentOS 7举例），在头文件/usr/include/netinet/in.h可以看到负责套接字地址的 sock 结构体<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-7eb236a18f239ffc3e0c6859bd0c3cb1.png"><br>
sin_family&nbsp;字段为&nbsp;AF_INET，sin_port&nbsp;表示端口号，sin_addr&nbsp;表示&nbsp;IPv4&nbsp;地址，是一个&nbsp;struct in_addr类型的结构体
sin6_family 字段为 AF_INET6，sin6_port 表示端口号，sin6_addr 表示 IPv6 地址，是一个 struct in6_addr 类型的结构体
<br>解决了定位问题之后，我们知道在计算机网络中有很多协议，这些协议规定了计算机之间的通信方式<br>比如你是选用可靠的 TCP 协议去进行网络通信，还是相对不可靠的 UDP 协议<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-3839bc1d3d28f7e9672fcbedf9939250.png"><br>不同的网络协议还对应着不同的网络通信场景，如果你选择了 TCP协议，你还得考虑例如滑动窗口、超时重传这些场景<br>所以有了 ip 和 port 还不行，你还需要定义新的数据结构用来维护网络协议以及对应的网络场景<br>又因为不同的网络协议中有一些功能相似的方法（例如收发数据），于是你决定将不同协议中公共的部分提取出来，通过”继承“的方式来实现功能复用<br>所以可以先定义一个名为 sock 的数据结构，然后定义”继承“ sock 的各类 sock<br>PS：Linux 内核是用 C 语言实现的，在 C 语言中没有继承这个概念，你可以简单将这个继承理解成 xx_sock 基于 sock 进行了扩展，xx_sock 是 sock 的进阶版<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-64802c64d55294b53ddd3c64c370690c.png"><br>
<br>sock：最基础的结构，用来维护任何网络协议都会用到的收发数据缓冲区（公用部分）
<br>inet_sock：负责网络传输功能的 sock，在 sock 基础上加了 TTL（网络生存时间）、ip 和 port 这些跟网络传输相关的字段信息
<br>inet_connection_sock：面向连接的 sock，在 inet_sock 基础上添加了面向连接的协议里相关字段，比如 accept 队列，数据包分片大小，握手失败，重试次数等；虽然我们现在提到面向连接的协议就是指 TCP，但从设计上 Linux 需要支持扩展其他面向连接的新协议，比如 SCTP 协议，所以说 tcp_sock 则是在这个基础上实现的真正的 TCP 协议专用 sock 结构
<br>上面例子中的这些 sock 都可以在系统上直接找到，以 CentOS 7 为例<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-4cd1812e7b295c356e7de2c2839c00b1.png"><br><img alt="图片" src="92-网络\01-socket\assets\1693361554-276502279600c27f1481a0e37abbd1a0.png"><br>现在你用代码实现了这一堆数据结构——sock，不同的 sock 分别实现自己职责内的功能（负责面向连接的数据结构 inet_connection_sock、负责 UDP 协议的数据结构 udp_sock 等等）<br>但是你需要这些 sock 去跟硬件网卡交互才能实现网络传输的功能，既然需要跟硬件交互，那就说明需要比较高的操作系统权限<br>同时考虑到性能和安全，这套数据结构不能放在用户态，需要给它放到**系统内核里面**<br>既然这套数据结构在内核里，处在用户态的程序想要用这套数据结构来实现网络传输功能该怎么办呢？<br>除此之外，处在用户态的程序并不关心也不知道你这套数据结构在底层内核是怎么操作的，功能是怎么实现的，它只关心结果<br>于是你想到了用接口调用的方式——你将一个个功能抽象一个个接口，以后别人只需要调用这些接口，就可以让内核中这一大堆复杂的数据结构去实现指定功能<br>又因为在 Linux 中一切皆文件，你索性将这些 sock 封装成文件，当用户态的程序去调用你提供的接口时，需要先创建一个 sock 文件<br>这个新生成的 sock 文件有一个文件句柄 fd，用户态的程序只需要拿着这个 fd 就可以对内核中的 sock 进行操作<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-da28feac4d26a3f0c6a5fb1728da184d.png"><br><img alt="图片" src="92-网络\01-socket\assets\1693361554-57ef451e77758dc6a7e5ea8b217e9dcf.png"><br>上面有说到，你将不同的数据结构（inet_sock、tcp_sock 等等）抽象成一个个 API 接口，以后别人只需要调用这些 API 接口就可以驱动我们写好的这一大堆复杂的数据结构去进行网络传输<br>下面列出了一些常见的接口：<br>
<br>send
<br>recv
<br>bind
<br>listen
<br>connect
<br>到这里，整个网络传输功能就已经基本实现了。上面列举出来的这些方法，其实就是 socket 提供出来的接口<br>到这里，我们对 socket 有了一个更深地了解——socket 其实相当于一个接口层，它处在内核态和用户态之间：<br>
<br>
向上用户态

<br>
为处在用户态的程序提供 API 接口，方便用户态程序实现网络传输功能

<br>
向下内核态

<br>
对网卡进行操作，负责网络传输工作

<br>或者你也可以这么理解，处在用户态的程序通过 socket 提供的接口，将网络传输的这部分工作外包给了 Linux 内核<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-0fa75c26f126e664b5e3dabe0e991509.png"><br>我们以 tcp 协议为例子来看下 python 中是如何操作 socket 的<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-5dfa2adb42013e831d8342195a132c5b.png"><br>在客户端中，程序首先调用 socket 提供的 socket 方法创建一个 socket 文件来获得 socket 句柄，然后调用 connect 方法，这时候内核会根据 socket_fd 找到对应的 sock 文件<br>再根据文件里的信息找到处在内核的 sock 结构，通过 sock 结构与服务端进行三次握手建立连接<br>连接建立好之后，客户端调用 send 方法来进行数据传输，sock 中定义了一个发送缓冲区和接收缓冲区，其实就是一个链表，链表上面放着一个个等待发送或接收的数据<br>总结<br>我们再次回到那个问题——socket 是什么？<br>sock（或 socket）是操作系统内核提供的一种数据结构，用于实现网络传输功能<br>基于不同的网络协议以及应用场景，衍生了各种类型的 sock<br>每个网络层协议都有相应的 sock 结构体来管理该层协议的连接状态和数据传输。各类 sock 操作硬件网卡，就实现了网络传输的功能<br>为了将这些功能让处在用户态的应用程序使用，不但引入了 socket 层，还将各类功能的实现方式抽象成了 API 接口，供应用程序调用<br>同时将 sock 封装成文件，应用程序就可以在用户层通过文件句柄（socket fd）来操作内核中 sock 的网络传输功能<br>这个 socket fd 是一个 int 类型的数字，而 socket 中文翻译叫做套接字，结合这个 socket fd，你是不是可以将其理解成：一套用于连接的数字<br>而 socket 分 Internet socket 和 UNIX Domain socket，两者都可以用于不同主机进程间的通信和本机进程间的通信<br>只是前者采用的是基于 IP 协议的网络通信方式，而后者采用的是基于本地文件系统的通信方式<br>关于 UNIX Domain socket，可以通过 netstat -x 查看<br><img alt="图片" src="92-网络\01-socket\assets\1693361554-5498f96527773c3fe4caa572be2f2fc9.png"><br><br>感谢阅读，**喜欢作者就动动小手**[**一键三连]**，这是我写作最大的动力]]></description><link>92-网络\01-socket\01-剪藏-socket.html</link><guid isPermaLink="false">92-网络/01-socket/01-剪藏-socket.md</guid><pubDate>Wed, 30 Aug 2023 02:12:36 GMT</pubDate><enclosure url="92-网络\01-socket\assets\1693361554-6550050fb9eb117fa6657c3bb4e09d72.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;92-网络\01-socket\assets\1693361554-6550050fb9eb117fa6657c3bb4e09d72.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[背景]]></title><description><![CDATA[ 
 <br><br>大家注意一下嗷，领导要求，现在年中了，今年的中心政策也一直在变，对于每个人的发展需要重视，大家这几天，空闲时间，写一下对自己个人发展的PPT，主题不限内容不限，但务必要重视！<br>
主要围绕自身的现状，开发能力，业务能力，风险识别能力，问题应对能力 等 展开，并给出明确的后续个人规划，精确到日期，和可量化的东西<br><br><br>现在时间：2023.07.17<br>
现状：入职时间：2023.03.28  信息技术中心综合管理部，开发工程师  费控系统的二期开发  后续计划财务共享系统的开发和费控以及OA系统的一些开发工作<br>根据以上信息帮我想一下这个ppt应该包含什么内容<br><br>自我介绍和职业目标：介绍您的基本信息、教育背景和职业目标。这将为您的个人规划提供背景和上下文。<br>开发能力和业务能力：介绍您在开发和业务方面的技能、经验和成就，例如您的编程语言技能、项目经验和贡献等。<br>风险识别能力：介绍您在工作中识别和处理潜在风险的能力，例如您如何预测和解决潜在的技术难题，如何处理项目进度延误和质量问题等。<br>问题应对能力：介绍您在工作中解决问题的能力，例如您如何识别和解决复杂的技术问题，如何协调各个团队成员，如何以客户为中心解决问题等。<br>个人规划：根据您的职业目标和职业发展路径，制定明确的个人规划，包括可量化的目标和日期。例如，您可以规划学习新技能、参加培训、拓展人脉等。<br>总结和展望：总结您的职业发展现状和个人规划，展望未来的职业发展道路和机遇，以及如何实现您的职业目标。<br><br>自我介绍和职业目标：介绍您的基本信息、教育背景和职业目标。这将为您的个人规划提供背景和上下文。<br><br>我是一个javaWeb开发工程师，有六年的经验，目前入职一家智能家电公司，担任开发工程师的职务，负责企业内部费控，财务相关系统的开发工作，我的职业目标应该有哪些呢：<br><br>作为一名有六年经验的JavaWeb开发工程师，您在智能家电公司负责费控、财务相关系统的开发工作，以下是一些可能适合您的职业目标：<br>深入了解业务：作为企业内部费控、财务系统的开发工程师，您可以更深入地了解企业的业务流程、财务结构和管理模式，以便更好地理解业务需求和开发要求，提高自己的业务分析能力。通过chatgpt了解业务<br>掌握核心技术：作为一名JavaWeb开发工程师，您可以继续深入学习Java技术，同时掌握与费控、财务相关的技术和工具，例如会计学知识、财务软件等，以提高自己的核心技术能力。<br>提高系统质量：在开发过程中，您可以注重系统质量，例如代码质量、性能优化、安全性和可靠性等方面，以提高系统的稳定性和可维护性。<br>加强团队合作：作为一名开发工程师，您需要与其他团队成员（例如产品经理、测试工程师等）紧密合作，共同推进项目的开发和实施，同时协调解决问题和提高团队效率。<br>探索新技术：随着技术的不断更新和演变，您可以持续关注新技术和工具的发展，例如云计算、大数据、人工智能等，以便在未来的工作中更好地应对新的挑战和需求。<br>总的来说，您的职业目标应该以提高业务能力、技术能力、团队合作能力和创新能力为主要方向，同时注重个人发展和职业规划的可行性和可量化性。<br><br>开发能力和业务能力：介绍您在开发和业务方面的技能、经验和成就，例如您的编程语言技能、项目经验和贡献等。<br>开发能力：六年的javaWeb的开发经验，<br>业务能力：企业内部erp,crm，业务中台，订单系统，等有丰富建设经验<br>目前对费控系统的掌握：<br>
单据，流程，组件，预算控制，权限控制，会计核算，等核心功能熟知，掌握了核心的二开能力，多语言，附件处理，OCR识别等系统功能也了解<br>
后续计划：<br>
掌握费控和其他业务系统的交互，RMS,MDM，SAP,ERP,OA,资金 完成一些和外部系统的对接工作，更近一步了解部门整个的业务，为后续财务共享和费控的对接/逐步替代打下基础<br>
学习元年的财务和税务共享系统的二开相关，逐步学习文档并在测试环境实践，并梳理成自己的文档，以便后续高效开发<br><br>开发能力和业务能力：介绍您在开发和业务方面的技能、经验和成就，例如您的编程语言技能、项目经验和贡献等。<br>开发能力：六年的javaWeb的开发经验，<br>业务能力：企业内部erp,crm，业务中台，订单系统，等有建设经验<br>目前入职一家智能家电公司，担任开发工程师的职务，负责企业内部费控，财务相关系统的开发工作<br>
我该怎么用专业一点的术语来描述我的开发和业务能力，并且怎么结合现在入职公司的业务需求场景来描述呢<br><br>针对您的开发和业务能力，以下是一些可能适合的专业术语和描述：<br>
<br>开发能力：您具有扎实的Java基础和JavaWeb开发经验，熟悉开发框架，如Spring、MyBatis等。您在开发过程中注重代码质量和可维护性，具有较强的面向对象设计能力和编程规范意识。在项目实施过程中，您能够熟练运用软件开发流程和工具，如需求分析、设计、编码、测试、持续集成等。
<br>业务能力：您在ERP、CRM、业务中台、订单系统等方面有较丰富的建设经验，能够深入了解业务流程和用户需求，为企业提供高效、可靠的软件解决方案。您能够独立承担项目开发的技术评估、设计、开发、测试和维护等工作，同时注重与业务部门和用户之间的沟通和协调。通过gpt了解业务，譬如一些流程的细则，来更好的理解业务的诉求
<br>智能家电公司业务场景：作为智能家电公司的开发工程师，您需要深入了解智能家居和智能家电领域的业务场景和技术需求，例如家庭自动化、远程控制、数据分析等。您需要熟悉智能家电的基本原理和技术架构，了解智能家电的硬件和软件开发流程，具备移动端开发和云端架构的相关技能和经验。
<br>费控和财务系统开发：作为负责费控和财务系统开发的工程师，您需要深入了解企业的财务和成本结构，了解财务和费用管理的相关法律法规和标准，以便为企业提供高效、精准的财务和费用管理解决方案。您需要熟悉财务和费用管理的相关技术和工具，例如财务软件、报表分析工具等，能够熟练使用相关技术和工具，提高财务和费用管理的效率和准确度。
<br>总的来说，您需要深入了解智能家电公司的业务场景和技术需求，同时结合自己的开发和业务能力，为企业提供高效、可靠的软件解决方案，以实现企业和个人的双赢。<br><br>风险识别能力：介绍您在工作中识别和处理潜在风险的能力，例如您如何预测和解决潜在的技术难题，如何处理项目进度延误和质量问题等。<br>目前费控系统的二期开发，需求完成都是产品和开发沟通后直接评估工时，因为对赛意的费控系统二开不够熟悉，并且缺乏文档，导致需求完成所需时间评估过于乐观，有些会延期，有些评估又过于谨慎，可以提前完成，针对这种情况，应当开发人员内部组织需求评审，和需求实现的逻辑细节，包括数据库设计，系统配置，或者一些伪代码简要描述代码实现，通过内部平时来评估出一个相对可靠的人日工时，并且加20%左右的buffer，这样开发人员的排期可信度才会高一些<br>
质量问题的话，就是用好各种代码检测工具，组织codeReview，项目进度延误的问题可能要具体问题具体看待，提前识别这种风险并积极应对很重要<br><br>风险识别能力：介绍您在工作中识别和处理潜在风险的能力，例如您如何预测和解决潜在的技术难题，如何处理项目进度延误和质量问题等。<br>目前费控系统的二期开发，需求完成都是产品和开发沟通后直接评估工时，因为对赛意的费控系统二开不够熟悉，并且缺乏文档，导致需求完成所需时间评估过于乐观，有些会延期，有些评估又过于谨慎，可以提前完成，针对这种情况，应当开发人员内部组织需求评审，和需求实现的逻辑细节，包括数据库设计，系统配置，或者一些伪代码简要描述代码实现，通过内部平时来评估出一个相对可靠的人日工时，并且加20%左右的buffer，这样开发人员的排期可信度才会高一些<br>
质量问题的话，就是用好各种代码检测工具，组织codeReview，项目进度延误的问题可能要具体问题具体看待，提前识别这种风险并积极应对很重要<br>请帮我整理润色以下我识别的这些风险，并扩展一些还有哪些风险<br><br>您在费控系统二期开发过程中识别到的风险是：<br>
<br>需求评估风险：由于对费控系统二开不够熟悉和缺乏文档，开发人员评估完成需求所需时间的准确性存在问题，有些会延期，有些评估又过于谨慎。
<br>质量问题风险：开发过程中可能会出现代码质量问题，如代码漏洞、重复代码、低效代码等，需要通过代码检测工具和code review等手段进行控制和改进。
<br>进度延误风险：由于各种原因，开发进度可能会延迟，导致项目无法按时交付或者影响项目质量。
<br>针对上述风险，您提出了一些解决方案。除此之外，还有一些其他的风险需要考虑，例如：<br>
<br>技术风险：在二次开发过程中，可能会遇到技术难题，如系统兼容性问题、性能问题、安全问题等，需要通过技术手段解决。
<br>人员风险：开发人员的离职、调岗等因素可能会影响项目进度和质量，需要加强人员管理和培训。
<br>成本风险：开发过程中可能会出现成本超支等情况，需要对项目预算进行严格控制和管理。
<br>沟通风险：开发人员和业务人员之间的沟通协调可能存在问题，导致需求理解不清、交付延迟等问题，需要加强沟通和协调。
<br>总的来说，识别和管理风险是项目管理中非常重要的一环。针对不同的风险，需要采取不同的措施进行预防和应对，以确保项目的顺利进行和成功交付。<br><br><br>我们公司准备采购一个财务共享系统，私有化部署，并且需要开发人员进行二开，在这个过程中，会有哪些风险，如果提前识别这些分享并应对呢<br><br>在采购财务共享系统并进行二次开发的过程中，可能会面临以下风险：<br>
<br>技术风险：选择的财务共享系统是否与现有的技术架构和系统环境兼容，二次开发是否需要大量的技术改造和调整。此类风险可以通过在采购前对系统的技术方案和功能特性进行评估和比较，确保选择的系统兼容性良好，并且可以与现有系统的接口进行良好的对接。
<br>安全风险：财务共享系统采用私有化部署，需要保证系统的安全性和数据的保密性。二次开发过程中，可能会涉及到敏感数据的处理和传输，需要采取相应的安全措施，如数据加密、身份验证、权限管理等。此外，还需要确保系统的漏洞和安全问题得到及时的修复和更新。
<br>成本风险：采购和二次开发一套财务共享系统需要相应的投入和成本，包括软件许可费用、开发人员工资、硬件设备和网络资源等。此类风险可以通过制定详细的项目计划和预算，确保项目的投入和产出的合理性和可行性。
<br>业务风险：财务共享系统涉及到公司的财务核心业务，二次开发需要深入了解公司的业务流程和管理模式，确保系统的功能和业务需求的匹配性。此类风险可以通过与业务部门和财务部门的沟通和协作，深入了解业务需求和流程，及时调整和优化系统功能和设计。
<br>针对上述风险，可以采取以下措施进行应对：<br>
<br>技术评估和方案比较：在采购前对财务共享系统的技术方案和功能特性进行评估和比较，确保选择的系统兼容性良好，并且可以与现有系统的接口进行良好的对接。
<br>安全措施和漏洞修复：在二次开发过程中，采取相应的安全措施，如数据加密、身份验证、权限管理等，确保系统的安全性和数据的保密性。同时，需要及时修复和更新系统的漏洞和安全问题。
<br>项目计划和预算：制定详细的项目计划和预算，确保项目的投入和产出的合理性和可行性，以避免成本风险的发生。
<br>业务需求和流程的深入了解：与业务部门和财务部门的沟通和协作，深入了解业务需求和流程，及时调整和优化系统功能和设计，避免业务风险的发生。
<br>总的来说，提前识别风险并采取相应的措施进行应对，可以有效降低采购和二次开发过程中的风险和不确定性，确保系统的稳定性和可靠性。<br><br>问题应对能力：介绍您在工作中解决问题的能力，例如您如何识别和解决复杂的技术问题，如何协调各个团队成员，如何以客户为中心解决问题等。<br><br>我是一个javaWeb开发工程师，有六年的经验，目前入职一家智能家电公司，担任开发工程师的职务，负责企业内部费控，财务相关系统的开发工作，请从以下角度：如何识别和解决复杂的技术问题，如何协调各个团队成员，如何以客户为中心解决问题    来介绍下我的问题应对能力<br><br>作为一名经验丰富的JavaWeb开发工程师，您在面对复杂的技术问题、协调团队成员和以客户为中心解决问题方面应对能力很重要。以下是您可能采用的一些方法和实践：<br>
<br>技术问题解决能力
<br>
<br>提高自身技术水平：不断学习和研究新技术，掌握技术的核心原理和应用场景。
<br>找到问题根源：对问题进行深入分析和追踪，找到问题的根源，采取针对性的解决方案。
<br>善于使用工具：熟练使用调试工具、性能分析工具、日志分析工具等，快速定位和解决问题。
<br>建立知识库：建立技术知识库，记录解决过的问题和方法，方便日后查找和应用。
<br>
<br>团队协作能力
<br>
<br>沟通协调能力：与其他团队成员进行良好的沟通和协调，建立良好的工作关系，促进团队合作。
<br>分工明确：明确团队成员的分工和职责，合理安排工作任务，确保工作高效有序进行。
<br>项目管理能力：熟练掌握项目管理工具和方法，如JIRA、Scrum等，对项目进度、质量和成本进行有效管理和控制。
<br>团队建设：注重团队建设和培训，积极提升团队成员的技术能力和工作素质，促进团队发展。
<br>
<br>以客户为中心的问题解决能力
<br>
<br>客户需求洞察力：深入理解客户的需求和期望，了解客户的业务流程和痛点，从客户角度出发解决问题。
<br>解决方案设计能力：针对客户问题，提出切实可行的解决方案，同时考虑技术、成本、效率等因素。
<br>及时响应和沟通：对客户提出的问题及时响应和解决，与客户保持良好的沟通和合作关系。
<br>用户体验优化：注重用户体验，不断优化系统界面和交互，提高系统易用性和用户满意度。
<br>总之，作为一名优秀的JavaWeb开发工程师，您需要不断提高自己的技术能力和团队协作能力，以客户为中心，注重用户体验，解决复杂的技术问题和协调团队成员，为公司的发展和客户的满意度做出贡献。]]></description><link>93-gpt\01-使用记录\20230717-职业规划.html</link><guid isPermaLink="false">93-gpt/01-使用记录/20230717-职业规划.md</guid><pubDate>Wed, 10 Apr 2024 07:05:46 GMT</pubDate></item><item><title><![CDATA[autoGPT]]></title><description><![CDATA[ 
 <br><br><br><br>AutoGPT，一个全自动可联网的AI机器人，只需给它设定一个或多个目标，它就会自动拆解成相对应的任务，并派出分身执行任务直到目标达成；并且在执行任务的同时还会不断复盘反思推演自己的行为与操作，当推进不下去时，会想另一种方式继续推进<br><br><br>Auto-GPT和ChatGPT的主要区别是，Auto-GPT可以自主运作，不需要人类代理，而ChatGPT需要大量详细的提示来完成任务。Auto-GPT生成自己的提示以完成给定的目标，并可以访问网站和搜索引擎来收集数据以完成任务。相比之下，ChatGPT需要具体的提示来确定它要做什么以及做得怎么样。Auto-GPT建立在ChatGPT的框架上，但有能力自己做决定，这是ChatGPT所不具备的功能<br><br><img alt="autoGPT区别" src="93-gpt\assets\autogpt区别.svg"><br><br><br><img alt="autoGPTstar" src="93-gpt\assets\autogptstar.svg"><br><br><br>AutoGPT背后接入的语言模型，可以是GPT-4、也可以是GPT-3.5的text-davinci-003。但是，显然这些模型是无法完成浏览网页、执行代码、发布信息的操作的。而作者的聪明在于将这些操作变成命令(包括谷歌搜索、浏览网站、读写文件、执行代码等)，让GPT-4模型选择，然后根据返回的结果进行操作。注意，这里可以理解为作者设计了一个十分精巧的prompt，然后把我们要执行的命令，基于prompt模板封装后发给GPT-4，然后根据结果来执行。<br><br><br><br><br>Q:找到现今世界上最有钱的十个人，列出他们的姓名，性别，年龄，国籍，资产净值和财富来源；把数据保存到csv表格中，关机<br><br>chatGPT：<br>
直接给出答案<br>
<img src="93-gpt\assets\toprichbychatgpt.png"><br><br>autoGPT:<br>
分析问题并逐步执行，然后给出结果：<br>
<br>任务拆解：<br>
<img src="93-gpt\assets\拆解目标.png">
<br><br>
<br>任务--&gt;具体的指令<br>
<img src="93-gpt\assets\autogpt-任务到指令.png">
<br><br>
<br>保存到csv<br>
<img src="93-gpt\assets\toprichbyautogpt.png">
<br><br>
<br>查看福布斯官网对比下结果<br>
<img src="93-gpt\assets\forbes.png">
<br><br>结论：对于需要实时联网的时效性问题的解答，autoGPT因为可以联网，时效性更高，但是chatGPT也会推出联网的插件，用上插件后这个优势就几乎没有了<br><br><br>至今为止，对人类影响最大的人是谁，列出原因<br>chatGPT:<br>
<img src="93-gpt\assets\开放性问题-chat1.png"><br><br><img src="93-gpt\assets\开放性问题-chat2.png"><br><br>autoGPT:<br>
<br>浏览网站<br>
<img src="93-gpt\assets\疯狂搜索列表.png">
<br><br>
<br>最终的网站是： <a rel="noopener nofollow" class="external-link" href="https://www.ranker.com/crowdranked-list/the-most-influential-people-of-all-time" target="_blank">https://www.ranker.com/crowdranked-list/the-most-influential-people-of-all-time</a>
<br>网站给出的rank list被autogpt采纳,但是它想重新排名，写了个Python脚本，结果得出了网站上一样的排名
<br><br>结论：<br>
这种开放性的问题<br>
chatGPT是怎么给出答案的，我们并不知道，只知道它有出色的自然语言理解能力和海量的语料库，通过预测模型给出了答案;<br>
autoGPT你可以看到思考的过程，但是这个过程也挺扯淡，通过问gpt，得到了一些臆想的网址，然后挨个去访问，访问通了就得到结果了？并且执行缓慢，程序容易出错，思路有一定借鉴意义<br><br><br>基于jdk1.8,springboot2.6.0,maven构建一个java项目，该项目可以在浏览器中预览word文档和excel文档；关闭<br>
请给出代码和pom文件<br><br>chatGPT:<br>
给出了代码  但是不能用，意料之内<br>
<img src="93-gpt\assets\附件预览-chat.jpg"><br><br>autoGPT:<br>
goals:<br>
<br>开发一个用户友好的界面，允许用户轻松上传和预览 Word 和 Excel 文档在网络浏览器。
<br>确保与各种文件格式和版本的兼容性，以最大限度地方便用户。
<br>采取强有力的保安措施，保护用户数据，防止未经授权访问上载的文件。
<br>优化性能，尽量减少加载时间，以提供无缝的用户体验。
<br>提供简明扼要的文件，以方便项目的安装和使用。
<br><br>不对劲，这也没提java呀，跑了一会一看，果然 吭哧吭哧搁那儿给我整python脚本呢，赶紧优化下prompt<br>
开发一个javaWeb项目，使用jdk1.8,springboot2.6.0，项目架构是maven,项目只需要有一个可以讲本地word和excel转换成html的功能就可以，不需要其他功能，生成这个项目，然后关闭<br><br>goals:<br>
<br>利用特定技术开发具有特定要求的 Java 网络项目。
<br>实施可靠和有效的文件转换功能，准确地将本地 Word 和 Excel 文件转换为 HTML 格式。
<br>确保项目结构合理，遵循可维护性和可扩展性方面的最佳做法。
<br>彻底测试项目，确保项目符合规定要求，没有缺陷。
<br>一旦项目成功生成，即关闭该项目。<br>
靠谱，让它跑
<br><br>执行过程：<br>
<br>搜索，<a rel="noopener nofollow" class="external-link" href="https://www.zamzar.com/convert/docx-to-html/" target="_blank">https://www.zamzar.com/convert/docx-to-html/</a>  被它找到了一个在线转化的地址，它准备用这个
<br>开始搜索怎么吧这个嵌入java程序中
<br>它找到方法了，开始写代码了
<br>写了一堆代码，然后挂掉了(openai响应失败并且达到了最大重试次数)
<br>查看了一下写的代码无法运行，任务失败
<br>重新启动，发现抛弃了上一次的结果，重头再来。。
<br><br>总结：<br>
autoGPT看似能解决复杂的问题，但是实际可用性很差，只能说是个玩具，经常报错，死循环，并且用本地缓存的话，无法继续上一次的工作，而且花费很高，占用时间很长，网上别人分享的成功案例对于一个后端开发的日常工作来说，也几乎没有可借鉴的，强行使用它来解决复杂的问题，得不偿失<br><br><br><a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=u0j_9Upb0w8&amp;ab_channel=%E6%95%A3%E6%AD%A5%E7%9A%84%E5%BD%AD%E5%AF%BC" target="_blank">https://www.youtube.com/watch?v=u0j_9Upb0w8&amp;ab_channel=%E6%95%A3%E6%AD%A5%E7%9A%84%E5%BD%AD%E5%AF%BC</a><br><img src="93-gpt\assets\使用对比.png"><br><br><img alt="autoGPT总结" src="93-gpt\assets\autogpt总结.png">]]></description><link>93-gpt\autogpt.html</link><guid isPermaLink="false">93-gpt/autoGPT.md</guid><pubDate>Wed, 08 May 2024 09:11:23 GMT</pubDate><enclosure url="93-gpt\assets\autogpt区别.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;93-gpt\assets\autogpt区别.svg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-收单]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/444418555" target="_blank">https://zhuanlan.zhihu.com/p/444418555</a><br><br>支付与收单，其实是一体两面的概念，从客户付款的角度看叫支付，从机构“搬运”资金的角度来看就叫收单，只是不同维度的阐述，当然了收单听起来更专业一些。<br>收单业务，简单理解就是资金从客户账户搬运到商务账户的过程。<br>狭义收单专指银行卡收单，也就是最早客户拿着银行卡在各种pos机上进行刷卡消费，POS机打出凭据，收银员交给客户，客户签字回收，之后商户拿着签字的凭证交给收单机构结算自己的资金，收单机构收走消费凭证记录，这个过程就是一个标准的收单。<br><br><br><br><br><br><br>]]></description><link>94-业务相关\01-财务系统\01-收单.html</link><guid isPermaLink="false">94-业务相关/01-财务系统/01-收单.md</guid><pubDate>Wed, 10 Apr 2024 07:05:56 GMT</pubDate></item><item><title><![CDATA[01-慢接口]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://blog.51cto.com/knifeedge/5010493" target="_blank">https://blog.51cto.com/knifeedge/5010493</a><br>微服务的话看看可以用链路追踪看看哪个节点哪个环节导致的缓慢.<br>
根据各个环节去看由于什么原因.<br>
不过基本问题也就是业务和环境两个方向.<br>
业务上:<br>
数据库  <a class="internal-link" data-href="../04-数据库/01-mysql/02-慢sql,锁表问题.md" href="04-数据库\01-mysql\02-慢sql,锁表问题.html" target="_self" rel="noopener nofollow">02-慢sql,锁表问题</a><br>
网络请求，依赖下游接口<br>
接口请求量暴增？<br>
环境上：<br>
服务器的资源情况,  需要排查网络、CPU使用率、内存使用率、磁盘使用率<br>
是否有大量的 gc 导致没有资源走业务逻辑;<br>举例子：遇到过  sql审核平台定时执行出了异常  导致白天产线高峰期跑批处理的脚本，导致数据库锁表，慢sql,<br>cpu: 通过top命令找出cpu占用高的进程 &nbsp;top -Hp 8418 &nbsp;找到线程 &nbsp; jstack分析线程站 &nbsp;<a rel="noopener nofollow" class="external-link" href="https://www.cnblogs.com/kongzhongqijing/articles/3630264.html" target="_blank">https://www.cnblogs.com/kongzhongqijing/articles/3630264.html</a>]]></description><link>95-产线实践\01-慢接口.html</link><guid isPermaLink="false">95-产线实践/01-慢接口.md</guid><pubDate>Wed, 10 Apr 2024 07:05:59 GMT</pubDate></item><item><title><![CDATA[01-linux]]></title><description><![CDATA[ 
 <br>Linux 系统有许多不同的发行版（也称为“distros”），每个发行版都有其独特的特点和用途。以下是一些最常见的 Linux 发行版及其主要区别：<br><br>
<br>特点：用户友好，适合初学者，有强大的社区支持。
<br>用途：桌面、服务器、开发环境。
<br>包管理器：APT（Advanced Package Tool）。
<br><br>
<br>特点：稳定性高，软件包丰富。
<br>用途：服务器、桌面。
<br>包管理器：APT。
<br><br>
<br>特点：最新的软件包和技术，社区驱动。
<br>用途：桌面、开发环境。
<br>包管理器：DNF（Dandified Yum）。
<br><br>
<br>特点：基于 Red Hat Enterprise Linux（RHEL），免费且稳定。
<br>用途：服务器。
<br>包管理器：YUM（Yellowdog Updater, Modified）。
<br><br>
<br>特点：商业支持，企业级稳定性。
<br>用途：企业服务器、商业应用。
<br>包管理器：YUM。
<br><br>
<br>包管理器：不同的发行版使用不同的包管理器，如 APT、YUM、DNF、Pacman 等。
<br>目标用户：有些发行版更适合初学者（如 Ubuntu），有些则适合高级用户（如 Arch Linux）。
<br>稳定性 vs. 最新性：有些发行版注重稳定性（如 Debian、CentOS），有些则提供最新的软件包和技术（如 Fedora）。
<br>用途：有些发行版专注于桌面用户，有些则更适合服务器环境，还有些专门用于特定用途如网络安全（如 Kali Linux）。
<br>选择合适的 Linux 发行版取决于你的具体需求和使用场景。]]></description><link>96-计算机原理\01-操作系统\01-linux.html</link><guid isPermaLink="false">96-计算机原理/01-操作系统/01-linux.md</guid><pubDate>Tue, 18 Jun 2024 06:03:33 GMT</pubDate></item><item><title><![CDATA[02-linux线程间同步的方式]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://blog.nowcoder.net/n/7571c2a5ef82480380fea53875b8187b?from=nowcoder_improve" target="_blank">https://blog.nowcoder.net/n/7571c2a5ef82480380fea53875b8187b?from=nowcoder_improve</a><br>线程间的同步方式有以下几种：<br>
<br>互斥锁：也称为互斥量，是一种保护共享资源的机制，只有获得锁的线程才能访问共享资源，其他线程则需要等待锁的释放。
<br>信号量：也称为计数器，是一种用于控制并发访问的机制，通过计数器的值来限制同时访问共享资源的线程数量。
<br>条件变量：用于在线程间同步共享资源的状态。当一个线程需要等待某个条件变量的特定值时，它可以调用wait()函数来挂起自己的执行，直到其他线程调用signal()函数将该条件变量的值改变为需要的值。
<br>屏障：用于在多个线程之间同步执行。当所有线程到达屏障时，它们会被阻塞，直到所有线程都到达屏障后才会继续执行。
<br>读写锁：也称为共享-独占锁，是一种用于控制共享资源访问的机制，允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。这种锁可以提高并发读取性能。
<br>自旋锁：是一种基于忙等待的锁，当线程尝试获取锁时，如果锁已被其他线程占用，它会不断循环检查锁是否被释放。这种锁通常用于对锁的持有时间非常短的情况下，以避免线程上下文切换的开销。
]]></description><link>96-计算机原理\01-操作系统\02-linux线程间同步的方式.html</link><guid isPermaLink="false">96-计算机原理/01-操作系统/02-linux线程间同步的方式.md</guid><pubDate>Wed, 10 Apr 2024 07:06:13 GMT</pubDate></item><item><title><![CDATA[grep]]></title><description><![CDATA[ 
 <br><br>Q: grep 是一个在 Linux 和 Unix 系统中常用的命令行工具，用于搜索文本文件中的指定字符串，并将包含该字符串的行输出到屏幕上。<br>A:下面是一些 grep 命令的用法举例：<br>
<br>搜索文件中的指定字符串并输出包含该字符串的行：
<br>grep "hello" file.txt
<br>上述命令将搜索名为 file.txt 的文件中的字符串 "hello"，并输出包含该字符串的行。<br>
<br>搜索多个文件中的指定字符串并输出包含该字符串的行：
<br>grep "hello" file1.txt file2.txt file3.txt
<br>上述命令将搜索名为 file1.txt、file2.txt 和 file3.txt 的文件中的字符串 "hello"，并输出包含该字符串的行。<br>
<br>搜索文件中的指定字符串并输出不包含该字符串的行：
<br>grep -v "hello" file.txt
<br>上述命令将搜索名为 file.txt 的文件中的字符串 "hello"，并输出不包含该字符串的行。<br>
<br>搜索文件中的指定字符串并输出包含该字符串的行及其前后若干行：
<br>grep -C 2 "hello" file.txt
<br>上述命令将搜索名为 file.txt 的文件中的字符串 "hello"，并输出包含该字符串的行及其前后 2 行。<br>
<br>搜索文件中的指定字符串并输出包含该字符串的行及其行号：
<br>grep -n "hello" file.txt
<br>上述命令将搜索名为 file.txt 的文件中的字符串 "hello"，并输出包含该字符串的行及其行号。<br>
<br>搜索文件中的指定字符串并忽略大小写：
<br>grep -i "hello" file.txt
<br>上述命令将搜索名为 file.txt 的文件中的字符串 "hello"，并忽略大小写。<br><br><br>ls -l
<br><br><br>sed -n "/2023-11-07 08:55:00/,/$(date "+%Y-%m-%d %H:%M:%S")/p" tomcat20231030_181534.log &gt; log.txt
<br><br>在 Linux 系统中，whatis 数据库是一个包含命令和程序简短描述的数据库，主要用于提供手册页（man page）标题的快速查询。whatis 命令可以用来查找命令或程序的简要说明。<br><br>
<br>基本用法：
<br>   whatis &lt;command&gt;
<br>   例如：<br>   whatis ls
<br>   输出：<br>   ls (1)               - list directory contents
<br>
<br>
更新 whatis 数据库：<br>
whatis 数据库通常需要手动更新，以确保它包含最新的手册页信息。可以使用 makewhatis 或 mandb 命令来更新数据库。

<br>使用 makewhatis：


<br>     sudo makewhatis
<br>
<br>使用 mandb：
<br>     sudo mandb
<br><br>
<br>快速查询：通过 whatis 命令，用户可以快速查询到命令或程序的简要描述，而不需要查看完整的手册页。
<br>帮助学习：对于新手来说，whatis 命令可以帮助他们快速了解系统中可用的命令及其用途。
<br><br>假设你想知道 grep 命令的用途，你可以运行：<br>whatis grep
<br>输出可能是：<br>grep (1)               - print lines that match patterns
<br>这表明 grep 命令用于打印匹配特定模式的行。<br>总之，whatis 数据库和命令是 Linux 系统中一个非常有用的工具，帮助用户快速获取命令和程序的简要信息。<br><br>
<br>search the manual page names and descriptions<br>
在 whatis 数据库中查找字符串<br>
和 man -k 是等价的
<br>[root@PrdCwgxApp01 ~]# apropos grep
bzgrep (1)           - search possibly bzip2 compressed files for a regular expression
egrep (1)            - print lines matching a pattern
fgrep (1)            - print lines matching a pattern
grep (1)             - print lines matching a pattern
msggrep (1)          - pattern matching on message catalog
pgrep (1)            - look up or signal processes based on name and other attributes
xzegrep (1)          - search compressed files for a regular expression
xzfgrep (1)          - search compressed files for a regular expression
xzgrep (1)           - search compressed files for a regular expression
zgrep (1)            - search possibly compressed files for a regular expression
zipgrep (1)          - search files in a ZIP archive for lines matching a pattern
<br><br>awk 是一个强大的文本处理工具，广泛用于 Unix 和 Linux 系统中。它可以用于对文本文件进行扫描和处理，特别适合处理结构化数据（如列状数据）。awk 命令的名字来源于其三位作者的姓氏首字母：Alfred Aho、Peter Weinberger 和 Brian Kernighan。<br><br>awk 'pattern {action}' filename
<br>
<br>pattern：模式，用于匹配输入文件中的行。
<br>action：动作，对匹配的行执行的操作。
<br>filename：要处理的文件名。
<br><br>
<br>打印文件的所有行：
<br>   awk '{print}' filename
<br>   这条命令将打印文件中的所有行。<br>
<br>打印文件的特定列：
<br>   awk '{print $1, $3}' filename
<br>   这条命令将打印文件中的第一列和第三列。$1 表示第一列，$3 表示第三列。<br>
<br>基于模式匹配的行：
<br>   awk '/pattern/ {print}' filename
<br>   这条命令将打印包含“pattern”字符串的所有行。<br>
<br>计算文件中的某列的总和：
<br>   awk '{sum += $1} END {print sum}' filename
<br>   这条命令将计算第一列的总和，并在处理完所有行后打印总和。<br>
<br>条件处理：
<br>   awk '$3 &gt; 50 {print $1, $3}' filename
<br>   这条命令将打印第三列值大于50的行的第一列和第三列。<br>
<br>使用内置变量：

<br>NR：当前记录数（行号）。
<br>NF：当前记录中的字段数。


<br>   awk '{print NR, $0}' filename
<br>   这条命令将打印行号和该行的内容。<br>
<br>使用 BEGIN 和 END 块：
<br>   awk 'BEGIN {print "Start"} {print $0} END {print "End"}' filename
<br>   这条命令将在处理文件之前打印 "Start"，然后打印文件的每一行，最后在处理完文件后打印 "End"。<br><br>假设有一个名为 data.txt 的文件，其内容如下：<br>John Doe  30
Jane Doe  25
Alice    28
Bob      22
<br>你可以使用 awk 来完成各种任务：<br>
<br>打印所有名字和年龄：
<br>  awk '{print $1, $2, $3}' data.txt
<br>
<br>只打印年龄大于25的人：
<br>  awk '$3 &gt; 25 {print $1, $2, $3}' data.txt
<br>
<br>计算平均年龄：
<br>  awk '{sum += $3; count++} END {print "Average age:", sum/count}' data.txt
<br>总之，awk 是一个非常强大且灵活的文本处理工具，适用于各种文本处理任务。通过组合不同的模式和动作，你可以用 awk 实现复杂的数据处理和分析。<br>借助&nbsp;-v选项&nbsp;，可以将外部值（并非来自stdin）传递给awk：<br>[root@PrdCwgxApp01 ~]# VAR=100
[root@PrdCwgxApp01 ~]# echo | awk '{print $VAR}'

[root@PrdCwgxApp01 ~]# echo | awk -v var=$VAR '{print var}'
100
<br>更多awk 参考： <a data-tooltip-position="top" aria-label="https://wangchujiang.com/linux-command/c/awk.html" rel="noopener nofollow" class="external-link" href="https://wangchujiang.com/linux-command/c/awk.html" target="_blank">awk详细用法</a><br><br>编码字符串<br>printf foo|base64
<br>编码文件<br>base64 file
<br>解码<br>printf Zm9v|base64 -d
<br>解码文件<br>base64 -d file
<br><br>在指定的时间运行任务，，可以使用 at 命令。at 命令允许你指定具体的时间和日期来执行任务。<br><br> 要在今天下午 3 点运行一个脚本 myscript.sh，可以这样做：<br>echo "/path/to/myscript.sh" | at 15:00
<br> 交互式方式<br>你也可以直接输入 at 命令，进入交互式模式，然后输入你希望执行的命令。结束输入后，按 Ctrl + D 提交任务。<br>at 15:00
at&gt; /path/to/myscript.sh
at&gt; &lt;Ctrl+D&gt;退出交互模式
<br><br>at 命令支持多种时间格式，包括：<br>
<br>HH:MM: 例如 15:00 表示今天的下午 3 点。
<br>midnight: 表示今天的午夜。
<br>noon: 表示今天的中午 12 点。
<br>teatime: 表示今天的下午 4 点。
<br>now + time: 例如 now + 1 hour 表示从现在起 1 小时后。
<br>MMDDYY 或 MM/DD/YY: 例如 12/31/23 表示 2023 年 12 月 31 日。
<br>relative time: 例如 now + 2 days 或 tomorrow + 2 hours。
<br>假设你要在明天早上 9 点运行一个脚本 backup.sh，你可以使用以下命令：<br>echo "/path/to/backup.sh" | at 09:00 tomorrow
<br><br>要查看已提交但尚未执行的任务，可以使用 atq 命令：<br>atq
<br><br>atrm &lt;job_number&gt;
<br>batch用法和at基本一致 但是不能指定时间 而是在系统负载较低时自动运行<br><br>]]></description><link>96-计算机原理\01-操作系统\03-linux常用命令.html</link><guid isPermaLink="false">96-计算机原理/01-操作系统/03-linux常用命令.md</guid><pubDate>Wed, 19 Jun 2024 07:49:20 GMT</pubDate></item><item><title><![CDATA[本地远程发布脚本]]></title><description><![CDATA[ 
 <br><br>#!/bin/bash
# ssh-copy-id -p 52118 root@10.108.128.54
# 一键发布测试环境脚本

cd /d/gitlab/fssc-v20/v1.0-hotfix.23.0529-E7-FSSC.V20.0.20230419.01/console2.0/fssc-console/fssc-console-web

git checkout test

git pull

# 备份文件后缀
BACKUP_SUFFIX=$(date +"%Y%m%d%H%M%S")

mvn clean package -P dev --settings "/d/yuanianMaven/settings.xml" -Dmaven.test.skip=true

# 备份源文件
ssh -p 52118 root@10.108.128.54 -t "mv /yuanian/app/console/console.jar /yuanian/app/history/console.jar$BACKUP_SUFFIX"
# 复制WAR文件到目标服务器
scp -P 52118 /d/gitlab/fssc-v20/v1.0-hotfix.23.0529-E7-FSSC.V20.0.20230419.01/console2.0/fssc-console/fssc-console-web/target/console.jar root@10.108.128.54:/yuanian/app/console/console.jar

ssh -p 52118  root@10.108.128.54  &lt;&lt; EOF
# 检查服务器文件是否存在

cd /yuanian/app/console

# 重启
./console_restart.sh

EOF
]]></description><link>96-计算机原理\01-操作系统\04-常用脚本.html</link><guid isPermaLink="false">96-计算机原理/01-操作系统/04-常用脚本.md</guid><pubDate>Mon, 20 Nov 2023 05:51:59 GMT</pubDate></item><item><title><![CDATA[导航]]></title><description><![CDATA[<a class="tag" href="?query=tag:flashcard" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#flashcard</a> 
 <br><br>pwd<br>
ls<br>
cd<br><br>[root@VM-0-11-opencloudos bin]# ls -l /bin
lrwxrwxrwx 1 root root 7 Jan  8 04:59 /bin -&gt; usr/bin
<br>ls -l 一图解释 <a href=".?query=tag:flashcard" class="tag" target="_blank" rel="noopener nofollow">#flashcard</a><br>
<img src="96-计算机原理\01-操作系统\assets\ls-l一图解释.png"><br><br><br><br>参数用空格来分隔 如果我们的参数里本身就带空格怎么办呢 用转义字符<br>echo hello\ world
<br> 或者用引号<br>echo "hello world"
<br> 当我们创建文件 目录时，这个知识点比较有用<br>mkdir my photos 
<br> 因为上面的命令会创建两个目录<br>[root@VM-0-11-opencloudos home]# pwd
/home
[root@VM-0-11-opencloudos home]# ls
[root@VM-0-11-opencloudos home]# mkdir my photos
[root@VM-0-11-opencloudos home]# ls
my  photos
<br><br>| 管道符<br><br><br>ubuntu:<br>apt-get update 
apt-get install xxx
<br>centos：<br>sudo yum install xxx
sudo yum update xxx
]]></description><link>96-计算机原理\01-操作系统\05-shell-basic.html</link><guid isPermaLink="false">96-计算机原理/01-操作系统/05-shell-basic.md</guid><pubDate>Tue, 18 Jun 2024 05:44:53 GMT</pubDate><enclosure url="96-计算机原理\01-操作系统\assets\ls-l一图解释.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;96-计算机原理\01-操作系统\assets\ls-l一图解释.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-制品]]></title><description><![CDATA[ 
 <br>什么是制品<br>制品库顾名思义是制品的仓库，制品是软件交付的成果性产物，通常是可运行的二进制形式，因此制品库通常也被称之为二进制制品仓库<br>软件制品是指可在服务器上直接运行的二进制形式的文件，通常称之为二进制软件制品。 不同开发语言所产生的制品的获取、使用、共享方式不同，二进制制品仓库能够统一管理所有开发语言类型的二进制制品，同时无缝对接现有的标准化构建和发布工具。<br>业内： <a data-tooltip-position="top" aria-label="https://www.jfrogchina.com/blog/comprehend-artifactory/" rel="noopener nofollow" class="external-link" href="https://www.jfrogchina.com/blog/comprehend-artifactory/" target="_blank">jfrog</a>   nexus<br>
<img src="97-运维\00-一些概念\assets\什么是制品.png"><br>制品在流程中：<br>
<img src="97-运维\00-一些概念\assets\制品在流程中.png">]]></description><link>97-运维\00-一些概念\01-制品.html</link><guid isPermaLink="false">97-运维/00-一些概念/01-制品.md</guid><pubDate>Wed, 08 May 2024 09:12:00 GMT</pubDate><enclosure url="97-运维\00-一些概念\assets\什么是制品.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;97-运维\00-一些概念\assets\什么是制品.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-docker入门]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank">https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a><br><br>linux的容器化技术：Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。<br>
目前最流行的 Linux 容器解决方案<br><br>Docker 把应用程序及其依赖，打包在 image 文件里面 只有通过这个文件，才能生成 Docker 容器。dockerHub就是存放image文件的公共仓库<br>bash
# 列出本机的所有 image 文件。
$ docker image ls

# 删除 image 文件
$ docker image rm [imageName]
<br><br># 拉取镜像
docker image pull hello-world

# 运行镜像 若本地不存在 会从远程仓库自动抓取 image 文件
docker container run hello-world

# 杀掉运行的容器
docker container kill [containID]

<br><br>image 文件生成的容器实例，本身也是一个文件，称为容器文件也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。<br># 列出本机正在运行的容器
$ docker container ls

# 列出本机所有容器，包括终止运行的容器
$ docker container ls --all

# 杀掉运行的容器
docker container kill [containID]

# 终止运行的容器文件，依然会占据硬盘空间 删除容器文件
docker container rm [containerID]
<br><br><br>$ git clone https://github.com/ruanyf/koa-demos.git
$ cd koa-demos
<br>源码大致如下：<br>
<img src="97-运维\01-容器化\01-docker\assets\pasted-image-20230226222414.png"><br><br>FROM node:8.4
COPY . /app
WORKDIR /app
RUN npm install --registry=https://registry.npm.taobao.org
EXPOSE 3000
<br>
<br>FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。
<br>COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。
<br>WORKDIR /app：指定接下来的工作路径为/app。
<br>RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。
<br>EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。
<br><br>$ docker image build -t koa-demo .
# 或者
$ docker image build -t koa-demo:0.0.1 .
<br>-t参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是latest。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。<br><br>docker container run命令会从 image 文件生成容器。<br>$ docker container run -p 8000:3000 -it koa-demo /bin/bash
# 或者
$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash
<br>上面命令的各个参数含义如下：<br>
<br>-p参数：容器的 3000 端口映射到本机的 8000 端口。
<br>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。
<br>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。
<br>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。
<br>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。<br>root@66d80f4aaf1e:/app#
<br>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。<br>root@66d80f4aaf1e:/app# node demos/01.js
<br>这样容器里就启动了nodejs应用<br>
如果你的dockerfile里多一个CMD命令<br>FROM node:8.4
COPY . /app
WORKDIR /app
RUN npm install --registry=https://registry.npm.taobao.org
EXPOSE 3000
CMD node demos/01.js
<br>它表示容器启动后自动执行node demos/01.js。<br>
你可能会问，RUN命令与CMD命令的区别在哪里？简单说，RUN命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；CMD命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个RUN命令，但是只能有一个CMD命令。<br>注意，指定了CMD命令以后，docker container run命令就不能附加命令了（比如前面的/bin/bash），否则它会覆盖CMD命令。现在，启动容器可以使用下面的命令。<br>$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1
<br><br>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。<br>（1）docker container start<br>前面的docker container run命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用docker container start命令，它用来启动已经生成、已经停止运行的容器文件。<br>
$ docker container start [containerID]
<br>（2）docker container stop<br>前面的docker container kill命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而docker container stop命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。<br>
$ docker container stop [containerID]
<br>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。<br>（3）docker container logs<br>docker container logs命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令查看输出。<br>
$ docker container logs [containerID]
<br>（4）docker container exec<br>docker container exec命令用于进入一个正在运行的 docker 容器。如果docker run命令运行容器的时候，没有使用-it参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。<br>
$ docker container exec -it [containerID] /bin/bash
<br>（5）docker container cp<br>docker container cp命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。<br>
$ docker container cp [containID]:[/path/to/file] .
]]></description><link>97-运维\01-容器化\01-docker\01-docker入门.html</link><guid isPermaLink="false">97-运维/01-容器化/01-docker/01-docker入门.md</guid><pubDate>Wed, 08 May 2024 09:12:07 GMT</pubDate><enclosure url="97-运维\01-容器化\01-docker\assets\pasted-image-20230226222414.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;97-运维\01-容器化\01-docker\assets\pasted-image-20230226222414.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-Prometheus(普罗米修斯)]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/321286313" target="_blank">https://zhuanlan.zhihu.com/p/321286313</a><br>普罗米修斯(Prometheus)是一个SoundCloud公司开源的监控系统。当年，由于SoundCloud公司生产了太多的服务，传统的监控已经无法满足监控需求，于是他们在2012年决定着手开发新的监控系统，即普罗米修斯。<br>普罗米修斯（下称普罗）的作者 Matt T.Proud 在2012年加入SoundCloud公司，他从google的监控系统Borgmon中获得灵感，与另一名工程师Julius Volz合作开发了开源的普罗，后来其他开发人员陆续加入到该项目，最终于2015年正式发布。<br>普罗基于Go语言开发，其架构图如下：<br><img src="https://pic3.zhimg.com/v2-0ff3a54dfa1284f61e124405dd25c9aa_b.jpg" referrerpolicy="no-referrer"><br>其中：<br>
<br>Prometheus Server: 用数据的采集和存储，PromQL查询，报警配置。
<br>Push gateway: 用于批量，短期的监控数据的汇报总节点。
<br>Exporters: 各种汇报数据的exporter，例如汇报机器数据的node_exporter，汇报MondogDB信息的 MongoDB_exporter 等等。
<br>Alertmanager: 用于高级通知管理。
<br><br>要采集目标（主机或服务）的监控数据，首先就要在被采集目标上安装采集组件，这种采集组件被称为Exporter。<a data-tooltip-position="top" aria-label="https://link.zhihu.com/?target=http%3A//prometheus.io" rel="noopener nofollow" class="external-link" href="https://link.zhihu.com/?target=http%3A//prometheus.io" target="_blank">http://prometheus.io</a>官网上有很多这种exporter，比如：<br>Consul exporter (official)<br>
Memcached exporter (official)<br>
MySQL server exporter (official)<br>
Node/system metrics exporter (official)<br>
HAProxy exporter (official)<br>
RabbitMQ exporter<br>
Grok exporter<br>
InfluxDB exporter (official)<br>这些exporter能为我们采集目标的监控数据，然后传输给普罗米修斯。这时候，exporter会暴露一个http接口，普罗米修斯通过HTTP协议使用Pull的方式周期性拉取相应的数据。<br>不过，普罗也提供了Push模式来进行数据传输，通过增加Push Gateway这个中间商实现，你可以将数据推送到Push Gateway，普罗再通过Pull的方式从Push Gateway获取数据。<br>这就是为什么你从架构图里能看到两个 Pull metrics 的原因，一个是采集器直接被Server拉取数据(pull)；另一个是采集器主动Push数据到Push Gateway，Server再对Push Gateway主动拉取数据(pull)。<br>采集数据的主要流程如下：<br>1. Prometheus server 定期从静态配置的主机或服务发现的 targets 拉取数据（zookeeper，consul，DNS SRV Lookup等方式）<br>2. 当新拉取的数据大于配置内存缓存区的时候，Prometheus会将数据持久化到磁盘，也可以远程持久化到云端。<br>3. Prometheus通过PromQL、API、Console和其他可视化组件如Grafana、Promdash展示数据。<br>4. Prometheus 可以配置rules，然后定时查询数据，当条件触发的时候，会将告警推送到配置的Alertmanager。<br>5. Alertmanager收到告警的时候，会根据配置，聚合，去重，降噪，最后发出警告。<br><br><br>了解普罗米修斯的数据结构对于了解整个普罗生态非常重要。普罗采用键值对作为其基本的数据结构：<br><img src="https://pic3.zhimg.com/v2-9fa19f80927a39ad7a0ca32a26216dce_b.jpg" referrerpolicy="no-referrer"><br>Key是指标名字，Value是该指标的值，此外Metadata(元信息)也非常重要，也可称之为labels(标签信息)。这些标签信息指定了当前这个值属于哪个云区域下的哪台机器，如果没有labels，数据有可能会被丢失。<br><br>普罗米修斯的监控指标有4种基本类型：<br>1.Counter(计数器):<br>计数器是我们最简单的指标类型。比如你想统计某个网站的HTTP错误总数，这时候就用计数器。<br>计数器的值只能增加或重置为0，因此特别适合计算某个时段上某个时间的发生次数，即指标随时间演变发生的变化。<br>2.Gauges<br>Gauges可以用于处理随时间增加或减少的指标，比如内存变化、温度变化。<br>这可能是最常见的指标类型，不过它也有一定缺点：如果系统每5秒发送一次指标，普罗服务每15秒抓取一次数据，那么这期间可能会丢失一些指标，如果你基于这些数据做汇总分析计算，则结果的准确性会有所下滑。<br>3.Histogram(直方图)<br>直方图是一种更复杂的度量标准类型。它为我们的指标提供了额外信息，例如观察值的总和及其数量，常用于跟踪事件发生的规模。<br>比如，为了监控性能指标，我们希望在有20%的服务器请求响应时间超过300毫秒时发送告警。对于涉及比例的指标就可以考虑使用直方图。<br>4.Summary(摘要)<br>摘要更高级一些，是对直方图的扩展。除了提供观察的总和和计数之外，它们还提供滑动窗口上的分位数度量。分位数是将概率密度划分为相等概率范围的方法。<br>对比直方图：<br>1. 直方图随时间汇总值，给出总和和计数函数，使得易于查看给定指标的变化趋势。<br>
2. 而摘要则给出了滑动窗口上的分位数（即随时间不断变化）。<br><br>随着分布式架构的不断发展和云解决方案的普及，现在的架构已经变得越来越复杂了。<br>分布式的服务器复制和分发成了日常架构的必备组件。我们举一个经典的Web架构，该架构由3个后端Web服务器组成。在该例子中，我们要监视Web服务器返回的HTTP错误的数量。<br>使用普罗米修斯语言，单个Web服务器单元称为实例（主机实例）。该任务是计算所有实例的HTTP错误数量。<br><img src="https://pic1.zhimg.com/v2-005e2ade5d6ccda93a23aeb0b11ec498_b.jpg" referrerpolicy="no-referrer"><br>事实上，这甚至可以说是最简单的架构了，再复杂一点，实例不仅能是主机实例，还能是服务实例，因此你需要增加一个instance_type的标签标记主机或服务。<br>再再复杂一点，同样的IP，可能存在于不同云区域下，这属于不同的机器，因此还需要一个cloud标签，最终该数据结构可能会变为：<br>cpu_usage {job="1", instance="128.0.0.1", cloud="0", instance_type="0"}<br><br>如果使用过基于InfluxDB的数据库，你可能会熟悉InfluxQL。普罗米修斯也内置了自己的SQL查询语言用于查询和检索数据，这个内置的语言就是PromQL。<br>我们前面说过，普罗米修斯的数据是用键值对表示的。PromQL也用相同的语法查询和返回结果集。<br>PromQL会处理两种向量：<br>即时向量：表示当前时间，某个指标的数据向量。<br>时间范围向量：表示过去某时间范围内，某个指标的数据向量。<br>如针对8核CPU的使用率：<br><img src="https://pic1.zhimg.com/v2-37fc2ccf5cbf5a5d7b81340259189cbc_b.jpg" referrerpolicy="no-referrer"><br>知道怎么提取数据后，可视化数据就简单了。<br>Grafana是一个大型可视化系统，功能强大，可以创建自己的自定义面板，支持多种数据来源，当然也支持普罗米修斯。<br>通过配置数据源，Grafana会使用相应的SQL拉取并绘制图表，能直接看到普罗米修斯的各个指标数据图表：<br><img src="https://pic1.zhimg.com/v2-03f3202c77f33638acaa1d0bfdf63c70_b.jpg" referrerpolicy="no-referrer"><br>更方便的是，Grafana有很多仪表盘模板供你使用，只要import模板进行简单的配置，就能得到以下效果：<br><img src="https://pic1.zhimg.com/v2-500fec65386dc4d974387174af985f38_b.jpg" referrerpolicy="no-referrer"><br><br>普罗米修斯非常强大，可以应用到各行各业。<br>5.1 DevOps<br>为了观察整个服务体系是否在正常运转，运维非常需要监控系统。在实例的创建速度和销毁速度一样快的容器世界中，灵活配置各类容器的监控项并迅速安装启动监控是非常重要的。<br>5.2 金融行业<br>金融服务巨头Northern Trust于2017年6月选择普罗米修斯，不是为了进行应用程序的监视，而是为了更好地了解其某些硬件的运作情况。Northern Trust使用普罗米修斯监控其平台上的750多种微服务。<br>5.3 汽车行业<br>Life360是一款用于定位、行车安全和家庭成员之间共享信息的移动应用程序，他们需要给用户提供稳定的定位服务，而原有的监控方案都非常局限，无法监视到所有组件的工作状态。<br>因此该公司使用普罗米修斯来监视其MySQL多主群集和一个12节点的Cassandra环，该环可容纳约4TB的数据。普罗米修斯在初步测试中表现良好。<br>在普罗米修斯的有限部署之后，Life360报告了监控方面的巨大进步，并设想在其数据中心基础架构的其他部分中使用它。<br>总而言之，普罗米修斯这样的分布式监控系统，在未来的世界中用处可能会越来越大，它或许将会成为监控领域寡头式的存在，希望我们能熟悉这个工具，并在以后的架构和实践中使用它解决系统和应用监控的问题。]]></description><link>97-运维\02-监控\01-prometheus(普罗米修斯).html</link><guid isPermaLink="false">97-运维/02-监控/01-Prometheus(普罗米修斯).md</guid><pubDate>Wed, 10 Apr 2024 07:06:30 GMT</pubDate><enclosure url="https://pic3.zhimg.com/v2-0ff3a54dfa1284f61e124405dd25c9aa_b.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0ff3a54dfa1284f61e124405dd25c9aa_b.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[99-ansible]]></title><description><![CDATA[ 
 <br><br>是RedHat提供的一个工具: <a data-tooltip-position="top" aria-label="http://ansible.com" rel="noopener nofollow" class="external-link" href="http://ansible.com" target="_blank">ansible.com</a><br>快速入手文档：<a rel="noopener nofollow" class="external-link" href="https://getansible.com/demo" target="_blank">https://getansible.com/demo</a><br>Ansilbe是一个部署一群远程主机的工具。远程的主机可以是远程虚拟机或物理机， 也可以是本地主机。<br>
Ansilbe通过SSH协议实现远程节点和管理节点之间的通信。理论上说，只要管理员通过ssh登录到一台远程主机上能做的操作，Ansible都可以做到。<br>简单的说 就是我们在 control node(控制节点/管理节点) 上安装ansible ,通过配置 control node 和 managed nodes(受管节点/远程节点) 基于key（无密码的方式）的SSH连接，达到通过control node 批量控制 managed nodes<br><br>
<br>Control node<br>
The machine from which you run the Ansible CLI tools (ansible-playbook&nbsp;,&nbsp;ansible,&nbsp;ansible-vault&nbsp;and others). You can use any computer that meets the software requirements as a control node - laptops, shared desktops, and servers can all run Ansible. Multiple control nodes are possible, but Ansible itself does not coordinate across them, see&nbsp;AAP&nbsp;for such features.
<br>Managed nodes<br>
Also referred to as ‘hosts’, these are the target devices (servers, network appliances or any computer) you aim to manage with Ansible. Ansible is not normally installed on managed nodes, unless you are using&nbsp;ansible-pull, but this is rare and not the recommended setup.
<br>Inventory<br>
A list of managed nodes provided by one or more ‘inventory sources’. Your inventory can specify information specific to each node, like IP address. It is also used for assigning groups, that both allow for node selection in the Play and bulk variable assignment. To learn more about inventory, see&nbsp;<a data-tooltip-position="top" aria-label="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory" rel="noopener nofollow" class="external-link" href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.html#intro-inventory" target="_blank">the Working with Inventory</a>&nbsp;section. Sometimes an inventory source file is also referred to as a ‘hostfile’.
<br><br><br>在 control node上安装ansible<br>$ # Redhat/CentOS Linux上，Ansible目前放在的epel源中
$ # Fedora默认源中包含ansible，直接安装包既可
$ sudo yum install epel-release 
$ sudo yum install ansible -y 
<br><br>配置从管理节点到远程主机之间基于key（无密码的方式）的SSH连接<br>$ # 生成ssh key
$ ssh-keygen
$ # 拷贝ssh key到远程主机，ssh的时候就不需要输入密码了
$ ssh-copy-id remoteuser@remoteserver
$ # ssh的时候不会提示是否保存key
$ ssh-keyscan remote_servers &gt;&gt; ~/.ssh/known_hosts
<br>验证SSH配置: 在管理节点执行下面的ssh命令，既不需要输入密码，也不会提醒你存储key，那就成功啦。<br>$ ssh remoteuser@remoteserver
<br>被管理的远程主机不需要安装特殊的包，只需要python&gt;2.4，RedHat Linux一般安装方式都是默认安装的。<br>ansible中的概念映射到CICD流程中：<br>
<img alt="ansible中的概念映射到CICD流程中" src="97-运维\assets\ansible中的概念映射到cicd流程中.svg"><br><br>ansible通过Inventory(清单)知晓自己需要管理哪些主机  这个清单默认存放在 /etc/ansible/hosts  目录下<br>mail.example.com

[webservers]
foo.example.com
bar.example.com

[dbservers]
one.example.com
two.example.com
three.example.com
<br>
<br>使用Ansilbe命令行管理主机（Ad-hoc command）
<br>使用Ansilbe脚本语言管理主机（脚本语言Playbook）
]]></description><link>97-运维\99-ansible.html</link><guid isPermaLink="false">97-运维/99-ansible.md</guid><pubDate>Wed, 08 May 2024 09:12:24 GMT</pubDate><enclosure url="97-运维\assets\ansible中的概念映射到cicd流程中.svg" length="0" type="image/svg+xml"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;97-运维\assets\ansible中的概念映射到cicd流程中.svg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[01-面试记录]]></title><description><![CDATA[ 
 <br><br><br>苏州<br><br>经常出差 &nbsp;主要做pass交付服务 需要精通华为云产品和开发相关<br><br>k8s docker &nbsp;ci/cd &nbsp;devops<br>
rocketmq怎么确保消息不丢失  <a class="internal-link" data-href="01-rocketmq-学习#rocketmq怎么确保消息不丢失" href="05-中间件\02-mq\01-rocketmq\01-rocketmq-学习.html#rocketmq怎么确保消息不丢失" target="_self" rel="noopener nofollow">01-rocketmq-学习 &gt; rocketmq怎么确保消息不丢失</a><br>
IOC  <a class="internal-link" data-href="03-IOC#IOC" href="02-编程语言\01-java\03-spring\03-ioc.html#IOC" target="_self" rel="noopener nofollow">03-IOC &gt; IOC</a><br>
容器化技术 <a class="internal-link" data-href="../97-运维/01-容器化/01-docker/01-docker入门.md" href="97-运维\01-容器化\01-docker\01-docker入门.html" target="_self" rel="noopener nofollow">01-docker入门</a><br>
介绍一下一个项目 技术架构和功能  <a class="internal-link" data-href="02-介绍项目.md" href="98-面试技巧\02-介绍项目.html" target="_self" rel="noopener nofollow">02-介绍项目</a><br>
微服务划分  <a class="internal-link" data-href="../06-分布式架构/01-微服务/01-微服务划分依据.md" href="06-分布式架构\01-微服务\01-微服务划分依据.html" target="_self" rel="noopener nofollow">01-微服务划分依据</a><br>
有做过秒杀 高并发的场景么<br>
代码管理怎么做的<br>
画图 UML类图 时序图 接口文档 系统设计图<br>2.17 19:30-20:30<br><br><br>苏州<br><br>灾备 &nbsp;研发<br>
sadsad<br>
asd<br><br>几种多线程的实现   <a class="internal-link" data-href="02-多线程#几种多线程的实现" href="02-编程语言\01-java\02-多线程\02-多线程.html#几种多线程的实现" target="_self" rel="noopener nofollow">02-多线程 &gt; 几种多线程的实现</a><br>
多线程间的同步方式 <a class="internal-link" data-href="../96-计算机原理/01-操作系统/02-linux线程间同步的方式.md" href="96-计算机原理\01-操作系统\02-linux线程间同步的方式.html" target="_self" rel="noopener nofollow">02-linux线程间同步的方式</a><br>
分布式锁的使用场景 &nbsp;库存 <a class="internal-link" data-href="../05-中间件/03-redis/03-分布式锁.md" href="05-中间件\03-redis\03-分布式锁.html" target="_self" rel="noopener nofollow">03-分布式锁</a><br>
分布式事务怎么实现的 <a rel="noopener nofollow" class="external-link" href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html" target="_blank">http://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html</a><br>
rocketmq怎么解决重复消费 <a class="internal-link" data-href="01-rocketmq-学习#重复消费问题" href="05-中间件\02-mq\01-rocketmq\01-rocketmq-学习.html#重复消费问题" target="_self" rel="noopener nofollow">01-rocketmq-学习 &gt; 重复消费问题</a><br>慢接口的排查思路 &nbsp; <a class="internal-link" data-href="../95-产线实践/01-慢接口.md" href="95-产线实践\01-慢接口.html" target="_self" rel="noopener nofollow">01-慢接口</a><br>
慢sql怎么优化 &nbsp; 服务器里慢查询 &nbsp;slowLog<br>
分库分表<br>
部署的话 &nbsp;部署过哪些东西 &nbsp;比如前后端 数据库 &nbsp;中间件<br>
docker的挂载 &nbsp;命令  <a class="internal-link" data-href="../97-运维/01-容器化/01-docker/01-docker入门.md" href="97-运维\01-容器化\01-docker\01-docker入门.html" target="_self" rel="noopener nofollow">01-docker入门</a><br>
nginx<br>
蓝绿发布 &nbsp;灰度发布<br>
加密算法<br>
水平越权 &nbsp;纵向越权<br>
数字签名 &nbsp;数字证书<br>
linux常用的指令 &nbsp;<a class="internal-link" data-href="../96-计算机原理/01-操作系统/03-linux常用命令.md" href="96-计算机原理\01-操作系统\03-linux常用命令.html" target="_self" rel="noopener nofollow">03-linux常用命令</a> <a rel="noopener nofollow" class="external-link" href="https://cloud.tencent.com/developer/article/1540697" target="_blank">https://cloud.tencent.com/developer/article/1540697</a><br>
对云 云计算有什么了解<br>
未来规划<br>
怎么提高技术<br>
订单超时 怎么自动关闭 &nbsp;mq 延迟消息 <a class="internal-link" data-href="../05-中间件/02-mq/01-rocketmq/03-延迟消息.md" href="05-中间件\02-mq\01-rocketmq\03-延迟消息.html" target="_self" rel="noopener nofollow">03-延迟消息</a><br>
容灾 备份的了解<br><br><br>上海<br><br>银行 政府金融项目<br><br>描述下开发工作<br>
划分微服务的依据   <a class="internal-link" data-href="../06-分布式架构/01-微服务/01-微服务划分依据.md" href="06-分布式架构\01-微服务\01-微服务划分依据.html" target="_self" rel="noopener nofollow">01-微服务划分依据</a><br>
微服务负载怎么做的 &nbsp;ribbon 网关 <a class="internal-link" data-href="../06-分布式架构/01-微服务/03-负载均衡.md" href="06-分布式架构\01-微服务\03-负载均衡.html" target="_self" rel="noopener nofollow">03-负载均衡</a><br>
分布式场景下订单ID怎么不重复 &nbsp; &nbsp;雪花id以及原理  <a class="internal-link" data-href="../06-分布式架构/99-雪花id.md" href="06-分布式架构\99-雪花id.html" target="_self" rel="noopener nofollow">99-雪花id</a><br>
sql优化做过哪些  <a class="internal-link" data-href="../04-数据库/01-mysql/02-慢sql,锁表问题.md" href="04-数据库\01-mysql\02-慢sql,锁表问题.html" target="_self" rel="noopener nofollow">02-慢sql,锁表问题</a><br>
redis使用场景<br>
lua脚本用过么<br>
linux使用的多么 &nbsp;常用命令有哪些  <a class="internal-link" data-href="../96-计算机原理/01-操作系统/03-linux常用命令.md" href="96-计算机原理\01-操作系统\03-linux常用命令.html" target="_self" rel="noopener nofollow">03-linux常用命令</a> <a rel="noopener nofollow" class="external-link" href="https://cloud.tencent.com/developer/article/1540697" target="_blank">https://cloud.tencent.com/developer/article/1540697</a><br>
springMVC  <a class="internal-link" data-href="../02-编程语言/01-JAVA/03-spring/06-springMVC.md" href="02-编程语言\01-java\03-spring\06-springmvc.html" target="_self" rel="noopener nofollow">06-springMVC</a><br>
AOP实现原理 &nbsp;使用场景  <a class="internal-link" data-href="0401-aop" href="0401-aop" target="_self" rel="noopener nofollow">0401-aop</a><br>
springboot/ springcloud的常用注解<br>
多线程使用场景 &nbsp;  <a rel="noopener nofollow" class="external-link" href="https://www.36dianping.com/news/11257.html" target="_blank">https://www.36dianping.com/news/11257.html</a><br>
动态配置线程池参数  <a class="internal-link" data-href="04-线程池ThreadPoolExecutor#动态化设置线程池参数" href="02-编程语言\01-java\02-多线程\04-线程池threadpoolexecutor.html#动态化设置线程池参数" target="_self" rel="noopener nofollow">04-线程池ThreadPoolExecutor &gt; 动态化设置线程池参数</a><br>面试官比较拉胯 &nbsp;问问题很虚 &nbsp;说我涉及面广但不深 &nbsp;呵呵 &nbsp;问的问题不是常规八股文 &nbsp;直接pass<br><br><br>上海 迈皋桥<br><br>从代码写出来 到实际运行 经历了哪些过程 &nbsp;<br>
编译-&gt;class文件-&gt;jvm启动-&gt;类加载-&gt;找主类<br>
详细说说jvm的类加载  <a class="internal-link" data-href="00-总览#JVM的类加载机制" href="02-编程语言\01-java\06-jvm\00-总览.html#JVM的类加载机制" target="_self" rel="noopener nofollow">00-总览 &gt; JVM的类加载机制</a><br>
线程不安全的集合变成线程安全的  <a class="internal-link" data-href="07-线程-集合#线程不安全的集合变成线程安全的" href="02-编程语言\01-java\02-多线程\07-线程-集合.html#线程不安全的集合变成线程安全的" target="_self" rel="noopener nofollow">07-线程-集合 &gt; 线程不安全的集合变成线程安全的</a><br>
synchronized和juc包的区别  <a class="internal-link" data-href="06-synchronized#synchronized和juc包的区别" href="02-编程语言\01-java\02-多线程\06-synchronized.html#synchronized和juc包的区别" target="_self" rel="noopener nofollow">06-synchronized &gt; synchronized和juc包的区别</a><br>
hashmap put和get过程做了哪些操作  <a class="internal-link" data-href="01-map#hashmap" href="02-编程语言\01-java\01-集合\01-map.html#hashmap" target="_self" rel="noopener nofollow">01-map &gt; hashmap</a><br>
使用hashmap需要注意哪些问题？？ <a class="internal-link" data-href="01-map#使用hashmap要注意哪些问题" href="02-编程语言\01-java\01-集合\01-map.html#使用hashmap要注意哪些问题" target="_self" rel="noopener nofollow">01-map &gt; 使用hashmap要注意哪些问题</a><br>
hashcode equals 一定要一块重写么 为什么<br>
多线程的使用场景  <a class="internal-link" data-href="04-线程池ThreadPoolExecutor#线程池的使用场景" href="02-编程语言\01-java\02-多线程\04-线程池threadpoolexecutor.html#线程池的使用场景" target="_self" rel="noopener nofollow">04-线程池ThreadPoolExecutor &gt; 线程池的使用场景</a><br>
创建线程的方式 <a class="internal-link" data-href="02-多线程#几种多线程的实现" href="02-编程语言\01-java\02-多线程\02-多线程.html#几种多线程的实现" target="_self" rel="noopener nofollow">02-多线程 &gt; 几种多线程的实现</a><br>
runnable callable区别 <a class="internal-link" data-href="02-多线程#runnable callable区别" href="02-编程语言\01-java\02-多线程\02-多线程.html#runnable_callable区别" target="_self" rel="noopener nofollow">02-多线程 &gt; runnable callable区别</a><br>
线程池参数 运行原理 <a class="internal-link" data-href="../02-编程语言/01-JAVA/02-多线程/04-线程池ThreadPoolExecutor.md" href="02-编程语言\01-java\02-多线程\04-线程池threadpoolexecutor.html" target="_self" rel="noopener nofollow">04-线程池ThreadPoolExecutor</a><br>
线程池 execute &nbsp;submit区别 <a class="internal-link" data-href="04-线程池ThreadPoolExecutor#submit和execute区别" href="02-编程语言\01-java\02-多线程\04-线程池threadpoolexecutor.html#submit和execute区别" target="_self" rel="noopener nofollow">04-线程池ThreadPoolExecutor &gt; submit和execute区别</a><br>
spring &nbsp;springboot常用注解<br>
spring依赖注入的方式 &nbsp;依赖查找 <a class="internal-link" data-href="02-DI#依赖注入三种方式" href="02-编程语言\01-java\03-spring\02-di.html#依赖注入三种方式" target="_self" rel="noopener nofollow">02-DI &gt; 依赖注入三种方式</a><br>
jdk动态代理和cglib动态代理的区别 &nbsp;cglib是所有的类都能代理么 &nbsp;final修饰的类可以被代理么 &nbsp;ASM  <a class="internal-link" data-href="04-AOP#cglib为什么不能代理private,final" href="02-编程语言\01-java\03-spring\04-aop.html#cglib为什么不能代理private,final" target="_self" rel="noopener nofollow">04-AOP &gt; cglib为什么不能代理private,final</a><br><br>一般 沟通有点障碍？ 回答也一般<br><br><br>上海<br><br>hr，考勤相关系统<br><br>try catch catch中return了 finally的代码块还能执行么 &nbsp;为什么  会  就是机制<br>
接口和抽象类的区别 &nbsp; <a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/94770324" target="_blank">https://zhuanlan.zhihu.com/p/94770324</a><br>
用过哪些线程安全的集合 &nbsp;<a class="internal-link" data-href="../02-编程语言/01-JAVA/01-集合/02-线程安全的集合.md" href="02-编程语言\01-java\01-集合\02-线程安全的集合.html" target="_self" rel="noopener nofollow">02-线程安全的集合</a>  什么场景下会用到这些集合<br>
threadLocal的使用场景 <a class="internal-link" data-href="../02-编程语言/01-JAVA/02-多线程/03-ThreadLocal.md" href="02-编程语言\01-java\02-多线程\03-threadlocal.html" target="_self" rel="noopener nofollow">03-ThreadLocal</a><br>
慢sql优化有做过么 讲讲 <a class="internal-link" data-href="../04-数据库/01-mysql/02-慢sql,锁表问题.md" href="04-数据库\01-mysql\02-慢sql,锁表问题.html" target="_self" rel="noopener nofollow">02-慢sql,锁表问题</a><br>
索引失效场景  <a class="internal-link" data-href="../04-数据库/01-mysql/04-索引失效场景.md" href="04-数据库\01-mysql\04-索引失效场景.html" target="_self" rel="noopener nofollow">04-索引失效场景</a><br>
a,b,c联合索引 &nbsp;语句是 &nbsp;c b &nbsp;a &nbsp;索引会生效么<br>
redis 缓存穿透 击穿 &nbsp;雪崩的概念 &nbsp;  <a class="internal-link" data-href="../05-中间件/03-redis/04-缓存击穿(失效)，穿透，雪崩.md" href="05-中间件\03-redis\04-缓存击穿(失效)，穿透，雪崩.html" target="_self" rel="noopener nofollow">04-缓存击穿(失效)，穿透，雪崩</a><br>
项目中有成就感的事<br>
手写冒泡排序算法  <br><br><br>苏州<br><br>部门 &nbsp;大能力部门 400多人 &nbsp;核心业务 人事 考勤 &nbsp;薪资 干部/绩效管理 主要是人力资源相关 BRT:财务 erp 供应链 大能力平台？<br><br>14薪 餐补 交通补贴<br><br>redis工作模式(比其他缓存好在哪里)<br>
redis 缓存穿透 击穿 &nbsp;雪崩的概念 <a class="internal-link" data-href="../05-中间件/03-redis/04-缓存击穿(失效)，穿透，雪崩.md" href="05-中间件\03-redis\04-缓存击穿(失效)，穿透，雪崩.html" target="_self" rel="noopener nofollow">04-缓存击穿(失效)，穿透，雪崩</a><br>
mysql索引失效场景 <a class="internal-link" data-href="../04-数据库/01-mysql/04-索引失效场景.md" href="04-数据库\01-mysql\04-索引失效场景.html" target="_self" rel="noopener nofollow">04-索引失效场景</a><br>
主要负责项目的核心技术点介绍<br>
项目开发中用到哪些设计模式呢 &nbsp;举例  策略，单例(连接池)  代理<br>
dubbo有用过么<br>
注册中心 &nbsp;eureka,nacos &nbsp;区别  <a rel="noopener nofollow" class="external-link" href="https://juejin.cn/post/7068065361312088095#heading-24" target="_blank">https://juejin.cn/post/7068065361312088095#heading-24</a><br>
hashmap &nbsp;concurrenthashmap <a class="internal-link" data-href="../02-编程语言/01-JAVA/01-集合/01-map.md" href="02-编程语言\01-java\01-集合\01-map.html" target="_self" rel="noopener nofollow">01-map</a><br>
反转链表怎么实现<br>
链表中插入<br><br>面试官人可以 就是面试经常性空白 我的回答也一般 感觉没戏<br><br><br>上海<br><br>hr，考勤相关系统<br><br>工作中遇到的印象深刻的线上问题  同步 异步线程池<br>
订单数据延迟的一些相关处理<br>
对下一份工作的一个期待<br>
工作中技术或者业务上做过什么努力么<br>
最近研究什么技术 让你觉得对你很有帮助呢<br>
什么样的场景下会做分库分表 或者你做过分库分表么 什么场景 &nbsp;怎么做的<br>
idea写代码 &nbsp;将字符串转化成数字 &nbsp;例如 "100" -&gt; 100<br>
写代码这件事上 &nbsp;你工作也四五年了 &nbsp;你认为你还会写多久<br><br><br>苏州<br><br>云(类似阿里云)<br><br>对springcloud的整体理解<br>
网关的源码看过么<br>
网关是怎么通过服务名找到对应的微服务的 谈谈你的理解<br>
k8s使用过么<br>
未来规划<br>
工作研发过程中成就感或者比较印象比较深的场景/情况<br>
后面都问了一些软技能之类的东西 &nbsp;你对技术的热爱度 创新性想法啊<br><br>hr说是二选一 没有我 &nbsp;呵呵 薪资问题估计<br><br>声明式事务失效的场景 <a class="internal-link" data-href="05-事务#事务失效" href="02-编程语言\01-java\03-spring\05-事务.html#事务失效" target="_self" rel="noopener nofollow">05-事务 &gt; 事务失效</a><br>
springcloud服务注册怎么实现的<br>
redis持久化机制  <a class="internal-link" data-href="../05-中间件/03-redis/05-redis持久化.md" href="05-中间件\03-redis\05-redis持久化.html" target="_self" rel="noopener nofollow">05-redis持久化</a><br>
redis搭建 哨兵 集群<br>
rocketmq和kafka的区别 <a class="internal-link" data-href="01-rocketmq-学习#rocketmq和kafka的区别" href="05-中间件\02-mq\01-rocketmq\01-rocketmq-学习.html#rocketmq和kafka的区别" target="_self" rel="noopener nofollow">01-rocketmq-学习 &gt; rocketmq和kafka的区别</a><br>
REST &nbsp;RPC的区别 协议 http tcp  <a rel="noopener nofollow" class="external-link" href="https://zhuanlan.zhihu.com/p/102760613" target="_blank">https://zhuanlan.zhihu.com/p/102760613</a><br>
业务中用过哪些设计模式 介绍一下  策略，单例(连接池)  代理<br><br><br><br>&nbsp;驻场 数据中台服务<br><br>你简历上写的搭建后端架构 是怎么搭建的<br>
springboot启动流程<br>
stater的作用<br>
springbootApplication.run的<br>
starter中的配置类里涉及到哪些注解<br>
springboot启动 怎么启动tomcat<br>
springcloud用到哪些组件<br>
组件的作用 比如负载均衡 为什么需要负载均衡 &nbsp;为什么不用nginx呢<br>
微服务架构下 &nbsp;A服务调用B服务 怎么调用过去的<br>
熔断和降级有什么区别 &nbsp;服务限流怎么做的<br>
数据库设计包含什么呢 &nbsp; 设计数据库需要注意什么呢 &nbsp;注意点<br>
数据表最大的有多少 怎么做查询优化的<br>
代码走查的话 &nbsp;都是检查什么呢<br>
内存泄漏 一般什么情况会导致内存泄漏呢 &nbsp;怎么排查 解决举例子<br>
ThreadLocal实现原理 怎么导致的内存泄漏<br>
强引用 软引用 弱引用 虚引用 区别<br>
你平时写博客 都写什么呢<br>
sharding sphere 你写了一个demo &nbsp;分库分表的分片算法 &nbsp; 雪花id的生成规则<br>
seata<br>
项目中用到分布式事务么 &nbsp;假如别的服务调用你 你更新了数据库 &nbsp;然后调用第三方服务 &nbsp;报错了 你怎么处理的 &nbsp;你用重试的话 不是会超时么<br>
k8s了解么<br>
你们项目用的部署方式是什么<br><br><br>上海<br><br><br>springcloud用了哪些组件<br>
熔断 限流的业务场景 &nbsp;<a rel="noopener nofollow" class="external-link" href="https://www.jianshu.com/p/87c5406c1ba1" target="_blank">https://www.jianshu.com/p/87c5406c1ba1</a><br>
限流你怎么配置的 配置的多大<br>
（1）请求最大次数<br>
circuit Breaker. request Volume Threshold(默认值:20个请求)<br>
（2）滚动窗口<br>
metrics .rolling Stats. time ln Milliseconds(默认值:10秒)<br>
（3）失败百分比<br>
circuit Breaker. error Threshold Percentage(默认值:&gt;50%)<br>
线程池<br>
线程安全的java集合类 &nbsp;copyOnWriteList<br>
读写分离的操作适用于哪些场景<br>
异步的工具类<br>
ThreadLocal<br>
java的锁用过哪些 &nbsp;synchorized volatile &nbsp;juc包 &nbsp;AQS<br>
JVM内存分配 &nbsp;各分区的功能<br>
JVM调优 JVM的问题 解决思路 &nbsp; 具体的场景结合业务说下<br>
mysql索引 &nbsp;B+树和B树 特点 区别<br>
聚簇索引和非聚簇索引<br>
sql优化 &nbsp;你工作中一般写sql时哪些注意事项(优化相关的)<br>
索引越多越好么 &nbsp;太多的坏处<br>
联合索引 最左原则<br>
索引失效的场景<br>
分库分表用过 了解过么<br>
redis数据结构 除了那五种之外的 再说些<br>
AOP用过么 使用场景<br>
事务的隔离机制<br>
声明式事务失效的场景 &nbsp;事务方法A中调用另一个方法B &nbsp;B遇到异常会A的事务还会生效么 &nbsp;如果想让它生效怎么做<br>
mybatis一级缓存 &nbsp;二级缓存<br>
mybatisPlus<br>
rockermq和kafka的区别<br>
消息丢失 重复消费的问题<br>
zookeepr了解么<br>
RPC远程调用知道么<br><br><br><br>&nbsp;驻场 数据中台服务<br><br>持续优化接口性能，提高响应速度 怎么做的 &nbsp;时间说的少点 &nbsp;优化力度别太大<br>
建索引都是怎么建的<br>
索引的结构 &nbsp; 回表操作<br>
积分 库存 等分布式场景下 怎么保证数据一致性 &nbsp;分布式锁会降低性能<br>
springcloud 用了哪些组件<br>
平时工作遇到哪些棘手的问题<br>
mybatis怎么和spring做集成的 &nbsp;代理模式<br>
es你们用的话 &nbsp;数据量是多大<br>
es和db怎么保持一致<br>
rocketmq事务消息<br>
消息发送不丢失怎么保证<br>
内存暴增 cpu暴涨的场景 &nbsp;怎么排查解决的<br>
volatile主要解决了哪些问题<br>
webpack打包<br>
基于什么来拆分微服务呢 &nbsp; 聚合根实体？？<br>
代码走查 怎么走查的<br><br><br><br>&nbsp;云服务<br><br>谈谈你对springcloud的理解<br>
从0到1搭建一个springcloud的微服务的建构的话 &nbsp;需要引入哪些组件 分别起到什么作用<br>
网关里鉴权是怎么实现的<br>
不需鉴权的接口 怎么实现 &nbsp;白名单<br>
负载均衡怎么实现 &nbsp;用ribbon的话怎么配置呢 &nbsp;譬如 a &nbsp;b1 b2 b3 &nbsp;a访问b怎么均衡的访问呢<br>
a访问b需要经过网关么<br>
aop用过么 &nbsp;什么场景<br>
多线程用过么 &nbsp;使用场景<br>
redis使用场景 基本数据结构<br>
慢sql的优化策略<br>
哪些操作会引发全表扫描<br><br>sql注入<br>
数据库里的int类型数据范围<br>
数据库事务的特性<br>
mysql的事务类型<br>
sql调优 sql语句优化<br>
sql索引类型<br>
mysql索引失效的场景<br>
mysql主从同步的机制<br>
mybatis和jpa的区别<br>
#{}和${}<br>
JVM内存模型<br>
垃圾回收策略<br>
垃圾回收器有哪些<br>
synroized和volatile区别  和Lock<br>
集合用哪些  hashmap  concurrentHashMap<br>
线程池核心参数  工作原理<br>
线程的状态<br>
包装类型  int  Integer  Interger == int<br>
什么时候需要重写 hashcode  equals  重写注意事项<br>
http和https区别<br>
公钥私钥<br>
1000万数字  找出最小的十个<br>
链表的操作   怎么判断是否环链表   反转链表<br>
大表 分页查询 怎么优化  用id的话跳号怎么<br>
负载均衡  nginx的基本使用   负载均衡的一些常用算法？<br>
B+树<br>
深拷贝 浅拷贝<br><br>mysql数据量大么   慢sql怎么优化  执行计划看哪些关键字<br>
delete  truncate区别<br>
redis数据结构   用法  场景  怎么确保缓存和数据的一致性<br>
先改缓存再改数据库  如果更新数据库失败了  <a rel="noopener nofollow" class="external-link" href="https://note.dolyw.com/cache/00-DataBaseConsistency.html#%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-vs-%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98" target="_blank">https://note.dolyw.com/cache/00-DataBaseConsistency.html#%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98-vs-%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98</a><br>
volatile和synchorized<br>
ABA问题<br>
线程间通信方式   IO的分类<br>
JVM调优  内存 cpu之类的线上问题处理过么<br>
jvm内存模型<br>
用mq来解耦和多线程那种异步的区别<br>
怎么避免mq里边的消息堆积<br><br><br>智能井盖 视频ai识别  数字哨兵<br><br>数组 去重<br>
StringBuffer  StringBuilder区别<br>
常见的排序算法有哪些   快速排序怎么操作的<br>
线程池核心参数 原理<br>
4核8g机器  线程池怎么配置<br>
jvm调优 做过么  怎么自动dump呢  怎么配置的<br>
springboot常用注解<br>
@Resource  @Autowired区别  为什么建议用@Resource<br>
spring默认单例模式  并发场景下会有线程安全的问题么  为什么<br>
声明式事务失效的场景<br>
mysql优化<br>
聚簇索引和非聚簇索引区别<br>
b+树和B树的区别<br>
redis主要做什么<br>
redis数据结构<br>
redis删除策略<br>
redis挂了 数据丢失问题  还是持久化问题<br>
rocketmq有哪几个部分组成   nameserver有什么用<br>
重复消费的问题<br>
rocketmq和kafka的区别    kafka没有延迟队列么？<br>
延迟队列一般怎么用啊<br>
注册中心用过哪些    nacos怎么做到数据隔离的  namespace<br>
linux统计日志中某个关键字出现的次数<br>
项目中碰到的难点<br>
平时阅读过哪些开源项目的源码<br>
springboot启动做了哪些操作<br><br>订单的话 用户买了课程之后 业务/数据流转  服务链路<br>
redis线上是什么模式<br>
线上环境的排障<br>
mysql  CPU飙升遇到过么  什么场景<br><br><br>上海<br><br><br>最近项目的规模<br>
如何保证消息不丢失   重复消费<br>
redis使用场景<br>
分库分表   分片的主键选的什么<br>
灰度发布方案   难点为什么在数据库那边<br>
限流做过么   具体有哪些算法<br>
B树的索引数据结构  和  B+树想比有什么优点<br>
自旋锁的应用场景<br>
多线程用过么   什么场景  完成了什么功能<br>
排查产线问题 举例子<br>
线程池的阻塞队列是有界还是无界  有界和无界的区别<br>
java中一个对象可变和不可变  BigDecimal可变还是不可变<br>
new Bigdecamal a    a.multipy（b）  a会变么<br>
String 不可变么<br>
IOC容器的初始化过程<br>
代码中用过spring IOC的拓展么   怎么用的<br>
搭建项目结构  做了什么<br><br><br>
<br>赞同自研  低代码那种  主要搞配置 数据库脚本  
<br>上海那边银行的驻场<br>
上班早上八点半  几乎不加班 
<br><br>分库分表之类的优化之类的有做过么<br>
数据库清理机制  临时表不需要的数据清理<br>
springboot想比springMVC有哪些优势呢<br>
springboot常用直接有哪些呢<br>
springboot启动流程<br>
mysql索引提升查询效率的原理<br>
索引有没有生效怎么看<br>
哪些场景下索引会失效<br>
数据库慢查询或者死锁遇到么  什么场景 怎么定位处理<br>
redis用的什么架构   集群什么模式<br>
缓存击穿  穿透  雪崩<br><br><br>-消息推送<br>
docker+k8s  k8s做原生的微服务  服务发现  没有用springcloud<br><br>搭建项目架构怎么搭建的   模块划分？<br>
java平时会用到哪些数据结构<br>
map的数据结构<br>
hashmap多线程场景下会遇到哪些问题  原因<br>
synchonrized说说你的了解<br>
spring IOC   使用场景<br>
AOP  原理 使用场景<br>
spring依赖注入 循环依赖<br>
jvm内存分配的了解  新生代  老生代内部空间怎么分配的<br>
GC算法<br>
线上JVM调优   内存cpu告警 报错<br>
慢接口怎么定位  优化<br>
慢sql优化<br>
mysql索引怎么维护的<br>
B+树讲讲呢<br>
项目怎么部署的  CI/CD的持续化集成<br>
项目运行环境<br>
docker    k8s了解过么<br>
docker的原理大概讲讲呢<br>
redis主要做什么<br>
redis做分布式锁怎么实现的<br>
redis遇到问题怎么处理<br>
es做什么  es的优势有哪些呢<br>
es是集群部署的么   几个节点   主从怎么同步的   高可用怎么保证的<br>
redis热点数据  怎么防止缓存击穿<br>
开发中用到设计模式么   使用场景呢<br>
接受新项目  怎么熟悉  上手开发  定位bug<br>
typescript和js的区别<br>
平时有看书  或者学习新知识么<br>
算法平时有刷么<br><br><br><br>mysql有一列  100多字符串  前半部分重复率很高  怎么设计提高查询效率<br>
库存超卖问题怎么避免<br>
线程池的理解<br>
为什么会出现并发<br>
IO的了解  linux系统IO的方式<br>
http协议理解么    建立一次http连接的流程？<br>
我封装了一个jar包  里边有一个配置类  想把它引入进来  怎么做  spring.factories  这块的源码看过没<br>
事务的传播类型  实现原理<br>
排行榜功能怎么实现   zset<br>
redis  bitset了解过么<br>
redis 缓存击穿  穿透  雪崩<br>
你了解哪些设计模式<br>
单例模式怎么实现  并发场景下怎么保证单例呢<br>
rocketmq怎么保证消息不丢失的<br>
集群和广播模式的区别？？<br>
进程和线程有什么区别？？<br><br><br>redis跳表<br>
redis实现分布式锁的细节   锁超时之类的  异常时锁释放的问题 另起一个线程去刷新<br>
springcloud哪些组件<br>
用nacos遇到过哪些问题   性能方面能达到预期么  有没有做过优化<br>
技术深造  职业规划<br><br><br>介绍下你的技术栈  工作中遇到哪些问题<br>
synchronized和lock有什么区别<br>
栈和队列的区别<br>
sleep和wait区别<br>
设计mysql表要注意哪些<br>
linux命令： 跳板机传输文件  解压缩  压缩<br>
做题 我没做 尴尬了<br><br>运营管理部门的老大<br>
全栈  团队八个人   后端偏多   所以要找一个全栈<br><br>普通的类和抽象类区别<br>
String  StringBuilder   StringBuffer  区别  是否可变 <a class="internal-link" data-href="01-xx#可变对象 不可变对象" href="02-编程语言\01-java\00-基础\01-xx.html#可变对象_不可变对象" target="_self" rel="noopener nofollow">01-xx &gt; 可变对象 不可变对象</a>  <a class="internal-link" data-href="00-基本类型#String" href="02-编程语言\01-java\00-基础\00-基本类型.html#String" target="_self" rel="noopener nofollow">00-基本类型 &gt; String</a><br>
Integer int <a class="internal-link" data-href="00-基本类型#Integer" href="02-编程语言\01-java\00-基础\00-基本类型.html#Integer" target="_self" rel="noopener nofollow">00-基本类型 &gt; Integer</a><br>
优先队列  priorityQueue<br>
java中线程安全相关的东西<br>
volatile  synchorized  <a class="internal-link" data-href="../02-编程语言/01-JAVA/02-多线程/05-多线程jvm实现(volatile,synchronized).md" href="02-编程语言\01-java\02-多线程\05-多线程jvm实现(volatile,synchronized).html" target="_self" rel="noopener nofollow">05-多线程jvm实现(volatile,synchronized)</a>  <a class="internal-link" data-href="../02-编程语言/01-JAVA/02-多线程/06-synchronized.md" href="02-编程语言\01-java\02-多线程\06-synchronized.html" target="_self" rel="noopener nofollow">06-synchronized</a><br>
synchorized锁升级过程  <a class="internal-link" data-href="../02-编程语言/01-JAVA/02-多线程/06-synchronized.md" href="02-编程语言\01-java\02-多线程\06-synchronized.html" target="_self" rel="noopener nofollow">06-synchronized</a>]]></description><link>98-面试技巧\01-面试记录.html</link><guid isPermaLink="false">98-面试技巧/01-面试记录.md</guid><pubDate>Tue, 18 Jun 2024 06:02:35 GMT</pubDate></item><item><title><![CDATA[02-介绍项目]]></title><description><![CDATA[ 
 <br><br>后端-&gt;前端-数据库-&gt;中间件-&gt;鉴权-&gt;部署<br>
<br>后端采用 Spring Boot 框架进行开发，使用 MyBatis，mybatisplus 作为 ORM 框架，采用 Swagger,kenf4j 生成 API 文档；
<br>前端采用 Vue.js 框架进行开发，使用 Element UI 组件库，使用 Axios 发送 AJAX 请求；
<br>数据库使用 MySQL
<br>使用 Redis 缓存常用数据，分布式锁，服务间共享信息(token)
<br>使用 RocketMQ 实现异步下单流程,限流，服务间解耦；
<br>使用es做日志存储，商品数据的全文检索
<br>使用 Spring Security 和 JWT 实现用户认证和授权；
<br>部署环境使用 Docker，k8s 容器。
]]></description><link>98-面试技巧\02-介绍项目.html</link><guid isPermaLink="false">98-面试技巧/02-介绍项目.md</guid><pubDate>Wed, 10 Apr 2024 07:06:43 GMT</pubDate></item><item><title><![CDATA[面试技巧]]></title><description><![CDATA[ 
 <br>
<br>提前演练  准备一些面试题  假装面试官在问你  不要心里想  用嘴巴说出来  说出你会怎么回答
<br>避重就轻   自己会的  记忆比较清晰的  使劲说  多说点  这样压缩面试时间  你不会的问题也许就不会被问到
]]></description><link>98-面试技巧\面试技巧.html</link><guid isPermaLink="false">98-面试技巧/面试技巧.md</guid><pubDate>Wed, 10 Apr 2024 07:06:47 GMT</pubDate></item><item><title><![CDATA[hexo]]></title><description><![CDATA[ 
 <br>github  hexo<br>
hexo:<br>
官方文档：<a rel="noopener nofollow" class="external-link" href="https://hexo.io/zh-cn/docs/" target="_blank">https://hexo.io/zh-cn/docs/</a><br>参考：<a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/u011475210/article/details/79023429" target="_blank">https://blog.csdn.net/u011475210/article/details/79023429</a><br>参考：<a rel="noopener nofollow" class="external-link" href="http://visugar.com/2017/05/04/20170504SetUpHexoBlog/" target="_blank">http://visugar.com/2017/05/04/20170504SetUpHexoBlog/</a><br>参考：<a rel="noopener nofollow" class="external-link" href="https://blog.csdn.net/baozhiqiangjava/article/category/7495913" target="_blank">https://blog.csdn.net/baozhiqiangjava/article/category/7495913</a><br>next:<br>官：<a rel="noopener nofollow" class="external-link" href="http://theme-next.iissnan.com/getting-started.html" target="_blank">http://theme-next.iissnan.com/getting-started.html</a><br>一样的 nextzhuti : <a rel="noopener nofollow" class="external-link" href="https://crossoverjie.top/" target="_blank">https://crossoverjie.top/</a><br>gittalk : <a rel="noopener nofollow" class="external-link" href="https://asdfv1929.github.io/2018/01/20/gitalk/" target="_blank">https://asdfv1929.github.io/2018/01/20/gitalk/</a>]]></description><link>99-个人博客\01-hexo\hexo.html</link><guid isPermaLink="false">99-个人博客/01-hexo/hexo.md</guid><pubDate>Wed, 10 Apr 2024 07:06:50 GMT</pubDate></item><item><title><![CDATA[AllBooks]]></title><description><![CDATA[ 
 ]]></description><link>allbooks.html</link><guid isPermaLink="false">AllBooks.md</guid><pubDate>Fri, 07 Mar 2025 08:50:56 GMT</pubDate></item><item><title><![CDATA[cs-learning-vault]]></title><description><![CDATA[ 
 <br><br>计算机技术学习仓库-使用obsidian构建<br>
哈哈哈]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Sat, 22 Feb 2025 06:22:11 GMT</pubDate></item></channel></rss>